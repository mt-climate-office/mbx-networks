from typing import Any, NewType, Literal
from dataclasses import dataclass, field
from enum import Enum
import re
from textwrap import indent


class VarType(Enum):
    PUBLIC = "Public"
    CONST = "Const"
    DIM = "Dim"
    ALIAS = "Alias"

    def __str__(self):
        return self.value


class DataType(Enum):
    FLOAT = "Float"
    BOOLEAN = "Boolean"
    LONG = "Long"
    STRING = "String"

    @classmethod
    def _missing_(cls, value):
        # Handle custom string types like "String20"
        if isinstance(value, str) and re.match(r"^String\d+$", value):
            length = int(
                value[6:]
            )  # Extract the length from the value (e.g., 20 from "String20")

            # Dynamically create a new Enum member
            member = object.__new__(cls)
            member._value_ = value
            member._name_ = cls.STRING  # Optional: Set to None because it doesn't correspond to a predefined member
            member.length = length
            return member

        return None

    def __str__(self):
        try:
            return f"{self.value} * {self.length}"
        except AttributeError:
            return self.value


@dataclass
class Variable:
    name: str
    var_type: VarType
    data_type: DataType | None = None
    value: str | int | float | None = None
    units: str | None = None
    rename_to: str | None = None
    meta: dict[str, Any] = field(init=False)

    def __post_init__(self):
        self.meta = {}
        if self.var_type == VarType.CONST and self.value is None:
            raise ValueError("When defining a Const type, value must not be none.")
        if self.var_type == VarType.ALIAS:
            assert self.value is not None, (
                "When defining an Alias, a value must be defined."
            )
            self.meta["orig_name"] = self.name
            self.name = self.value

    def __str__(self):
        return self.rename_to or self.name

    def declaration_str(self) -> str:
        v_name = self.name if self.var_type != VarType.ALIAS else self.meta["orig_name"]
        out = f"{self.var_type} {v_name}"

        if self.var_type in [VarType.CONST, VarType.ALIAS]:
            val = self.rename_to or self.value
            out = f"{out} = {val}"

        if self.data_type is not None:
            out = f"{out} as {str(self.data_type)}"

        if self.units is not None:
            out = f"{out} : Units {self.rename_to or self.name} = {self.units}"

        return out


Constant = NewType("Constant", int)
Expression = NewType("Expression", str)
Array = NewType("Array", Variable)
Integer = NewType("Integer", int)
ConstantInteger = NewType("ConstantInteger", int)


def ACPower(
    DestAC: Variable,
    ConfigAC: Literal["1", "2", "3"],
    LineFrq: Constant,
    ChanV: Constant,
    MultV: Constant,
    MaxVrms: Constant,
    ChanI: Constant,
    MultI: Constant,
    MaxIrms: Constant,
    RepsI: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acpower.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acpower.htm).

                The ACPower instruction is suitable for net-metering applications, as well as variable-frequency (wild AC) applications. Potential and current transformers must be used to measure the voltage and current using the datalogger.
    WARNING: Working with live electrical equipment is dangerous! The user is responsible for ensuring all wiring conforms to local safety regulations and that the enclosure is labeled accordingly.

    Args:
                    DestAC (Variable): Variable or variable array in which to store the measurement results. The number of values returned depends upon the option chosen for the configuration parameter. If DestAC is not dimensioned large enough to hold all values, only those values that will fit into the array will be stored.

            ConfigAC (Constant): Determines the type of measurement that will be made. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (Single-phase with one voltage measurement and the number of current measurements specified by the RepsI parameter. This configuration monitors a single load with one voltage and one current measurement, or multiple loads in sub-panel applications with one voltage and multiple current measurements.), 2 (Split-phase with one voltage measurement and two current measurements. This configuration is typical of residential service-entry panels, as well as residential and commercial distribution panels. Split-phase configurations have two line (or “hot”) conductors plus a neutral conductor.), 3 (Three-phase ‘Y’, four-conductor, configurations with three voltage measurements and three current measurements. This configuration is typical of commercial entry panels and commercial distribution panels. The four conductors are three line (or “hot”) conductors plus a neutral conductor.)

            LineFrq (Constant): The expected line frequency in hertz. Valid entries are 60, 50, or a value between 2 and 20. A value between 2 and 20 indicates measurements from variable-frequency power, where LineFrq is the minimum frequency to be measured. Note that smaller values for LineFrq increase the measurement and processing time for this instruction. The maximum frequency for the variable-frequency mode is 480 Hz and independent of the 2- to 20-Hz minimum frequency.

            ChanV (Constant): The single-ended channel for the voltage measurement. For single- and split-phase configurations (ConfigAC = 1 or 2), the datalogger makes a voltage measurement at ChanV. For three-phase configurations (ConfigAC = 3), the datalogger makes three voltage measurements on increasing consecutive channels starting at ChanV.

            MultV (Constant): The potential transformer multiplier represented as input Volts per output mVolts. A typical value is 115 V/333 mV (or 0.345345).

            MaxVrms (Constant): The expected maximum RMS Root-mean square, or quadratic mean. A measure of the magnitude of wave or other varying quantities around zero. voltage to measure. MaxVrms is specified at the primary of the potential transformer, or equivalently, the non-logger side of the potential transformer. Typical values are 120 or 240. The datalogger uses MultV and MaxVrms to calculate which input range to use for the voltage measurement.

            ChanI (Constant): The single-ended channel for the current measurement. For single-phase configurations (ConfigAC = 1) with RepsI greater than 1, the datalogger makes multiple current measurements on increasing consecutive channels starting at ChanI. For split-phase configurations (ConfigAC = 2), the datalogger makes two current measurements on increasing consecutive channels starting at ChanI. For three-phase configurations (ConfigAC = 3), the datalogger makes three current measurements on increasing consecutive channels starting at ChanV.

            MultI (Constant): The current transformer multiplier as input Amps per output mVolts. A typical value is 15 Amps/333 mV (or 0.045045).

            MaxIrms (Constant): The expected maximum RMS Root-mean square, or quadratic mean. A measure of the magnitude of wave or other varying quantities around zero. current to measure. MaxIrms is specified at the primary of the current transformer, or equivalently, the non-logger side of the current transformer. The datalogger uses MultI and MaxIrms to calculate which input range to use for the current measurement(s).

            RepsI (Constant): The number of current measurements to make on consecutive single-ended input channels. This parameter is used only in configuration 1 and is ignored by the datalogger for configurations 2 and 3.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ACPower({DestAC},{ConfigAC},{LineFrq},{ChanV},{MultV},{MaxVrms},{ChanI},{MultI},{MaxIrms},{RepsI})"


def AddPrecise(PrecisionVariable: Variable, X: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/addprecise.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/addprecise.htm).

        In this function, the variable X is added to the PrecisionVariable. Every reference to the PrecisionVariable will cause a 32 bit extension of its mantissa to be saved and used internally. A normal single precision float has 24 bits of mantissa; therefore, this new precision is 56 bits. This function can be useful when trying to find the difference between two high precision variables.

    Args:
            PrecisionVariable (Variable): The variable that will be affected by the precision move or add.

    X (Variable): The value that will be moved to or added to the PrecisionVariable. It may or may not be a high precision variable, depending upon whether it has been declared as such in a previous AddPrecise or MovePrecise instruction. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"AddPrecise({PrecisionVariable},{X})"


def custom(name: str, *args: str, logic: str | list[str]) -> str:
    """Create user-defined function

    Args:
        name (str): Name of the function
        logic (str | list[str]): The LoggerNet code logic body of the function.

    Returns:
        str: A string that can be inserted into a CR1X loggernet program to create the function.
    """
    s = f"Function {name}({','.join(args)})\n"
    if isinstance(logic, list):
        logic = "\n".join(logic)

    s += indent(logic, "    ")
    s += "\nEndFuncion"


def AM25T(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    AM25TChan: Constant,
    DiffChan: Constant,
    TCType: Literal[
        "mV", "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    TRef: Variable | Expression | Array,
    ClkPort: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    ResetPort: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    ExcitationChannel: Literal["0", "VX1", "VX2", "VX3", "VX4"],
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/am25t.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/am25t.htm).

              This instruction sets up the AM25T Multiplexer to be used with the datalogger, triggers the measurements, and stores the returned measurements. This instruction also returns a measurement from the multiplexer's built-in PRT (used as a reference temperature for the thermocouple measurements). If 0 is entered for the Reps parameter, this instruction makes only the PRT measurement and stores the result in the Dest parameter.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. Measurements are made on consecutive channels. If the Repetitions parameter is greater than 1, the Destination parameter must be a variable array. If 0 is entered, the only measurement that is made is the reference PRT temperature measurement. In the case of Reps = 0, the reference PRT measurement is stored in the Dest variable.

          Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          AM25TChan (Constant): Specifies the starting input channel for the multiplexer.   If the Repetitions parameter is greater than 1, the additional measurements will be made on sequential channels. If the channel is entered as a negative number, all repetitions occur on the same channel at a repetition rate of 1/fN1.

          DiffChan (Constant): The number for the differential terminal to which the AM25T is connected.

          TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric or numeric code can be entered. Entering a -1 records a voltage, in millivolts, instead of a thermocouple temperature. Right-click on the parameter to display a list.
    Must be one of following options: mV (Outputs voltage in mV), TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

          TRef (Variable | Expression | Array): The name of the variable that is the source of the reference temperature (or the result of the reference temperature measurement), in degrees C, for the thermocouple measurements. Right-click the parameter to display a list of defined variables.  If ExChan is set to a non-zero value, the measured value of the AM25T PRT is loaded into TRef and used as the reference. If ExChan is set to 0, the AM25T reference PRT will not be measured and whatever value was previously loaded into TRef is used as the reference temperature.

          ClkPort (Constant): The control port used for the multiplexer clock pulse. One clock port may be used to clock several devices. An alphanumeric code is entered for this argument. Right-click to display a drop-down list.
    Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

          Reset Port (Constant): The control port that will be used to enable and reset the multiplexer. Each multiplexer must have its own unique Reset line. An alphanumeric code is entered for this argument. Right-click to display a list.
    Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

          Excitation Channel (Constant): The excitation channel that will be used to provide switched excitation for the PRT reference temperature measurement. An alphanumeric code is entered. Right-click the parameter to display a list.
    Must be one of following options: 0 (Temperature measurement not made), VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list. False (or 0) = Do not make second measurement; True (or 1) = Reverse inputs and make second measurement.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Measurement Time The minimum time it will take to make the measurement will include the settling time, 450 microseconds to flush old data from the A to D converter, fN1, and whether or not the instruction removes voltage offset errors. If the total scan interval minus the scan measurement time is less than 50 microseconds, analog power is left on and the A to D converter requires only about 1 microsecond to "wake up". NOTE:   This instruction must NOT be placed inside a conditional statement when running in pipeline mode.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Measurement Time The minimum time it will take to make the measurement will include the settling time, 450 microseconds to flush old data from the A to D converter, fN1, and whether or not the instruction removes voltage offset errors. If the total scan interval minus the scan measurement time is less than 50 microseconds, analog power is left on and the A to D converter requires only about 1 microsecond to "wake up". NOTE:   This instruction must NOT be placed inside a conditional statement when running in pipeline mode.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"AM25T({Dest},{Reps},{Range},{AM25TChan},{DiffChan},{TCType},{TRef},{ClkPort},{ResetPort},{ExcitationChannel},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def Average(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "IEEE4",
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
        "FP2",
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/average.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/average.htm).

                The Average instruction is placed inside a DataTable declaration. The measurement or measurements for which to calculate an average are specified using the Reps and Source parameters.
    If the DisableVar is true for the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Also, if a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. is -7999, so NAN for FP2 data will appear in a data table as -7999.  If the data type is Long, NAN will appear in the data table as -2147483648.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. For the Average instruction, the Reps are the number of averages to calculate. If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error is returned when the program is compiled.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Average({Reps},{Source},{DataType},{DisableVar})"


def AvgRun(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Number: Constant,
    RunReset: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Count: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TotalCalls: Constant,
    Call_ID: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avgrun.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avgrun.htm).

                This instruction, when used, must appear between the Scan … NextScan instructions. A running average is the average of the last N values where N is specified in the Number argument.
    NAN values are not included in the running average. However, they can affect the running average by reducing the number of values contained in the average. The running average is calculated from the non-NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. values in the buffer of historical data. Note that all values, including NAN, are stored in the ring buffer. When a new value comes in, the running average is calculated by adding in the new value (if not NAN) and subtracting the oldest value (if not NAN) and then dividing by the number of values in the buffer that are not NAN. For example, if you have an N (number of values) of 5, but 2 of those are NANs, then N is reduced to 3, which results in a “poorer” average. In the event that all values in the buffer are NAN, a NAN is returned as the running average (this can be useful in detecting faults; for example, a broken sensor). If you want to ensure there are always N values used in the running average, the AvgRun instruction should be called conditionally (only when good values are received). This will eliminate any memory in the buffer being allocated to NAN values that are not used in the calculation. Calling the AvgRun instruction conditionally could also be used to remove values that are out-of-range.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. The Reps parameter is the number of variables in the array for which a running average should be calculated. When the Source is not an array, only a single variable in the array should be averaged, Reps should be 1.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the AvgRun instruction, the Source parameter is the name of the variable for which a running average should be calculated.

            Number (Constant): The number of values of Source to be used for calculating the running average, running total, running minimum, running maximum, or running standard deviation.

            RunReset (Variable | Constant | Expression | Array | Integer | ConstantInteger): When RunReset is true, the history over which the running value (for example, running average, running maximum, running minimum, running total, or running standard deviation)  is calculated is cleared, so that the value returned is calculated from a a single value, the current input. Note that the reset parameter does not automatically toggle back to false once set to true. When the reset parameter is set back to false (problematically or manually), then the running average, running maximum, running minimum, or running total continues, starting with the current input. Note that until the data logger has taken N measurements, the running average/total/maximum/minimum is calculated based on the actual number of measurements made since reset was set back to false.

            Count (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter added in OS 3.02 and greater that returns the actual number of values used to calculate the running value. The actual number of values used may be different than the number specified for the calculation due to NAN values in the buffer of historical data. The Count parameter can only be used if the optional Reset parameter is also used. The Count parameter is a variable of Type Long and must be the same dimension as the array that is being averaged (i.e., the same as reps). A count used for each rep will be written to this variable on each execution of the instruction.  The TotalCalls and Call_ID optional parameters below, allow a single instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun)  to be called with different source variables, as in a subroutine or function.  Click here for additional information. These parameters are available with operating system 7 and later.

            TotalCalls (Constant): Optional parameter that specifies the total number of calls to a specific instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun) in the program.

            Call_ID (Integer): Specifies a unique ID number for each specific call of the instruction. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"AvgRun({Dest},{Reps},{Source},{Number},{RunReset},{Count},{TotalCalls},{Call_ID})"


def AvgSpa(Dest: Variable | Array, Swath: Constant, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avgspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avgspa.htm).

                The AvgSpa is calculated as:
    If a NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is returned by the datalogger it is not included in the spatial average.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Swath (Constant): The number of values of the array over which to perform the specified operation. For the AvgSpa function, the Swath parameter is the number of elements to include in the average.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the AvgSpa function, the Source is the first variable in the array for which the spatial average should be calculated. In the case where the Source used is a multidimensional array, a one-dimensional representation of the value is used in the Source.  Example: If the array is declared Public Source(3,4),  to indicate Source(3,1)  use Source(7). Column 1Column 2Column 3Row 1123Row 2456Row 3789Row 4101112 See also Multi-dimensional Arrays. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"AvgSpa({Dest},{Swath},{Source})"


def ABS(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/abs.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/abs.htm).

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"ABS({number})"


def AcceptDataRecords(
    PakBusAddr: Integer,
    TableNo: Constant,
    DestTableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acceptdatarecords.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acceptdatarecords.htm).

                The AcceptDataRecords instruction is used in place of the CallTable instruction to store data sent by a remote datalogger. The remote datalogger sends the data using the SendData instruction.
    The table definitions for the local and remote dataloggers must be identical, unless 32768 (&H8000) is added to the TableNo parameter. The local data table cannot be an interval driven table, though the remote data table can be interval driven. Thus, in most cases you will need to add the 32768. When it is added, the number of fields and the data types must be the same, but the table name, number of records in the table, and field names do not. It is a more efficient use of memory to set a fixed number of records in the data table that will hold the incoming data, rather than let the datalogger autoallocate table size. Without a data interval, memory is allocated for a table as if the table is executed with each scan.
    The timestamp for the data stored in the local table (DestTableName) is the timestamp of the record in the remote datalogger.
    Since this instruction calls the table when records are received from the remote, you should not include a call to the same table (CallTable) elsewhere in the program.

    Args:
                    PakBusAddr (Integer): The PakBus address of the remote datalogger from which records should be accepted. If 0 is entered, the datalogger will accept records from any PakBus address. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089. 4095 is a broadcast address that can be used in a limited number of instructions. Typically, dataloggers are assigned addresses less than 4000.

            TableNo (Constant): Specifies the table in the remote datalogger from which a record will be retrieved (GetDataRecord) or accepted (AcceptDataRecords). This is a numeric value that represents the data tables in the order they are declared in the program (for example, the first data table declared in the program is 1, the second data table declared in the program is 2, etc.).  If 32768 (&H8000) is added to the TableNo parameter, the table definitions in both the local and remote dataloggers do not need to be identical. As an example, to accomplish this for table 1, you can enter 32769, or 1+32768, or 1+&H8000. Table 2 would be 32770, etc.

            DestTableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the data table in the local datalogger where the incoming record(s) should be stored. Right click the parameter for a list of tables that have been declared in the program.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"AcceptDataRecords({PakBusAddr},{TableNo},{DestTableName})"


def ACos(
    Number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acos.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/acos.htm).

                The Number argument can be any valid numeric expression that has a value between -1 and 1, inclusive.
    The ACOS function takes the ratio (number) of two sides of a right triangle and returns the corresponding angle. This ratio is the length of the side adjacent to the angle divided by the length of the hypotenuse. The result is expressed in radians and falls within the range of -π/2 to π/2 radians. Here, π is approximately 3.141593.
    To return the result of this function in degrees instead of radians, you can use the AngleDegrees function.
    To convert degrees to radians, multiply the degrees by π/180. To convert radians to degrees, multiply the radians by 180/π.

    Args:
                    Number (Variable | Constant | Expression | Array | Integer | ConstantInteger): Number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ACos({Number})"


def ASCII(ASCIIString: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ascii.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ascii.htm).

    Variables that are declared as strings can have only two dimensions. If a third dimension is used for a string, it represents the character within the string. Therefore, in the previous syntax example, X is a value that represents the position of the character in the string that you want returned. If your string is ABCDEFG and you want the ASCII value returned of D, you would use the number 4 for X to return that value.

    Args:
        ASCIIString (Variable): The string that should be processed with the function.  Variables that are declared as strings can have only two dimensions. If a third dimension is used for a string, it represents the character within the string. Therefore, to specify the character for which to return the value, use ASCIIString(1,1,X) where X is a value that represents the position of the character in the string that you want returned. If your string is ABCDEFG and you want the ASCII value returned of D, you would use the number 4 for X to return that value.

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"ASCII({ASCIIString})"


def ASin(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/asin.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/asin.htm).

                The Number argument can be any valid numeric expression that has a value between -1 and 1 inclusive.
    The ASIN function takes the ratio (number) of two sides of a right triangle and returns the corresponding angle. The ratio is the length of the side opposite to the angle divided by the length of the hypotenuse. The result is expressed in radians and is in the range -Pi/2 to Pi/2 radians. Pi is approximately 3.141593.
    AngleDegrees can be used to return the result of this function in degrees instead of radians.
    To convert degrees to radians, multiply degrees by Pi/180. To convert radians to degrees, multiply radians by 180/Pi.

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ASin({number})"


def Atn(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/atn.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/atn.htm).

                The Number argument can be any valid numeric expression.
    The ATN function takes the ratio (number) of two sides of a right triangle and returns the corresponding angle. The ratio is the length of the side opposite the angle divided by the length of the side adjacent to the angle. The result is expressed in radians and is in the range -Pi/2 to Pi/2 radians. Pi is approximately 3.141593.
    AngleDegrees can be used to return the result of this function in degrees instead of radians.
    To convert degrees to radians, multiply degrees by Pi/180. To convert radians to degrees, multiply radians by 180/Pi.

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Atn({number})"


def Atn2(
    Y: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    X: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/atn2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/atn2.htm).

                ATN2 function calculates the arctangent of Y/X, returning an angle (in radians) in the range of Pi to –Pi.  The signs of the parameters determine the quadrant of the returned value.
    ATN2 is defined for every point except the origin (X = 0 and Y = 0). AngleDegrees can be used to return the result of this function in degrees instead of radians.
    Pi is approximately 3.141593. To convert degrees to radians, multiply degrees by Pi/180. To convert radians to degrees, multiply radians by 180/Pi.

    Args:
                    Y (Variable | Constant | Expression | Array | Integer | ConstantInteger): Y (No description provided)

            X (Variable | Constant | Expression | Array | Integer | ConstantInteger): X (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Atn2({Y},{X})"


def ArgosData(
    ResultCode: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ST20Buffer: Constant | Integer,
    DataTable: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumRecords: Variable,
    DataFormat: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argosdata.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argosdata.htm).

                Using this instruction, the datalogger can be set up to send two-byte data values (FP2) or you can specify the bit width for each field.
    Each of the Argos buffers holds up to 31 or 32 bytes of data (a device with a 20 bit ID can hold 32 bytes; a device with a 28 bit ID can hold only 31 bits). Care should be given to write only the number of bytes to the data table that can be accommodated by the buffer; data that exceeds the buffer is discarded.
    The datalogger will attempt to send any new data from the data table when the instruction is executed. In most instances this instruction should be executed only after new data is stored to the data table. When the ArgosData instruction is executed, any existing data in the buffer is erased.

    Args:
                    ResultCode (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable that holds the result of the instruction. The instruction stores a -1 (True) if the transmission is successful or 0 (False) if it fails. If 2 is returned, the transmitter is not connected to the datalogger's communications port or there is some hardware problem with the connection.  Type: Variable declared as a Float, Boolean, or long

            ST20Buffer (Constant | Integer): The number of the ST20 buffer that should be set up. Valid entries are 0 through 6 (ArgosData, ArgosTransmit) or 0 through 7 (ArgosSetup). For the ArgosData instruction, valid entries are 0 through 6 (7 is reserved for the ST20's internal temperature).

            DataTable (Variable | Constant | Expression | Array | Integer | ConstantInteger): The datalogger DataTable that holds the data to be sent to the transmitter. Right-click the parameter to display a list of declared data tables in the program.

            NumRecords (Variable): The number of records from the data table to copy to the buffer of the transmitter.

            DataFormat (Variable | Constant | Expression | Array | Integer | ConstantInteger): The format for the values being transmitted. If "FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4." is entered, the data will be transmitted as a two-byte value. The data in the table must be formatted as FP2, or a compiler error will be returned. Alternately, you can specify the bit width for each field in a data table by entering a comma separated string of integers ("nnn,nnn,nnn…" where each nnn represents the width of a field in the table). In this instance, all values must be formatted as Long in the data table, or a compiler error will be returned.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ArgosData({ResultCode},{ST20Buffer},{DataTable},{NumRecords},{DataFormat})"


def ArgosDataRepeat(
    ResultCode: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RepeatRate: Constant | Integer,
    RepeatCount: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    BufferArray: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argosdatarepeat.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argosdatarepeat.htm).

                The ArgosData/ArgosDataRepeat instructions are most useful when transmitting to only one ID number. When transmitting to multiple ID numbers, ArgosTransmit should be used so that the datalogger program can control the timing of each transmission.
    ResultCode (Instruction Results)
    A variable that holds the result of the instruction. The instruction stores a -1 (True) if the transmission is successful or 0 (False) if it fails. If 2 is returned, the transmitter is not connected to the datalogger's communications port or there is some hardware problem with the connection.
    Type: Variable declared as a Float, Boolean, or long

    Args:
                    ResultCode (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable that holds the result of the instruction. The instruction stores a -1 (True) if the transmission is successful or 0 (False) if it fails. If 2 is returned, the transmitter is not connected to the datalogger's communications port or there is some hardware problem with the connection.  Type: Variable declared as a Float, Boolean, or long

            RepeatRate (Constant | Integer): The amount of time, in seconds, between each packet being sent. Valid rates are 0 through 255, or enter a negative number to use the default repetition rate for the PTT. Note that the transmitter adds 42 seconds to the rate entered for this parameter (so if 0 is entered, the rate will be 42).

            RepeatCount (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies how many times the message will be repeated. Valid entries are 0 to 255. Enter a negative value to use the default PTT settings.   Type: Constant Integer

            BufferArray (Variable | Constant | Expression | Array | Integer | ConstantInteger): An Boolean variable array used to set the buffers in the transmitter to true (use) or false (don't use). BufferArray is a variable array dimensioned to 8 and declared as a Boolean. Each element in the array corresponds to the Buffer Number minus 1 (e.g., 1 = buffer 0, 2 = buffer 1… 8 = buffer 7).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ArgosDataRepeat({ResultCode},{RepeatRate},{RepeatCount},{BufferArray})"


def ArgosError(ErrorMessage: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argoserror.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argoserror.htm).

    This instruction sends the &H09 command and then waits for the returned string plus the ACK or NAK character. The transmitter replaces the error message with an empty string after responding to the command.

    Args:
        ErrorMessage (Variable): A variable, declared as a string, that holds the returned error message from the transmitter. Returned error messages include: Bad ArgumentBad BufferBad Command  No Failsafe ModeTimeoutTransmit Failure

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"ArgosError({ErrorMessage})"


def ArgosSetup(
    ResultCode: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ST20Buffer: Constant | Integer,
    DecimalID: Constant | Integer,
    HexadecimalID: Constant | Integer,
    Frequency: Constant | Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argossetup.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argossetup.htm).

    Args:
            ResultCode (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable that holds the result of the instruction. The instruction stores a -1 (True) if the transmission is successful or 0 (False) if it fails. If 2 is returned, the transmitter is not connected to the datalogger's communications port or there is some hardware problem with the connection.  Type: Variable declared as a Float, Boolean, or long

    ST20Buffer (Constant | Integer): The number of the ST20 buffer that should be set up. Valid entries are 0 through 6 (ArgosData, ArgosTransmit) or 0 through 7 (ArgosSetup).

    DecimalID (Constant | Integer): The decimal ID number assigned to the buffer.

    HexadecimalID (Constant | Integer): The hexadecimal ID number assigned to the buffer.

    Frequency (Constant | Integer): The frequency (Hz) to be assigned to the ST20Buffer. Valid entries are 401630000 to 401656000 in steps of 2000 Hz and 401676000, 401678000, and 401680000.  NOTE: The assigned DecimalID and HexadecimalID are different values (e.g., the DecimalID is not merely a decimal representation of the HexadecimalID).

    Returns:
            str: A string of the CRBasic function call.

    """
    return (
        f"ArgosSetup({ResultCode},{ST20Buffer},{DecimalID},{HexadecimalID},{Frequency})"
    )


def ArgosTransmit(
    ResultCode: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ST20Buffer: Constant | Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argostransmit.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/argostransmit.htm).

        This instruction is used most often when transmitting to multiple ID numbers, where more data throughput is required. The user must write the program to account for the retransmission of failed data packets. If transmitting to only one ID number, you may want to use ArgosData and ArgosDataRepeat, which take care of failures based on the parameters in ArgosDataRepeat.

    Args:
            ResultCode (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable that holds the result of the instruction. The instruction stores a -1 (True) if the transmission is successful or 0 (False) if it fails. If 2 is returned, the transmitter is not connected to the datalogger's communications port or there is some hardware problem with the connection.  Type: Variable declared as a Float, Boolean, or long

    ST20Buffer (Constant | Integer): The number of the ST20 buffer that should be set up. Valid entries are 0 through 6 (ArgosData, ArgosTransmit) or 0 through 7 (ArgosSetup). For the ArgosTransmit instruction, valid entries are 0 through 6 (7 is reserved for the ST20's internal temperature).

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"ArgosTransmit({ResultCode},{ST20Buffer})"


def ArrayLength(ArrayLenVar: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/arraylength.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/arraylength.htm).

                The ArrayLenVar parameter is the variable for which to return the number of elements in the array.
    In CRBasic, ArrayLength always refers to the number of elements in an array, regardless of the variable type (Float, Long, String, etc.). Thus, ArrayLength returns the number of strings in an array, not the number of characters per string.
    ArrayLength can be used to return the number of tables in the datalogger; for example,
    NumberofTables(1)=ArrayLength(DataTableInfo.DataTableName)
    NumberofTables(2)=ArrayLength(Status.DataTableName)

    Args:
                    ArrayLenVar (Variable): The variable for which to return the length.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ArrayLength({ArrayLenVar})"


def AVW200(
    Result: Literal["0", "≥1", "-3", "-5", "-20"],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Destination: Variable,
    AVWChan: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    MuxChannel: Constant,
    Reps: Variable | Constant,
    BeginFreq: Constant,
    EndFreq: Constant,
    ExVolt: Constant,
    Therm50_60Hz: Literal["0", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    AmpThreshold: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avw200.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/avw200.htm).

                This instruction is used to read measurements from one or more vibrating wire sensors when the sensors are connected to the AVW200 channels directly or connected to a multiplexer connected to the AVW200. In addition to frequency, diagnostic information is returned for the sensor (see the Dest parameter).
    The first execution of the instruction sets up the AVW200; subsequent instructions retrieve the data values. If different beginning and ending frequencies are required to measure different types of sensors, use multiple AVW200 instructions. The maximum scan rate for an AVW200 program is 2 seconds per sensor. If the program is compiled in pipeline mode, the AVW200 will make the measurement before the scan interval occurs, with the timing being such that the measurement is ready when the scan occurs. If the program is compiled in sequential mode, the measurement is made on the scan interval and the datalogger waits for the response.
    Use SDI12Recorder to trigger and retrieve measurements from the AVW200 using SDI12.
    Use GetVariables to retrieve values from the AVW200's status table. This can be used to return the RF signal level (RfSignalLevel in the status table), battery voltage (BattVoltage), or other values of interest. A full list of status table values is provided in an appendix of the AVW200 manual.
    The AVW200 instruction is a processing instruction. The program should be run in SequentialMode if the instruction is called outside of the main scan (for example, in a subroutine or if called within a conditional statement).

    Args:
                    Result (Variable): Stores the success or failure of the datalogger's communication attempt with the AVW200. The result codes are as follows:
      Must be one of following options: 0 (Communication successful. Values have been written to the destination array.), ≥1 (Number of communication failures. Old values will remain in the destination array. Resets to 0 upon successful communication), -3 (First communication. Values will be available on the next scan.), -5 (Request for another measurement received when the AVW200 is busy making a measurement.), -20 (Out of Comms memory)

            ComPort (Variable): Specifies the communications port that will be used to communicate with the AVW200. Enter an alphanumeric code:
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions. For the AVW200 instruction, the PakBusAddr parameter identifies the PakBus address of the AVW200 with which the host datalogger is trying to communicate. Valid entries are 1 through 4094, or a variable can be used. Each PakBus device in the network must have a unique address. NOTE: By default, LoggerNet uses PakBus address 4094 and PC400 uses 4093.

            Destination (Variable): The variable array in which to store the results of the instruction. Dest is a single-dimensioned array of 5 or 6 (depending upon whether a thermistor is being measured) if only one sensor is being measured. Dest is a multi-dimensioned array of 5 or 6 if multiple sensors are being measured using a multiplexer. The first dimension is set equal to the number of sensors being measured and the second dimension is set equal to the number of values returned for each sensor (5 or 6). For example, to measure 4 sensors with thermistor measurements attached to a multiplexer, Dest would be declared as Array(4,6). Values for sensor 1 would be stored in Array(1,1) through Array(1,6), values for sensor 2 stored in Array (2,1) through (2,6), etc. For the AVW200 instruction, the values returned for each sensor are: (1)  Frequency in Hertz (2) Amplitude in mV RMS (3) Signal-to-noise ratio (4) Noise frequency (5) Decay ratio (6) Thermistor in ohms (if measured) If communication is unsuccessful, NANs Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. are stored. If the amplitude is < 0.01 mV, -9,999,999 is stored for frequency (Array element 1) when the device is communicating via SDI-12, or NAN is stored for all other scenarios. If there is an inductor failure or other power supply problem, -555,555 is stored for array element 1 (frequency)

            AVWChan (Variable | Constant | Expression | Array | Integer | ConstantInteger): The channel on the AVW200 where the sensor or multiplexer is wired. Valid options are 1 (1V+/-) or 2 (2V+/-).

            MuxChannel (Constant): The channel on the multiplexer where measurements should start. Valid options are 1 through 32; anything outside of this range returns an error.  Enter 1 if a multiplexer is not used.

            Reps (Variable | Constant): The number of measurements to be made on the multiplexer. This parameter does not affect the AVW200Chan.

            BeginFreq (Constant): The starting frequency to use for the vibrating wire measurement (Hz). The minimum value that can be entered is 100. Refer to the specifications of the vibrating wire sensor for recommended BeginFreq and EndFreq values (typical sweep range is 450 to 6000).

            EndFreq (Constant): The ending frequency to use for the vibrating wire measurement (Hz). The maximum value that can be entered is 6500. Refer to the specifications of the vibrating wire sensor for recommended BeginFreq and EndFreq values (typical sweep range is 450 to 6000).

            ExVolt (Constant): The excitation voltage to be used to excite the vibrating wire. Valid options are 1 (5 V peak-to-peak) or 2 (12 V peak-to-peak).

            Therm50_60Hz (Constant): Sets the integration time for the thermistor in the vibrating wire sensor.
      Must be one of following options: 0 (No thermistor measurement), 60 (Use 60 Hz noise rejection), 50 (Use 50 Hz noise rejection)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            AmpThreshold (Constant): An optional parameter that is used to define a minimum value, in millivolts, for the amplitude of the signal. If an amplitude of less than the threshold is returned, NAN will be stored for the Frequency measurement (Dest(1)). If AmpThreshold is omitted, a default value of 0.01 mV is used. If a value of less than 0.01 mV is entered for this parameter, the precompiler will return an error. For best results, use an amplitude threshold that is an integer multiple of 0.0625 (for additional information, refer to the AVW200 manual). The AVW200 instruction will be run in SequentialMode under the following circumstances: The AVW200() is in a SlowSequence or is forced to sequential mode with the SequentialMode instruction.One or more of the following AVW200() parameters are assigned as variables: PakBusAddr, AVWChan, MuxChan, AVWReps, AVWBeginFreq, AVWEndFreq or AVWExVolt. Even if the datalogger program is compiled and running in the PipeLine mode, the AVW200 instruction will run in a sequential mode of operations.The AVW200() instruction occurs in a conditional statement or subroutine.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"AVW200({Result},{ComPort},{NeighborAddr},{PakBusAddr},{Destination},{AVWChan},{MuxChannel},{Reps},{BeginFreq},{EndFreq},{ExVolt},{Therm50_60Hz},{Mult},{Offset},{AmpThreshold})"


def ArrayIndex(
    Name: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/arrayindex.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/arrayindex.htm).

                The ArrayIndex function is used to return the index of a named element in an array, which would otherwise be unknown. The value can then be further processed in the program because of its known position in the array. If the named element is not found, the function returns 0 (this will result in a Variable Out of Bounds error).
    One use of this instruction is in a wireless sensor network where auto-discovery is being used. In this instance, the sensor measurements are returned in the destination array in the order in which the sensors are discovered by the base. It is not known until the sensors are discovered where in the array each sensor's measurement values will be stored. The names of the values returned by the sensors are known, however. Thus, the ArrayIndex function can be used to return the correct index value so that further processing can be done (for example, output processing or unit conversion). This instruction can be used similarly with the NewFieldNames instruction.

    Args:
                    Name (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that contains the name of the value for which an index is desired. All sensors have a default sensor name, and a fieldname for each returned value. For instance, a CWS900 with a 109 probe attached returns four values Ts (temperature), Ti (internal temperature), BV (battery voltage), and SS (signal strength). Thus, the default name for the sensor's temperature measurement might be CWS900_1_Ts. This would be entered as a string in the ArrayIndex function. Unique sensor names and fieldnames can be assigned using Device Configuration Utility, Network Planner, or Wireless Sensor Planner.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ArrayIndex({Name})"


def Battery(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/battery.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/battery.htm).

                This instruction reads the voltage of the battery powering the system and stores the result in the Dest variable. The units for battery voltage are volts.
    NOTE: The datalogger performs the same battery measurement whether it is a measurement performed in the background or as a result of the Battery instruction in the program (some other Campbell Scientific dataloggers perform a different measurement, based on whether it is a background measurement or the Battery instruction).

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): Dest (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Battery({Dest})"


def BrFull(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Literal["1", "2", "3", "4", "5", "6", "7", "8"],
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    MeasPEx: Constant,
    ExmV: Variable | Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brfull.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brfull.htm).

              This instruction applies an excitation voltage to a full bridge and makes a differential voltage measurement of the bridge output. The resulting value is the measured voltage in millivolts divided by the  excitation voltage in volts.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the BrFull instruction, the Dest parameter is a variable in which to store the results (X in the equation) of the measurement.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the BrFull instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          DiffChan (Constant): Specifies the differential channel on which to make the first measurement. If the Reps parameter is greater than 1, additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible.
    Must be one of following options: 1 (Differential Channel 1 (SE 1 and 2)), 2 (Differential Channel 2 (SE 3 and 4)), 3 (Differential Channel 3 (SE 5 and 6)), 4 (Differential Channel 4 (SE 7 and 8)), 5 (Differential Channel 5 (SE 9 and 10)), 6 (Differential Channel 6 (SE 11 and 12)), 7 (Differential Channel 7 (SE 13 and 14)), 8 (Differential Channel 8 (SE 15 and 16))

          ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

          MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

          ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.

          RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"BrFull({Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def BrFull6W(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Literal["1", "2", "3", "4", "5", "6", "7", "8"],
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    MeasPEx: Constant,
    ExmV: Variable | Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    ReturnV1: Literal["0", "≠0"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brfull6w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brfull6w.htm).

              This instruction applies an excitation voltage and makes two differential voltage measurements. The measurements are made on sequential channels. The result is 1000 * the voltage measured on the second channel (V2) divided by the voltage measured on the first (V1) (or millivolts output per volt of excitation). The connections are made so that V1 is the measurement of the voltage drop across the full bridge, and V2 is the measurement of the bridge output. The excitation voltage used by this instruction is turned off when another measurement instruction is run or the program reaches the end of the scan.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the BrFull6W instruction, the Dest parameter is a variable in which to store the results (X in the equation) of the measurement.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the BrFull6W instruction, the Reps parameter is the number of times the measurement should be made. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option). Range1 is for the first channel measured; Range2 is for the second channel measured. An alphanumeric code is entered.
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          DiffChan (Constant): Specifies the differential channel on which to make the first measurement. If the Reps parameter is greater than 1, additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible.
    Must be one of following options: 1 (Differential Channel 1 (SE 1 and 2)), 2 (Differential Channel 2 (SE 3 and 4)), 3 (Differential Channel 3 (SE 5 and 6)), 4 (Differential Channel 4 (SE 7 and 8)), 5 (Differential Channel 5 (SE 9 and 10)), 6 (Differential Channel 6 (SE 11 and 12)), 7 (Differential Channel 7 (SE 13 and 14)), 8 (Differential Channel 8 (SE 15 and 16))

          ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

          MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

          ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.

          RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          ReturnV1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether or not to return the V1 voltage as shown in the following image. If ReturnV1 is non-zero, V1 will be returned. In this case, the Destination parameter must be  a two-element (or greater) array. The first element will hold 1000*V2/V1 (the normal output for this instruction). The second element will hold V1.
    Must be one of following options: 0 (Do not return V1), ≠0 (Return V1)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"BrFull6W({Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset},{ReturnV1})"


def BrHalf(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    MeasPEx: Constant,
    ExmV: Variable | Constant,
    RevEx: Constant,
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf.htm).

              This instruction applies an excitation voltage, delays a specified amount of time, and then makes a single ended voltage measurement. With a multiplier of 1 and an offset of 0 the result is the ratio of the measured voltage divided by the excitation voltage.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the BrHalf instruction, the Dest parameter is a variable in which to store the results (X in the equation) of the measurement.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the BrHalf instruction, the Reps parameter is the number of times the measurement should be made. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. For the BRHalf instruction, if the SEChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The burst measurement sampling rate is determined by the fN1 (first notch frequency) parameter, which can go up to a maximum of 93750Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC Analog to digital conversion. The process that translates analog voltage levels to digital values. flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

          ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

          MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

          ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.  For the BrHalf instruction, the ExmV argument is the excitation, in millivolts, to apply to the sensor.

          RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"BrHalf({Dest},{Reps},{Range},{SEChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{SettlingTime},{fN1},{Mult},{Offset})"


def BrHalf3W(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    MeasPEx: Constant,
    ExmV: Variable | Constant,
    RevEx: Constant,
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf3w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf3w.htm).

                This instruction is used to determine the ratio of the sensor resistance to a known resistance using a separate voltage sensing wire from the sensor to compensate for lead wire resistance.
    The measurement sequence is to apply an excitation voltage and make two voltage measurements on two adjacent single-ended channels: the first on the reference resistor and the second on the voltage sensing wire from the sensor. The two measurements are used to calculate the resulting value that is the ratio of the voltage across the sensor to the voltage across the reference resistor. The excitation voltage used by this instruction is turned off when another measurement instruction is run or the program reaches the end 		of the scan.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the BrHalf3W instruction, the Dest parameter is a variable in which to store the results (X in the 		equation) of the measurement.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the BrHalf3W instruction, the Reps parameter is the number of times the measurement should be made. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. Specify the channel to be used for the first measurement. The second measurement will be made on the next consecutive channel. For the BRHalf3W instruction, if the SEChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The burst measurement sampling rate is determined by the fN1 (first notch frequency) parameter, which can go up to a maximum of 93750Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC Analog to digital conversion. The process that translates analog voltage levels to digital values. flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
      Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
      Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"BrHalf3W({Dest},{Reps},{Range},{SEChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{SettlingTime},{fN1},{Mult},{Offset})"


def BrHalf4W(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Literal["1", "2", "3", "4", "5", "6", "7", "8"],
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    MeasPEx: Constant,
    ExmV: Variable | Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    ReturnV1: Literal["0", "≠0"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf4w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/brhalf4w.htm).

              This instruction applies an excitation voltage and makes two differential voltage measurements, then reverses the polarity of the excitation and repeats the measurements. The measurements are made on sequential channels. The result is the voltage measured on the second channel (V2) divided 			by the voltage measured on the first (V1). The connections are made so that V1 is the voltage drop across the fixed resistor (Rf), and V2 is the drop across the sensor 		(Rs). The result is V2 / V1 which equals Rs / Rf. The excitation voltage used by this instruction is turned off when another measurement instruction is run or the program reaches the end of the scan.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the BrHalf4W instruction, the Dest parameter is a variable in which to store the results (X in the 		equation) of the measurement.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the BrHalf4W instruction, the Reps parameter is the number of times the measurement should be made. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option). Range1 is for the first channel measured; Range2 is for the second channel measured. An alphanumeric code is entered
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          DiffChan (Constant): Specifies the differential channel on which to make the first measurement. If the Reps parameter is greater than 1, additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible.
    Must be one of following options: 1 (Differential Channel 1 (SE 1 and 2)), 2 (Differential Channel 2 (SE 3 and 4)), 3 (Differential Channel 3 (SE 5 and 6)), 4 (Differential Channel 4 (SE 7 and 8)), 5 (Differential Channel 5 (SE 9 and 10)), 6 (Differential Channel 6 (SE 11 and 12)), 7 (Differential Channel 7 (SE 13 and 14)), 8 (Differential Channel 8 (SE 15 and 16))

          ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

          MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

          ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.

          RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. For the BRHalf4W instruction, a multiplier (mult) of 1 and an offset of 0, results in V2/V1 which is equal to Rs/Rf.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. For the BRHalf4W instruction, a multiplier (mult) of 1 and an offset of 0, results in V2/V1 which is equal to Rs/Rf.

          ReturnV1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether or not to return the V1 voltage as shown in the following image. If ReturnV1 is non-zero, V1 will be returned. In this case, the Destination parameter must be  a two-element (or greater) array. The first element will hold V2/V1 (the normal output for this instruction). The second element will hold V1.
    Must be one of following options: 0 (Do not return V1), ≠0 (Return V1)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"BrHalf4W({Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset},{ReturnV1})"


def Broadcast(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    Message: Literal["0", "12", "13", "14"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/broadcast.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/broadcast.htm).

                An error is returned if something other than a valid message is sent. Valid messages following.

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. If 0 is used for the ComPort in a datalogger not set up as a router and a neighbor address is specified, the datalogger will use that PakBus device as a router.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            Message (Variable): The code for the message that should be broadcast to the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. network. Right click the parameter for a list of valid options.
      Must be one of following options: 0 (Beacon A signal broadcasted to other devices in a PakBus network to identify "neighbor" devices. A beacon in a PakBus network ensures that all devices in the network are aware of other devices that are viable. If configured to do so, a clock-set command may be transmitted with the beacon. This function can be used to synchronize the clocks of devices within the PakBus network.. When a Beacon is transmitted, all PakBus devices within range will respond and become a neighbor to the beaconing datalogger. The only exception is if a device in range has a neighbor filter that prevents it from responding.), 12 (Reset routing tables. Resets the routing
    tables of the dataloggers in the PakBus network.), 13 (GoodBye. Removes the datalogger from the
    neighbor list of other devices in the network.), 14 (Hello request. A Hello request sets up
    other devices as neighbors to the datalogger sending the message. Routing information, hop metrics, communication verification intervals, and router indication are exchanged in a Hello request.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Broadcast({ComPort},{Message})"


def CalFile(
    SourceDest: Variable | Array,
    NumVals: Constant,
    DeviceFilename: Literal["CPU:", "CRD:", "USR:", "USB:"],
    Option: Literal["0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/calfile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/calfile.htm).

                The CalFile instruction can also be used to write one or more stored calibration files to the datalogger's non-volatile flash memory. When the datalogger is powered up, all such files located in flash memory are loaded into SDRAM memory, which can then be accessed by the program through the use of the CalFile instruction.
    The data in the file is stored as 4 byte binary single precision floating point values (in the native format of the datalogger) with a 2 byte signature appended to the end of the data. This signature is checked (if reading) to verify that the file is not corrupt. When writing to a file, the signature is calculated and stored with the data.

    Args:
                    Source/Dest (Variable | Array): A variable array specifying where to read data from or write data to.

            NumVals (Constant): The number of values that should be read from or written to the calibration file.

            "Device:Filename" (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the device to be written to/read from and the name of the calibration file. The Device:Filename string must be enclosed in quotation marks. Valid devices are:  The USR device is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512-byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up). Use a Device other than CPU if writing the calfile frequently. The datalogger’s CPU has limited write cycles and writing to it frequently may exceed this limit.
      Must be one of following options: CPU: (Internal CPU), CRD: (External Memory Card), USR: (User-Defined Drive), USB: (SC115)

            Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): A numeric code used to determine whether to create a calibration file or to read from a calibration file. Right-click the parameter to display a list of valid options:
      Must be one of following options: 0 (Write source array to a file), 1 (Read data from a file and if the signature matches, write to an array)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CalFile({SourceDest},{NumVals},{DeviceFilename},{Option})"


def Calibrate(Dest: Array, Range: Literal["0", "≠"]) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/calibrate.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/calibrate.htm).

                During calibration, the datalogger measures offset and gain on voltage ranges and calculates calibration coefficients. Calibration occurs when a datalogger program is compiled (typically, when the datalogger is powered up or when a watchdog error occurs). Calibration also occurs automatically every 36 to 364 seconds during program execution. The frequency of calibration is based on the lowest notch frequency (fN1) used in the program; maximum is 1000 milliseconds. When the Calibrate instruction is used in a program, this automatic calibration is disabled and calibration occurs when the instruction is executed. When CDMs are used with the datalogger, this instruction will cause the datalogger and all modules to perform their respective calibration measurements.
    Temperature is the major factor affecting the calibration of the analog voltage measurement section. If calibration is not performed as part of the program, a typical shift in the calibration is 0.01% per degree C change from the temperature at which the program compile calibration occurred. When there is adequate time for all measurements, calibration is performed in the background to provide continuous adjustment as temperature changes. If there is not enough time to perform automatic calibration, you may want to enable it under program control if accuracy is important. If the program does not allow enough time for automatic calibration to be performed, the message "Warning when Fast Scan x is running background calibration will be disabled" will be returned when the program is compiled.
    The instruction can be placed in a fast scan with measurements, or, if there is insufficient time to run it in the fast scan it can be placed in a SlowSequence. When the instruction is placed in a SlowSequence, calibration is performed as extra time slices allow. Note, however, that unless the SlowSequence is faster than about 40 seconds, the calibration will not be performed any faster than if using automatic calibration.
    Parameters for this instruction are optional, and are used only when the user desires to store the results of the calibration. The Dest parameter should reference an array dimensioned to at least 60 values to store the results. If your program also includes BrFull, BrHalf3W, or BrHalf you will need to increase the array size by one value for each excitation channel used in these instructions. The Range parameter is a constant entered as either 0 or non-zero. It allows the user to choose whether to perform a calibration on all ranges or only those ranges used in the program (Range=0, calibrate only ranges used in program; Range=non-zero, calibrate all ranges).
    Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Args:
                    Dest (Array): The array in which to store the calibration coefficients. The array must be dimensioned to 60 in order to hold all of the calculated calibration coefficients.

            Range (Variable | Constant): The entry for this optional parameter is either 0 or a non-zero number.
      Must be one of following options: 0 (Calibrate only those ranges used in the program.), ≠ (Calibrate all ranges.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Calibrate({Dest},{Range})"


def CHR(Code: Integer) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/chr.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/chr.htm).

                The CHR function returns a string consisting of the character indicated followed by a null character. CHR(0) will produce a string of two nulls. The character returned by the CHR function can be stored in a string in the program or sent to some other device by using serial commands (for example, SerialOut).
    NOTE: Characters up to 127 represent the standard ASCII character set and will mostly likely work correctly in any application. Characters beyond 127 are dependent on the application using the created string.

    Args:
                    Code (Integer): The code for the character to be output. The Code parameter is the integer value (0 through 255) that is the extended ASCII representation of the character to output. See ASCII Codes and Characters for a full list of codes and their associated characters. String variables can be declared as only one or two dimensions; for example, String(x) or String(x,y). To begin reading or modifying a string at a particular location into the string, enter the location as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CHR({Code})"


def CDM_ACPower(
    CDMType: Constant,
    CPIAddress: Constant,
    DestAC: Variable,
    ConfigAC: Literal["1", "2", "3"],
    LineFrq: Constant,
    ChanV: Constant,
    MultV: Constant,
    MaxVrms: Constant,
    ChanI: Constant,
    MultI: Constant,
    MaxIrms: Constant,
    RepsI: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmacpower.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmacpower.htm).

                The CDM_ACPower instruction is suitable for net-metering applications, as well as variable-frequency (wild AC) applications. Potential and current transformers must be used to measure the voltage and current using the datalogger.
    WARNING: Working with live electrical equipment is dangerous! The user is responsible for ensuring all wiring conforms to local safety regulations and that the enclosure is labeled accordingly.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            DestAC (Variable): Variable or variable array in which to store the measurement results. The number of values returned depends upon the option chosen for the configuration parameter. If DestAC is not dimensioned large enough to hold all values, only those values that will fit into the array will be stored.

            ConfigAC (Constant): Determines the type of measurement that will be made. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (Single-phase with one voltage measurement and the number of current measurements specified by the RepsI parameter. This configuration monitors a single load with one voltage and one current measurement, or multiple loads in sub-panel applications with one voltage and multiple current measurements.), 2 (Split-phase with one voltage measurement and two current measurements. This configuration is typical of residential service-entry panels, as well as residential and commercial distribution panels. Split-phase configurations have two line (or “hot”) conductors plus a neutral conductor.), 3 (Three-phase ‘Y’, four-conductor, configurations with three voltage measurements and three current measurements. This configuration is typical of commercial entry panels and commercial distribution panels. The four conductors are three line (or “hot”) conductors plus a neutral conductor.)

            LineFrq (Constant): The expected line frequency in hertz. Valid entries are 60, 50, or a value between 2 and 20. A value between 2 and 20 indicates measurements from variable-frequency power, where LineFrq is the minimum frequency to be measured. Note that smaller values for LineFrq increase the measurement and processing time for this instruction. The maximum frequency for the variable-frequency mode is 480 Hz and independent of the 2- to 20-Hz minimum frequency.

            ChanV (Constant): The single-ended channel for the voltage measurement. For single- and split-phase configurations (ConfigAC = 1 or 2), the datalogger makes a voltage measurement at ChanV. For three-phase configurations (ConfigAC = 3), the datalogger makes three voltage measurements on increasing consecutive channels starting at ChanV.

            MultV (Constant): The potential transformer multiplier represented as input Volts per output mVolts. A typical value is 115 V/333 mV (or 0.345345).

            MaxVrms (Constant): The expected maximum RMS Root-mean square, or quadratic mean. A measure of the magnitude of wave or other varying quantities around zero. voltage to measure. MaxVrms is specified at the primary of the potential transformer, or equivalently, the non-logger side of the potential transformer. Typical values are 120 or 240. The datalogger uses MultV and MaxVrms to calculate which input range to use for the voltage measurement.

            ChanI (Constant): The single-ended channel for the current measurement. For single-phase configurations (ConfigAC = 1) with RepsI greater than 1, the datalogger makes multiple current measurements on increasing consecutive channels starting at ChanI. For split-phase configurations (ConfigAC = 2), the datalogger makes two current measurements on increasing consecutive channels starting at ChanI. For three-phase configurations (ConfigAC = 3), the datalogger makes three current measurements on increasing consecutive channels starting at ChanV.

            MultI (Constant): The current transformer multiplier as input Amps per output mVolts. A typical value is 15 Amps/333 mV (or 0.045045).

            MaxIrms (Constant): The expected maximum RMS Root-mean square, or quadratic mean. A measure of the magnitude of wave or other varying quantities around zero. current to measure. MaxIrms is specified at the primary of the current transformer, or equivalently, the non-logger side of the current transformer. The datalogger uses MultI and MaxIrms to calculate which input range to use for the current measurement(s).

            RepsI (Constant): The number of current measurements to make on consecutive single-ended input channels. This parameter is used only in configuration 1 and is ignored by the datalogger for configurations 2 and 3.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_ACPower({CDMType},{CPIAddress},{DestAC},{ConfigAC},{LineFrq},{ChanV},{MultV},{MaxVrms},{ChanI},{MultI},{MaxIrms},{RepsI})"


def CDM_Battery(CDMType: Constant, CPIAddress: Constant, Dest: Variable | Array) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbattery.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbattery.htm).

    Args:
            CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

    CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  WARNING: If this instruction is placed inside a conditional statement, the datalogger will attempt to compile the program in Sequential mode. If the program is forced into PipeLine mode using the PipelineMode instruction, compilation will fail.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CDM_Battery({CDMType},{CPIAddress},{Dest})"


def CDM_BrFull(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Constant,
    ExChan: Constant,
    MeasPEx: Constant,
    ExmV: Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrfull.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrfull.htm).

                This instruction applies an excitation voltage to a full bridge and makes a differential voltage measurement of the bridge output. The resulting value is the measured voltage in millivolts divided by the excitation voltage in volts.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_BrFull instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
      Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_BrFull({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_BrFull6W(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Constant,
    ExChan: Constant,
    MeasPEx: Constant,
    ExmV: Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    ReturnV1: Literal["0", "≠0"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrfull6w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrfull6w.htm).

                This instruction applies an excitation voltage and makes two differential voltage measurements. The measurements are made on sequential channels. The result is 1000 * the voltage measured on the second channel (V2) divided by the voltage measured on the first (V1) (or millivolts output per volt of excitation). The connections are made so that V1 is the measurement of the voltage drop across the full bridge, and V2 is the measurement of the bridge output.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDMBrFull6W instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option). Range1 is for the first channel measured; Range2 is for the second channel measured. An alphanumeric code is entered.
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
      Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            ReturnV1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether or not to return the V1 voltage as shown in the following image. If ReturnV1 is non-zero, V1 will be returned. In this case, the Destination parameter must be  a two-element (or greater) array. The first element will hold 1000*V2/V1 (the normal output for this instruction). The second element will hold V1.  Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..
      Must be one of following options: 0 (Do not return V1), ≠0 (Return V1)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_BrFull6W({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset},{ReturnV1})"


def CDM_BrHalf(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    ExChan: Constant,
    MeasPEx: Constant,
    ExmV: Constant,
    RevEx: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf.htm).

                This instruction applies an excitation voltage, delays a specified amount of time, and then makes a single ended voltage measurement. With a multiplier of 1 and an offset of 0 the result is the ratio of the measured voltage divided by the excitation voltage.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_BrHalf instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_BrHalf({CDMType},{CPIAddress},{Dest},{Reps},{Range},{SEChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_BrHalf3W(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    ExChan: Constant,
    MeasPEx: Constant,
    ExmV: Constant,
    RevEx: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf3w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf3w.htm).

                This instruction is used to determine the ratio of the sensor resistance to a known resistance using a separate voltage sensing wire from the sensor to compensate for lead wire resistance.
    The measurement sequence is to apply an excitation voltage and make two voltage measurements on two adjacent single-ended channels: the first on the reference resistor and the second on the voltage sensing wire from the sensor. The two measurements are used to calculate the resulting value that is the ratio of the voltage across the sensor to the voltage across the reference resistor.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_BrHalf3W instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_BrHalf3W({CDMType},{CPIAddress},{Dest},{Reps},{Range},{SEChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_BrHalf4W(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Constant,
    ExChan: Constant,
    MeasPEx: Constant,
    ExmV: Constant,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    ReturnV1: Literal["0", "≠0"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf4w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmbrhalf4w.htm).

                This instruction applies an excitation voltage and makes two differential voltage measurements, then reverses the polarity of the excitation and repeats the measurements. The measurements are made on sequential channels. The result is the voltage measured on the second channel (V2) divided by the voltage measured on the first (V1). The connections are made so that V1 is the voltage drop across the fixed resistor (Rf), and V2 is the drop across the sensor (Rs). The result is V2 / V1 which equals Rs / Rf.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_BrHalf4W instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option). Range1 is for the first channel measured; Range2 is for the second channel measured. A
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
      Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            ReturnV1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether or not to return the V1 voltage as shown in the following image. If ReturnV1 is non-zero, V1 will be returned. In this case, the Destination parameter must be  a two-element (or greater) array. The first element will hold V2/V1 (the normal output for this instruction). The second element will hold V1.  Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..
      Must be one of following options: 0 (Do not return V1), ≠0 (Return V1)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_BrHalf4W({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{ExChan},{MeasPEx},{ExmV},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset},{ReturnV1})"


def CDM_Delay(
    CDMType: Constant,
    CPIAddress: Constant,
    Option: Literal["0", "1"],
    Delay: Constant,
    Units: Literal["0", "1", "2", "3", "4", "5"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmdelay.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmdelay.htm).

                The CDM_Delay instruction is used to delay the measurement task sequence or the processing instructions for the time period specified by the Delay and Units arguments, before progressing to the next measurement or processing instruction.
    The Scan Interval should be sufficiently long to process all measurements plus the delay period. If the delay is applied to the measurement task sequence and the scan interval is not long enough to process all measurements plus the delay, the program will not compile when sent to the datalogger. If the delay is applied to the processing task sequence, the program will compile but scans will be skipped.
    Note that the CDM_Delay instruction with option set to 0 only delays the addressed device. In other words, each device that needs a delay must have its own CDM_Delay instruction.
    The CDM_Delay instruction with option set to 1 essentially makes the CDM_Delay instruction equivalent to the datalogger’s Delay instruction since the processing delay happens at the datalogger.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Option (Constant): Determines whether the delay should apply to the measurement task sequence or the processing instructions. Right-click the parameter to display a drop-down list box.
      Must be one of following options: 0 (Delay will affect the measurement task sequence. Processing will continue to take place as needed in the background. When this option is chosen, the Delay instruction must not be placed in a conditional statement.), 1 (Delay will affect processing. Measurements will continue as called for by the task sequencer.)

            Delay (Constant): The time to delay the program at the designated place (10 microsecond resolution). The time units are selected by the Units argument.

            Units (Constant): For the Delay instruction, the Units parameter is the time units for the delay. A numeric  code is entered. Right-click the parameter to display a list.
      Must be one of following options: 0 (usec), 1 (msec), 2 (sec), 3 (min), 4 (hr), 5 (day)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_Delay({CDMType},{CPIAddress},{Option},{Delay},{Units})"


def CDM_ExciteI(
    CDMType: Constant,
    CPIAddress: Constant,
    IxChan: Constant,
    IxUA: Constant,
    Delay: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmexcitei.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmexcitei.htm).

        This instruction is used to set to the current level (μAmperes) for a specified current excitation channel.

    Args:
            CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

    CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

    IxChan (Constant): The excitation channel (X1, X2, etc.) to use for the first measurement. The number of available channels depends upon the CDM being programmed. Right-click the parameter for a list of valid options.  This is a snippet

    IxUA (Constant): The current excitation, in microAmps, to apply to the excitation channel. The allowable range is ±2500 µA. For ExciteI() only, with DiffEx set to 1, the allowable range is ±12500 µA.

    Delay (Constant): The amount of time, in microseconds, to delay before moving on to the next instruction. Excitation is turned off after the specified delay. If the Delay is set to 0 (default), the datalogger will apply the desired excitation and immediately move to the next instruction without turning excitation off. The excitation will be held until the end of the program scan or until another instruction sets an excitation. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CDM_ExciteI({CDMType},{CPIAddress},{IxChan},{IxUA},{Delay})"


def CDM_ExciteV(
    CDMType: Constant,
    CPIAddress: Constant,
    ExChan: Constant,
    ExmV: Constant,
    Delay: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmexcitev.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmexcitev.htm).

                This instruction is used to set to the voltage excitation level (in millivolts) for a specified excitation channel. The Delay parameter is used to specify the length of time the excitation channel is enabled, after which, the terminal is set low and the datalogger moves on to the next instruction. If the Delay is set to 0, the excitation channel will be enabled and the voltage will be held until the end of the program scan, until another instruction sets an excitation voltage, or until the instruction is interrupted by a measurement. When the measurement is finished the excitation channel is returned to the value that was set prior to the measurement. Instructions that will not return the excitation to its former state are: CDM_PanelTemp, CDM_Therm107, 108, and 109, and all CDM bridge measurements.
    Note that any time the measurement hardware is accessed when CDM_ExciteV is exciting a channel, the excitation will be turned off for the measurement and then turned back on. This includes when the MeasOff parameter of a subsequent voltage measurement instruction is set to True (and thus a measurement is made), or when a CDM_ExciteV resides in a slow sequence scan and the main scan makes a measurement. This interruption in CDM_ExciteV may adversely affect the sensor measurement. In general, the use of CDM_ExciteV in a slow sequence scan should be avoided.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered. Right-click within the parameter to display a list of valid options.

            ExmV (Constant): Excitation, in millivolts, to apply to the sensor. The allowable range is ±5000 mV.

            Delay (Constant): The amount of time, in microseconds, to delay before moving on to the next instruction. Excitation is turned off after the specified delay. If the Delay is set to 0 (default), the datalogger will apply the desired excitation and immediately move to the next instruction without turning excitation off. The excitation will be held until the end of the program scan or until another instruction sets an excitation. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_ExciteV({CDMType},{CPIAddress},{ExChan},{ExmV},{Delay})"


def CDM_MuxSelect(
    CDMType: Constant,
    CPIAddress: Constant,
    ClkPort: Constant,
    ResetPort: Constant,
    ClockPW: Constant,
    MuxChan: Constant,
    Mode: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmmuxselect.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmmuxselect.htm).

                This instruction "wakes up" the multiplexer and clocks it to the specified starting channel. It can be used in conjunction with the SubScan and PulsePort instructions to step through the multiplexer's measurement channels to make measurements.
    When measurements are completed, the ResetPort should be set low using PortSet to turn off the multiplexer (see example).

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            ClkPort (Constant): The switched 5V port that will be used to clock (ClkPort) or wake up and reset (ResetPort) the multiplexer. If multiple mutiplexers are used in the program, each must have a unique ResetPort. A numeric code is entered for this argument. Valid ports vary depending upon the CDMType. Right-click the parameter for a drop-down list of valid options.

            ResetPort (Constant): The switched 5V port that will be used to clock (ClkPort) or wake up and reset (ResetPort) the multiplexer. If multiple mutiplexers are used in the program, each must have a unique ResetPort. A numeric code is entered for this argument. Valid ports vary depending upon the CDMType. Right-click the parameter for a drop-down list of valid options.

            ClockPW (Constant): Used to control the period of the clock used to advance the multiplexer. The value is entered in milliseconds.

            MuxChan (Constant): Specifies the first measurement channel on the multiplexer. It can be a constant or a variable. If programmed as a variable, the datalogger program will be forced into SequentialMode at compile time.

            Mode (Constant): Specifies what type of clocking will be used. Enter 0 for AM16/32A clocking and 1 for AM16/32B clocking.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_MuxSelect({CDMType},{CPIAddress},{ClkPort},{ResetPort},{ClockPW},{MuxChan},{Mode})"


def CDM_PanelTemp(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    ThermChan: Literal["1", "2", "3", "4"],
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmpaneltemp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmpaneltemp.htm).

                A measurement from the CDM_PanelTemp instruction can be used as the reference temperature for one or more thermocouple measurements. The CDM devices have multiple thermistors built into the wiring panel. If using this instruction for a thermocouple measurement, choose the thermister closest to the analog channel on which you wish to make the thermocouple measurement.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_PanelTemp instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            ThermChan (Constant): Used to select the thermistor that will be used for the measurement. Select the ThermChan that is closest to the analog measurement you are making. If the Reps parameter is  >1, ThermChan will be incremented by 1 for each rep. Valid channels will vary depending upon the CDM being used. Right-click the parameter to display a drop-down list box.
      Must be one of following options: 1 (Terminals 1
    through 8), 2 (Terminals 9
    through 16), 3 (Terminals 17
    through 24), 4 (Terminals 25
    through 32)

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_PanelTemp({CDMType},{CPIAddress},{Dest},{Reps},{ThermChan},{fN1})"


def CDM_PeriodAvg(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Gain: Literal["0", "1", "2", "3"],
    SEChan: Constant,
    Threshold: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Option: Literal["0", "1"],
    Cycles: Constant,
    Timeout: Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmperiodavg.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmperiodavg.htm).

              The CDM_PeriodAvg instruction returns the measurement of a signal in either microseconds (period) or Hertz (frequency). Processing instructions can then be used to convert the output to engineering units.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_PeriodAvg instruction, when the Source is not an array, or only a single variable in the array should be averaged, Reps should be 1.

          Gain (Constant): Used to set the voltage gain for the input signal prior to going into the zero crossing comparator. Enter the code for the desired option.
    Must be one of following options: 0 (1), 1 (3.8), 2 (19), 3 (66)

          SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

          Threshold (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines the threshold, in millivolts, (input referred) at which the comparator will trigger to count transitions. This allows the user to measure signals not centered around the default threshold of zero Volts. This parameter should be set to the average DC voltage of the signal relative to datalogger ground.

          Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies whether to output the frequency or the period of the signal.
    Must be one of following options: 0 (Period of the signal is returned), 1 (Frequency of the signal is returned)

          Cycles (Constant): The Cycles parameter specifies the number of cycles to average each scan. The specified number of cycles are timed with a resolution of 135 ns, making the resolution of the period measurement 135 ns divided by the number of Cycles measured.

          Timeout (Constant): The maximum time duration, in milliseconds, that the logger will wait for the number of Cycles to be measured for the average calculation. An overrange value will be stored if the Timeout period is exceeded. The maximum Timeout is 1000 ms.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_PeriodAvg({CDMType},{CPIAddress},{Dest},{Reps},{Gain},{SEChan},{Threshold},{Option},{Cycles},{Timeout},{Mult},{Offset})"


def CDM_PulsePort(
    CDMType: Constant,
    CPIAddress: Constant,
    SW5Port: Literal["1", "2", "3", "4"],
    Delay: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmpulseport.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmpulseport.htm).

              This instruction toggles a digital channel (or "port"), delays the specified amount of time, toggles the channel, and then delays a second time. The second delay in the instruction allows it to be used to create a 50 percent duty cycle clock for clocking multiplexers.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          SW5Port (Constant): The switched 5 volt port to use with this instruction. The number of available ports depends upon the CDM being programmed. Right-click the parameter for a list of valid options.
    Must be one of following options: 1 (Switched 5V 1), 2 (Switched 5V 2), 3 (Switched 5V 3), 4 (Switched 5V 4)

          Delay (Constant): The amount of time, in microseconds, to delay after toggling the port. The delay is used after both the first and second toggles of the port.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_PulsePort({CDMType},{CPIAddress},{SW5Port},{Delay})"


def CDM_Resistance(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal["mV5000", "mV1000", "mV200"],
    DiffChan: Constant,
    IexChan: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    MeasPEx: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ExuA: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RevEx: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    MeasCurrent: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmresistance.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmresistance.htm).

              The resistance is determined by applying a known excitation current to a circuit and dividing the resultant voltage by the excitation current. The maximum excitation current is 2500 μA. If multiple sensors are measured during current excitation, the sensors should be connected in series, rather than in parallel. The sum of the voltages that develops across each resistor when the excitation current is applied cannot exceed the specified compliance voltage for each excitation channel (+/- 5V). The MeasPEx and ExuA arguments are used to specify the number sensors to exicite with a given excitation channel. The output of the measurement is a ratio of the measured voltage and the known current excitation. Example calculations follow.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_Resistance measurement, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered:
    Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV)

          DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

          IexChan (Variable | Constant | Expression | Array | Integer | ConstantInteger): The excitation channel (X1, X2, etc.) to use for the first measurement. The number of available channels depends upon the CDM being programmed. Right-click the parameter for a list of valid options. If the Reps parameter is greater than 1, the excitation channel used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.

          MeasPEx (Variable | Constant | Expression | Array | Integer | ConstantInteger): The MeasPEx argument specifies the number of sensors to excite with the same excitation channel before automatically advancing to the next excitation channel. To excite all sensors with the same excitation channel, the value of MeasPEx should be set equal to the Reps parameter. If multiple sensors are measured during current excitation, the sensors should be connected in series, rather than in parallel. For example, instead of connecting the low side of the resistor to ground, the low side connects to the high side of the next resistor being measured. The last resistor in the chain will tie to ground. With the sensors connected in series, you need to consider the voltage that develops across each resistor when the excitation current is applied (V = IR). The sum of these voltages cannot exceed the specified compliance voltage for each excitation channel (+/- 5V). For example, if you’re exciting a string of 350-ohm resistors with the full 2.5 mA of current excitation, the voltage across each resistor is 0.0025 * 350 = 0.875 V per resistor. Then, 5 V compliance voltage/ 0.875 V per resistor = 5.714 resistors. So, you could measure up to five 350-ohm resistors per excitation channel. Hence, to measure eight of these sensors, 8 would be entered for the Reps argument and 5 for the MeasPEx argument. The first 5 sensors would all be connected to the first excitation channel, and the next 3 to the second excitation channel.

          ExuA (Variable | Constant | Expression | Array | Integer | ConstantInteger): The ExuA argument is the current excitation, in μAmps, to apply to the sensor. The allowable range is ±2500 μA. Reducing the excitation current may allow additional sensors to be excited with one excitation channel. For example, in the example above for MeasPEx, if we decrease the excitation current to 2 mA , (V=IR), 0.002 * 350 = 0.7 V per resistor. Then divide the maximum compliance voltage for an excitation channel (5 V) by the volts per sensor: 5 V/0.7 V per resistor = 7.14 resistors. So, by decreasing the excitation current to 2 mA instead of 2.5 mA, you could measure up to seven 350-ohm resistors per excitation channel. Note that because output for this instruction is ratometric, output is scaled to the excitation current.

          RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
    Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          MeasCurrent (Variable | Constant | Expression | Array | Integer | ConstantInteger): An optional parameter added with OS 3 which, when set to 1, instructs the datalogger to return the current measurement as the last measurement in the array. Dest must be dimensioned appropriately to store the additional measurement. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_Resistance({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{IexChan},{MeasPEx},{ExuA},{RevEx},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset},{MeasCurrent})"


def CDM_Resistance3W(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal["mV5000", "mV1000", "mV200"],
    SEChan: Constant,
    IexChan: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    MeasPEx: Constant,
    ExuA: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RevEx: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    MeasCurrent: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmresistance3w.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmresistance3w.htm).

                This instruction makes three measurements. First, to compute the circuit current, the specified excitation current is applied and the voltage across the internal precision resistor is measured differentially (Vi). The inputs are then reversed and a second measurement is made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Next, the specified channel is measured as a single ended measurement (V1). Finally, the next higher channel is measured as a single ended measurement (V2).
    The instruction returns Rs = (2*V2-V1) Ri / Vi
    where Ri is the precision internal resistor value that is saved as part of the factory calibration procedure and Rs is the sense resistance.
    If reverse excitation (RevEx) is specified, it is performed on all three measurements.
    The following image shows the measurements. Rw is the resistance of the lead wires. These are assumed to be matched.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_Resistance measurement, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered:
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV)

            SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            IexChan (Variable | Constant | Expression | Array | Integer | ConstantInteger): The excitation channel (X1, X2, etc.) to use for the first measurement. The number of available channels depends upon the CDM being programmed. Right-click the parameter for a list of valid options. If the Reps parameter is greater than 1, the excitation channel used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.

            MeasPEx (Constant): The number of sensors to excite with the same excitation terminal before automatically advancing to the next excitation terminal. To excite all sensors with the same excitation terminal, the value of this parameter should be set equal to the value of the Reps parameter.  This parameter in a bridge measurement can be used when the sensors to be measured outnumber the available excitation channels. It allows multiple sensors to be excited with each excitation channel.   For example, assume it is desired to measure eight pressure transducers that have 350 ohm full bridge strain gages to be excited by 5 volts. Each transducer requires 14 mA (5 volts/350 ohms = 14 mA). Since each excitation channel can provide a maximum of 50 mA at 5 volts, a maximum of 3 pressure transducers can be excited per channel (50 mA/14 mA = 3.57). To measure the eight transducers, 8 would be entered for the Reps argument and 3 for the MeasPEx. The first three transducers would all be connected to the first excitation channel, the next 3 to the second excitation channel, and the last 2 to the third excitation channel.

            ExuA (Variable | Constant | Expression | Array | Integer | ConstantInteger): The ExuA argument is the current excitation, in μAmps, to apply to the sensor. The allowable range is ±2500 μA. Reducing the excitation current may allow additional sensors to be excited with one excitation channel. For example, in the example above for MeasPEx, if we decrease the excitation current to 2 mA , (V=IR), 0.002 * 350 = 0.7 V per resistor. Then divide the maximum compliance voltage for an excitation channel (5 V) by the volts per sensor: 5 V/0.7 V per resistor = 7.14 resistors. So, by decreasing the excitation current to 2 mA instead of 2.5 mA, you could measure up to seven 350-ohm resistors per excitation channel. Note that because output for this instruction is ratometric, output is scaled to the excitation current.

            RevEx (Constant): A constant is entered for the RevEx argument to determine whether the excitation  should be reversed and applied to the sensor after the first measurement is made. False (or 0) = Do not reverse excitation ; True (or 1) = Reverse excitation  and make a second measurement (requires more time to complete). Use of RevEx cancels out voltage offsets due to the sensor, wiring, and excitation circuitry, but does not compensate for operational input voltage errors.

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            MeasCurrent (Variable | Constant | Expression | Array | Integer | ConstantInteger): An optional parameter added with OS 3 which, when set to 1, instructs the datalogger to return the current measurement as the last measurement in the array. Dest must be dimensioned appropriately to store the additional measurement.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_Resistance3W({CDMType},{CPIAddress},{Dest},{Reps},{Range},{SEChan},{IexChan},{MeasPEx},{ExuA},{RevEx},{SettlingTime},{fN1},{Mult},{Offset},{MeasCurrent})"


def CDM_SW12(
    CDMType: Constant,
    CPIAddress: Constant,
    Port: Constant,
    State: Literal["0", "≠0"],
    Option: Literal["Omitted", "0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmsw12.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmsw12.htm).

              The CDM device has one or more switched 12 volt outputs, depending upon the device. These channels are used to provide a 12 volt supply to external peripherals under program control. At room temperature the switched 12 volt supply can source 900 mA between the SW12 terminal and Ground.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Port (Constant): The switched 12 volt port (1=S12-1 or 2=S12-2) to use with this instruction. The number of available ports depends upon the CDM being programmed. Right-click the parameter for a list of valid options.

          State (Variable | Constant | Expression): Determines whether to set the port high or low. Right-click to display a list.
    Must be one of following options: 0 (Low), ≠0 (High)

          Option (Constant): An optional parameter that determines whether the instruction will run in the measurement task sequence or the processing task sequence, and also affects whether the program will compile and run in SequentialMode or PipelineMode: *other programming may force the program into SequentialMode Running this  instruction in the processing task when the program is run in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization. can prove to be problematic if you are using the instruction to power a sensor. Because processing tasks can lag behind measurement tasks in PipelineMode, the instruction may be processed by the device after the measurement has already been made. To avoid this scenario, program the datalogger to operate in SequentialMode. NOTE: The SW12 supply is unregulated and can supply up to 1.10 A at 20 degrees C, 640 mA at 70 degrees C, and 500 mA at 85 degrees C. A resettable polymeric fuse protects against over-current. Reset is accomplished by removing the load or turning off the SW12 for several seconds.
    Must be one of following options: Omitted (Instruction is run within the measurement task sequence; program will compile in SequentialMode), 0 (Instruction is run within the measurement task sequence; program will attempt to compile in PipelineMode*), 1 (Instruction is run within the processing task sequence; program will attempt to compile in PipelineMode*)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_SW12({CDMType},{CPIAddress},{Port},{State},{Option})"


def CDM_SW5(
    CDMType: Constant,
    CPIAddress: Constant,
    SW5Port: Literal["1", "2", "3", "4"],
    State: Literal["0", "≠0"],
    Option: Literal["Omitted", "0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmsw5.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmsw5.htm).

              The CDM device has one or more switched 5 volt outputs, depending upon the device. These channels are used to provide a 5 volt supply to external peripherals under program control.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          SW5Port (Constant): The switched 5 volt port to use with this instruction. The number of available ports depends upon the CDM being programmed. Right-click the parameter for a list of valid options.
    Must be one of following options: 1 (Switched 5V 1), 2 (Switched 5V 2), 3 (Switched 5V 3), 4 (Switched 5V 4)

          State (Variable | Constant | Expression): Determines whether to set the port high or low. Right-click to display a list.
    Must be one of following options: 0 (Low), ≠0 (High)

          Option (Constant): An optional parameter that determines whether the instruction will run in the measurement task sequence or the processing task sequence, and also affects whether the program will compile and run in SequentialMode or PipelineMode: *other programming may force the program into SequentialMode Running this  instruction in the processing task when the program is run in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization. can prove to be problematic if you are using the instruction to power a sensor. Because processing tasks can lag behind measurement tasks in PipelineMode, the instruction may be processed by the device after the measurement has already been made. To avoid this scenario, program the datalogger to operate in SequentialMode.
    Must be one of following options: Omitted (Instruction is run within the measurement task sequence; program will compile in SequentialMode), 0 (Instruction is run within the measurement task sequence; program will attempt to compile in PipelineMode*), 1 (Instruction is run within the processing task sequence; program will attempt to compile in PipelineMode*)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_SW5({CDMType},{CPIAddress},{SW5Port},{State},{Option})"


def CDM_SWPower(
    CDMType: Constant,
    CPIAddress: Constant,
    State: Literal["0", "≠0"],
    Option: Literal["Omitted", "0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmswpower.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmswpower.htm).

              Each Volt 408 isolation module has one switched 12V port and one switched 5V port.  The 12V port and the 5V port are switched together with a single CDM_SWPower() instruction.  The switched 12V port and the switched 5V port cannot be set independently. These ports are used to provide a 12V or a 5V supply to external peripherals under program control. The current limit of the 12 V port is 200 mA. The current limit of the 5V port is 300 mA.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          State (Variable | Constant | Expression): Determines whether to set the port high or low. Right-click to display a list.
    Must be one of following options: 0 (Low), ≠0 (High)

          Option (Constant): An optional parameter that determines whether the instruction will run in the measurement task sequence or the processing task sequence, and also affects whether the program will compile and run in SequentialMode or PipelineMode: *other programming may force the program into SequentialMode Running this  instruction in the processing task when the program is run in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization. can prove to be problematic if you are using the instruction to power a sensor. Because processing tasks can lag behind measurement tasks in PipelineMode, the instruction may be processed by the device after the measurement has already been made. To avoid this scenario, program the datalogger to operate in SequentialMode.
    Must be one of following options: Omitted (Instruction is run within the measurement task sequence; program will compile in SequentialMode), 0 (Instruction is run within the measurement task sequence; program will attempt to compile in PipelineMode*), 1 (Instruction is run within the processing task sequence; program will attempt to compile in PipelineMode*)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_SWPower({CDMType},{CPIAddress},{State},{Option})"


def CDM_TCDiff(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Constant,
    TCType: Literal[
        "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    TRef: Variable | Expression | Array,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtcdiff.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtcdiff.htm).

                The calculations used for the CDM_TCDiff instruction are based on the thermocouple type selected (TCType). The instruction adds the measured voltage to the voltage calculated for the reference temperature relative to 0 degrees Celsius, and converts the combined voltage to temperature in degrees Celsius.
    The CDM has thermisters under the wiring panel that can be used as reference temperatures for thermocouple measurements. Refer to the CDM_PanelTemp instruction.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_TCDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric code is entered. Right-click on the parameter to display a list of valid options. NOTE: When using TEMP408 modules, the TCType selected must match the module type.
      Must be one of following options: TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

            TRef (Variable | Expression | Array): The name of the variable that is the source of the reference temperature (or the result of the reference temperature measurement), in degrees C, for the thermocouple measurements. Right-click the parameter to display a list of defined variables.

            Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
      Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_TCDiff({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{TCType},{TRef},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_TCSe(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    TCType: Literal[
        "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    TRef: Variable | Expression | Array,
    MeasOff: Literal["0", "1"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtcse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtcse.htm).

                The calculations used for the CDM_TCSE instruction are based on the thermocouple type selected (TCType). The instruction adds the measured voltage to the voltage calculated for the reference temperature relative to 0 degrees Celsius, and converts the combined voltage to temperature in degrees Celsius.
    The CDM has thermisters under the wiring panel that can be used as reference temperatures for thermocouple measurements. Refer to the CDM_PanelTemp instruction.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_TCSE instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric code is entered. Right-click on the parameter to display a list of valid options. NOTE: When using TEMP408 modules, the TCType selected must match the module type.
      Must be one of following options: TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

            TRef (Variable | Expression | Array): The name of the variable that is the source of the reference temperature (or the result of the reference temperature measurement), in degrees C, for the thermocouple measurements. Right-click the parameter to display a list of defined variables.

            MeasOff (Constant): Determines whether the ground offset voltage is measured before the measurement is made on the analog channel. If the ground offset is measured it is subtracted from the sensor measurement and the result is stored in Dest.
      Must be one of following options: 0 (Offset voltage is corrected from background calibration.), 1 (Offset voltage is measured each scan  (this option
    effectively increases the measurement time as if an additional rep were added to
    the instruction).)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_TCSe({CDMType},{CPIAddress},{Dest},{Reps},{Range},{SEChan},{TCType},{TRef},{MeasOff},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_Therm107(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_Therm instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

          ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered.If multiple thermistors are measured with one instruction, all repetitions use the same excitation channel. Right-click within the parameter to display a list of valid options.

          SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
    Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_Therm107({CDMType},{CPIAddress},{Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_Therm108(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_Therm instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

          ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered.If multiple thermistors are measured with one instruction, all repetitions use the same excitation channel. Right-click within the parameter to display a list of valid options.

          SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
    Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_Therm108({CDMType},{CPIAddress},{Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_Therm109(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Constant,
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtherm107cdmtherm108cdmtherm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_Therm instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

          ExChan (Constant): Enter the excitation channel number (X1, X2...) used to excite the first measurement. The number of available channels depends upon the CDM being programmed. An alphanumeric code is entered.If multiple thermistors are measured with one instruction, all repetitions use the same excitation channel. Right-click within the parameter to display a list of valid options.

          SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
    Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_Therm109({CDMType},{CPIAddress},{Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_VoltSE(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    MeasOff: Literal["0", "1"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvoltse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvoltse.htm).

                This instruction measures the voltage of a single ended analog channel with respect to ground.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_VoltDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel to use with this instruction. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the SEChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, which can go up to a maximum of 93750 Hz (minimum sample interval of 10.667µS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 810µS). The sample interval resolution is 1/93750Hz. The specified notch frequency will use the nearest multiple of (1/93750Hz) to get as close to the specified frequency as possible.

            MeasOff (Constant): Determines whether the ground offset voltage is measured before the measurement is made on the analog channel. If the ground offset is measured it is subtracted from the sensor measurement and the result is stored in Dest.
      Must be one of following options: 0 (Offset voltage is corrected from background calibration.), 1 (Offset voltage is measured each scan  (this option
    effectively increases the measurement time as if an additional rep were added to
    the instruction).)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_VoltSE({CDMType},{CPIAddress},{Dest},{Reps},{Range},{SEChan},{MeasOff},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_VoltDiff(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mV200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvoltdiff.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvoltdiff.htm).

                This instruction measures the voltage difference between the high and low inputs of a differential channel. Both the high and low inputs must be within ± 5V of the datalogger's ground (Input range).

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_VoltDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected voltage range of the input from the sensor. An alphanumeric code is entered. Note that not all ranges are valid for all CDM types. Right-click the parameter to display a list of valid ranges.  For signals that do not fluctuate too rapidly, AutoRange allows the CDM to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.  The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input.  The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (±5000 mV), mV1000 (±1000 mV), mV200 (±200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (±5000 mV, checks for open input, sets excitation to ~5600 mV.
    Overrange values may go undetected; use code to detect overrange values.), mV1000C (±1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (±200 mV, checks for open input, sets excitation to ~1250 mV.)

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
      Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

            SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
      Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_VoltDiff({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_CurrentDiff(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal["mA20"],
    DiffChan: Constant,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal[
        "30000",
        "60",
        "50",
        "15000",
        "7500",
        "3750",
        "2000",
        "1000",
        "500",
        "100",
        "30",
        "25",
        "15",
        "10",
        "5",
        "2.5",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmcurrentdiff.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmcurrentdiff.htm).

              This instruction measures the loop current flowing into the high terminal and returning out the low terminal.

    Args:
                  CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

          CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

          Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CDM_CurrentDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The expected current range of the input from the sensor. An alphanumeric code is entered.
    Must be one of following options: mA20 (±20 mA)

          DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          SettlingTime (Constant): The amount of time to delay, in microseconds, after setting up a measurement and before making the measurement on the CDM. Minimum settling time is 100 microseconds; maximum settling time is 100 ms. If 0 is entered, a default of 500 microseconds is used.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Any value between 2.5 Hz and 30,000 Hz can be entered, but the value entered will be rounded to the nearest of the frequencies below. The three most common noise filtering options are listed first.
    Must be one of following options: 30000 (Performs a 0.0333 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise)), 15000 (Performs a 0.0667 millisecond integration), 7500 (Performs a 0.0133 millisecond integration), 3750 (Performs a 0.2667 millisecond integration), 2000 (Performs a 0.5 millisecond integration), 1000 (Performs a 1 millisecond integration), 500 (Performs a 2 millisecond integration), 100 (Performs a 10 millisecond integration), 30 (Performs a 33.33 millisecond integration), 25 (Performs a 40 millisecond integration), 15 (Performs a 66.67 millisecond integration), 10 (Performs a 100 millisecond integration), 5 (Performs a 200 millisecond integration), 2.5 (Performs a 400 millisecond integration)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information. Caution: Do NOT place this instruction inside a conditional statement when running in pipeline mode A CRBasic program execution mode wherein instructions are evaluated in groups of like instructions, with a set group prioritization..

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CDM_CurrentDiff({CDMType},{CPIAddress},{Dest},{Reps},{Range},{DiffChan},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def CDM_VW300Config(
    DeviceType: Constant,
    CPIAddress: Constant,
    SysOptions: Literal["0", "1", "10", "11"],
    ChanEnable: Variable,
    ResonAmp: Variable,
    LowFreq: Literal["20", "50", "100", "200", "333"],
    HighFreq: Literal["20", "50", "100", "200", "333"],
    ChanOptions: Variable,
    Mult: Constant,
    Offset: Variable,
    SteinA: Variable,
    SteinB: Variable,
    SteinC: Variable,
    RF_MeanBins: Variable,
    RF_AmpBins: Variable,
    RF_LowLim: Variable,
    RF_HighLim: Variable,
    RF_Hyst: Variable,
    RF_Form: Literal["A", "A", "B", "B", "C", "C"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300config2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300config2.htm).

                The CDM_VW300Config instruction should be placed before the BeginProg statement in the CRBasic program. Before starting the datalogger program, the datalogger configures the specified CDM device according to the settings given as parameters of this instruction.

    Args:
                    DeviceType (Constant): The type of module being configured. Right-click in the parameter box to display a drop-down list of defined variables.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs). NOTE: This instruction cannot be used to set the CPI address stored within a VWIRE 305, CDM-VW300 or CDM-VW305 device. That must be done using Device Configuration Utility Configuration tool used to set up dataloggers and peripherals, and to configure PakBus settings before those devices are deployed in the field and/or added to networks., DVW Toolbox software, or the CPIAddModule instruction.

            SysOptions (Variable): Determines if a numeric value or NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored when a flag condition occurs, and whether or not the diagnostic LEDs are on or off. The following are valid options: Disabling the LEDs offers some measure of power conservation. Refer to the CDM_VW300Dynamic instruction for additional information on diagnostic flags.
      Must be one of following options: 0 (Display numeric
    output when diagnostic flags are set; LEDs are operational), 1 (Display NANs when
    diagnostic flags are set; LEDs are operational), 10 (Display numeric output
    when diagnostic flags are set; LEDs are disabled), 11 (Display NANs when
    diagnostic flags are set; LEDs are disabled)

            ChanEnable (Variable): A variable that enables or disables the channels on a VWIRE 305 or CDM-VW3XX device. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter a 0 or a 1 to disable or enable the corresponding channels.

            ResonAmp (Variable): Holds the desired output voltage amplitude of the steady-state resonant response of the sensor in units of Volts. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the voltage for the corresponding channel number. The default value is 0.002V.

            LowFreq (Variable): Sets the lower and upper bounds of the resonant frequency expected on the sensor. The parameters are dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. Valid ranges depend upon the scan rate, according to the following:
      Must be one of following options: 20 (290
    Hz), 50 (290
    Hz), 100 (580
    Hz), 200 (1150
    Hz), 333 (2300
    Hz)

            HighFreq (Variable): Sets the lower and upper bounds of the resonant frequency expected on the sensor. The parameters are dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. Valid ranges depend upon the scan rate, according to the following:
      Must be one of following options: 20 (290
    Hz), 50 (290
    Hz), 100 (580
    Hz), 200 (1150
    Hz), 333 (2300
    Hz)

            ChanOptions (Variable): Used to determine if the measured frequency is output in units of Hz or Hz^2. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter a 0 (Hz) or 1 (Hz^2) to configure the respective channel number.

            Mult (Constant): The multiplier that will be applied to the output for each channel. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired multiplier for the respective channel number.

            Offset (Variable): The offset that will be applied to the output for each channel. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305.

            SteinA (Variable): The coefficients to use for A, B, and C in the Steinhart-Hart equation for calculating the thermistor temperature (degrees Celsius) for each channel of the CDM device. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired coefficients for the respective channel number. To output Ohms from the thermistor, set the parameters to 0.

            SteinB (Variable): The coefficients to use for A, B, and C in the Steinhart-Hart equation for calculating the thermistor temperature (degrees Celsius) for each channel of the CDM device. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired coefficients for the respective channel number. To output Ohms from the thermistor, set the parameters to 0.

            SteinC (Variable): The coefficients to use for A, B, and C in the Steinhart-Hart equation for calculating the thermistor temperature (degrees Celsius) for each channel of the CDM device. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired coefficients for the respective channel number. To output Ohms from the thermistor, set the parameters to 0.

            RF_MeanBins (Variable): Specifies the number of bins for the Mean axis of the rainflow histogram. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired number of bins for the respective channel number. The minimum value is 1; the product of RF_MeanBins and RF_AmpBins cannot exceed 4096.

            RF_AmpBins (Variable): Specifies the number of bins for the Amplitude axis of the rainflow histogram. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired number of bins for the respective channel number. The minimum value is 1; the product of RF_MeanBins and RF_AmpBins cannot exceed 4096.

            RF_LowLim (Variable): Specifies the lower limits of the histogram range for the rainflow histogram calculations. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired lower limit for the respective channel number.

            RF_HighLim (Variable): Specifies the upper limits of the histogram range for the rainflow histogram calculations. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the desired upper limit for the respective channel number.

            RF_Hyst (Variable): Sets the minimum amplitude of a cycle for it to be counted in the rainflow histogram. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter the minimum amplitude for the respective channel number.

            RF_Form (Variable): Defines the form for the rainflow histogram. This parameter is dimensioned to two for the CDM-VW300 and eight for the VWIRE 305 or CDM-VW305. For each element of the array, enter a three-digit code in the format of ABC, based on the following:
      Must be one of following options: A (Reset histogram after each output), A (Do not reset histogram), B (Divide bins by total count), B (Output total in each bin), C (Open form; include outside range values in end bins), C (Closed form; exclude values outside range)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_VW300Config({DeviceType},{CPIAddress},{SysOptions},{ChanEnable},{ResonAmp},{LowFreq},{HighFreq},{ChanOptions},{Mult},{Offset},{SteinA},{SteinB},{SteinC},{RF_MeanBins},{RF_AmpBins},{RF_LowLim},{RF_HighLim},{RF_Hyst},{RF_Form})"


def CDM_VW300Dynamic(
    CPIAddress: Constant, DestFreq: Variable, DestDiag: Variable
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300dynamic2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300dynamic2.htm).

                The CDM_VW300Dynamic instruction measures the resonant frequency or square of the resonant frequency of a vibrating wire sensor, depending upon the ChanOptions of the CDM_VW300Config instruction. The update/output interval of the measurement is based on the scan rate at which the instruction is executed. The CDM_VW300Config instruction's multipliers and offsets are applied to the results of the measurements before being stored in the DestFreq variable. This instruction should be run in the main scan of the CRBasic program.
    This instruction also stores diagnostic information for the measurements. Refer to CDM-VW300 Diagnostic Codes for additional information.

    Args:
                    CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs). NOTE: Use Device Configuration Utility Configuration tool used to set up dataloggers and peripherals, and to configure PakBus settings before those devices are deployed in the field and/or added to networks., DVW Toolbox software, or the CPIAddModule instruction to configure the CPIAddress within your VWIRE 305 or CDM-VW300 series device.

            DestFreq (Variable): The variable array in which to store the measurement values streaming from the device. The values are output in Hz or Hz^2, depending upon the CDM_VW300Config instruction. The array should be dimensioned to two for the CDM-VW300 or eight for the VWIRE 305 or CDM-VW305.

            DestDiag (Variable): The variable array in which to store diagnostic values. The array should be dimensioned to two for the CDM-VW300 or eight for the VWIRE 305 or CDM-VW305.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_VW300Dynamic({CPIAddress},{DestFreq},{DestDiag})"


def CDM_VW300Static(
    CPIAddress: Constant, DestFreq: Variable, DestTherm: Variable, DestStdDev: Variable
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300static2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300static2.htm).

        The CDM_VW300Static instruction measures the resonant frequency or square of the resonant frequency of a vibrating wire sensor, depending upon the ChanOptions of the CDM_VW300Config instruction. The frequency (update interval) of the measurement output is 1 Hz. The program scan interval must be 50, 20, 10, 5, or 3 mS (20, 50, 100, 200, or 333 Hz) and the CDM_VW300Static instruction must be called conditionally (using TimeIntoInterval) at a 1 second interval (1 Hz). The CDM_VW300Config instruction multipliers and offsets are applied to the results of the measurements before being stored in the DestFreq variable.

    Args:
            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs). NOTE: Use Device Configuration Utility Configuration tool used to set up dataloggers and peripherals, and to configure PakBus settings before those devices are deployed in the field and/or added to networks., DVW Toolbox software, or the CPIAddModule instruction to configure the CPIAddress within your VWIRE 305 or CDM-VW300 series device.

    DestFreq (Variable): The variable array in which to store the static measurement values streaming from the device at 1 Hz. The values are output in Hz or Hz^2, depending upon the CDM_VW300Config instruction. The array should be dimensioned to two for the CDM-VW300 or eight for the VWIRE 305 or CDM-VW305.

    DestTherm (Variable): The variable array in which to store the thermistor values streaming from the device. The array should be dimensioned to two for the CDM-VW300 or eight for the VWIRE 305 or CDM-VW305. If the SteinA/B/C are non-zero in CDM_VW300Config this value will be in DegC; otherwise, when using zeroes for ABC this value is in Ohms.

    DestStdDev (Variable): The variable array in which to store the calculated standard deviation of the dynamic data values take over the last second. The values are output at a rate of 1 Hz. The array should be dimensioned to two for the CDM-VW300 or eight for the VWIRE 305 or CDM-VW305.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CDM_VW300Static({CPIAddress},{DestFreq},{DestTherm},{DestStdDev})"


def CDM_VW300Rainflow(
    CPIAddress: Constant,
    RFx: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300rainflow1.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmvw300rainflow1.htm).

        The CDM_VW300RainFlow instruction is a processing instruction. It must be used in a SlowSequence scan.To output the results to a data table, use the RainFlowSample instruction.

    Args:
            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs). NOTE: Use Device Configuration Utility Configuration tool used to set up dataloggers and peripherals, and to configure PakBus settings before those devices are deployed in the field and/or added to networks., DVW Toolbox software, or the CPIAddModule instruction to configure the CPIAddress within your VWIRE 305 or CDM-VW300 series device.

    RFx (Variable | Constant | Expression | Array | Integer | ConstantInteger): Two-dimensional arrays in which to store the rainflow histogram for each channel measured on the device. The first dimension is the number of Mean bins and the second dimension is the number of amplitude bins. For the CDM-VW300, only two variable arrays are required (RF1 and RF2); for the VWIRE 305 or CDM-VW305 eight variable arrays are required (RF1 – RF8).

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CDM_VW300Rainflow({CPIAddress},{RFx})"


def CDM_TCComp(
    CDMType: Constant,
    CPIAddress: Constant,
    Dest: Variable | Array,
    Reps: Constant,
    DiffChan: Constant,
    TCType: Literal[
        "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    FilterEnable: Literal["0", "1"],
    Units: Literal["0", "1", "2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtccomp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cdmtccomp.htm).

                In contrast to the CDM_TCDiff instruction, the CDM_TCComp instruction automatically performs cold-junction compensation using data from the junction temperature sensor nearest the specified TC input(s).  I.e., there is no reference temperature parameter for this instruction.  In addition, the CDM_TCComp instruction automatically employs input reversal to enhance measurement quality and open detection to help detect sensor wiring issues.
    The calculations used for the CDM_TCComp instruction are based on the thermocouple type selected (TCType). The instruction adds the measured voltage to the voltage calculated for the reference temperature relative to 0 degrees Celsius and converts the combined voltage to temperature in user-selected units (refer to the Units parameter).  Multiple CDMs may be used to increase the number of thermocouple measurements. Each CDM module on the bus will require its own CDM_TCComp instruction.

    Args:
                    CDMType (Constant): Used to specify the type of CDM used by the instruction. This is a read-only setting in the device which cannot be changed. Right-click the parameter to display a list of valid CDM types.

            CPIAddress (Constant): The CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. address configured in the CDM module. Valid range is 1 through 120. Note that the CPIAddress cannot be a variable because the datalogger must know all information for a given CDM module at program compile.(e.g., before the program runs).

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction.

            DiffChan (Constant): The number of the differential channel pair on which to make the first measurement. The number of available channels depends upon the CDM being programmed. If the Reps parameter is greater than 1, the additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps will be performed on the same channel (burst measurement). The burst mode sample frequency is controlled by the fN1 parameter, so there are 16 sample frequencies with a maximum of 30 kHz. The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus 180 microseconds.

            TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric code is entered. Right-click on the parameter to display a list of valid options. NOTE: When using TEMP408 modules, the TCType selected must match the module type.
      Must be one of following options: TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

            FilterEnable (Constant): If the FilterEnable parameter is set to 1 (enabled), 50 Hz and 60 Hz frequencies will be eliminated or notched out simultaneously by the sync filter. Note that when the filter is enabled, the fastest that measurements can be made is 1 Hz for all 20 channels. In contrast, if the FilterEnable parameter is set to 0 (disabled), the TEMP120 can measure all 20 channels at speeds up to 10 Hz.
      Must be one of following options: 0 (Filter disabled for fast measurements), 1 (Filter 50/60 Hz noise (AC Power))

            Units (Constant): Used to specify the units of the returned measurement. Valid options for the units parameter are:
      Must be one of following options: 0 (Celsius), 1 (Fahrenheit), 2 (Kelvin)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CDM_TCComp({CDMType},{CPIAddress},{Dest},{Reps},{DiffChan},{TCType},{FilterEnable},{Units})"


def CheckSum(
    ChkSumString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ChkSumType: Literal[
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
    ],
    ChkSumSize: Variable | Expression,
    ChkSumOpt1: Variable,
    ChkSumOpt2: Variable,
    ChkSumOpt3: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/checksum.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/checksum.htm).

                The CheckSum function returns the checksum  of a String A data type used when declaring a variable consisting of alphanumeric characters. into a variable. If the string for which the CheckSum is being calculated contains one or more null characters, the Size parameter should not be set to 0.

    Args:
                    ChkSumString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string value for which the checksum will be calculated. If a directory and filename are entered for this parameter (for example, CPU:checkfile.txt), the CheckSum will be performed on the file. All bytes in the file will be read, and the ChkSumSize parameter is ignored.

            ChkSumType (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the method of the checksum calculation. The options are:
      Must be one of following options: 1 (CCITT CRC16 x16+x12+x5+1 (Xmodem, seed of 0).), 2 (CRC16 used by ModBus.), 3 (CRC16 used by ModBus with 0 initializer.), 4 (CCITT CRC32 used by Campbell Scientific BMP3 protocol.), 5 (Campbell Scientific signature.), 6 (Campbell Scientific signature nullifier.), 7 (Sum all the bytes and mod by 256.), 8 (Sum all the bytes and mod by 8192 (used by Campbell Scientific array-based dataloggers).), 9 (Checksum which performs exclusive OR on all the bytes; for example, first byte XOR second byte XOR third byte XOR… last byte.), 10 (CRC16 with seed of 0 and XOR polynomial of &hA001.), 11 (CRC16 with seed of &hFFFF and XOR polynomial of &hA001.), 12 (CRC16 with seed of 0 and XOR polynomial of &h8408.), 13 (CRC16 with seed of &hFFFF and XOR polynomial of &h8408.), 14 (CRC16 reverse bit order with seed of 0 and XOR polynomial of &hA001.), 15 (CRC16 reverse bit order with seed of &hFFFF and XOR polynomial of &hA001.), 16 (CRC16 reverse bit order with seed of 0 and XOR polynomial of &h8408.), 17 (CRC16 reverse bit order with seed of &hFFFF and XOR polynomial of
    &h8408.), 18 (CCITT CRC16 ITU/X25.), 19 (CRC16 UKMO (UK Met office).), 22 (CRC DNP3 Distributed Network Protocol is a set of communications protocols used between components in process automation systems. Its main use is in utilities such as electric and water companies. (note that DNP is little-endian Endianness refers to byte order.  With the little-endian format, bytes are ordered with the least significant byte (the "little end") first.  With the big-endian format, bytes are ordered with the most significant byte ("big end") first. The CR300, GRANITE 9, and GRANITE 10 dataloggers use the little-endian format. The CR800, CR1000, CR3000, CR6, CR1000X, and GRANITE 6 use the big-endian format. Byte order when sending string variables as serial data is identical in big-endian and little-endian CSI dataloggers. Only numeric values sent as multiple bytes require attention to big-endian and little-endian issues. and the datalogger is big-endian. Use MoveBytes to convert Endianess.)), 23 (Returns the sum of all bytes with no masking.), 24 (Fletcher-16.), 25 (SHA1. This option requires an additional parameter that is a destination array
    that can hold 20 bytes.), 26 (SHA1, base 64 encoded. This option requires an additional parameter, typed as a string that can hold 29 characters. The result is null-terminated.), 27 (HMAC SHA1. This option requires three additional parameters: a destination array that can hold 20 bytes, a key, and the length of the key. If length is 0, the length of the key is used.), 28 (HMAC SHA1, base 64 encoded. This option requires three additional parameters: a destination array typed as a string that can hold 29 characters, a key, and the length of the key. If length is 0, the length of the key is used.), 29 (MD5 16 byte checksum of the TCP/IP VTP configuration.. This option requires an additional parameter that is a destination array
    that can hold 16 bytes.)

            ChkSumSize (Variable | Expression): Determines the size of the checksum. If 0 is entered the size of the string is used. However, if the string will contain null characters the size should not be set to 0.

            ChkSumOpt1 (Variable): Additional parameter for options 25-29

            ChkSumOpt2 (Variable): Additional parameter for options 27-28

            ChkSumOpt3 (Variable): Additional parameter for options 27-28

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CheckSum({ChkSumString},{ChkSumType},{ChkSumSize},{ChkSumOpt1},{ChkSumOpt2},{ChkSumOpt3})"


def ClockReport(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/clockreport.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/clockreport.htm).

                This instruction initiates a one-way transmission of the datalogger's clock value to a destination datalogger. No response is returned from the destination datalogger. If the destination datalogger has a PakBusClock instruction with this datalogger's address, the destination device will set its clock according to the transmitted time value.
    NOTE: The CR200 Series datalogger does not have a PakBusClock instruction, but it will accept any ClockReport it receives.
    A PakBus address of 4095 can be entered to send a ClockReport to all dataloggers in the network that the sending datalogger can communicate with directly (however, the packet will not be routed). If the dataloggers that receive the packet have a PakBusClock instruction with the sending datalogger's address, their clocks are set.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  If the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions. As noted previously, 4095 can be entered to send a clock report to all dataloggers that can be communicated with directly.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ClockReport({ComPort},{NeighborAddr},{PakBusAddr})"


def ComPortIsActive(
    ComPort: Literal[
        "ComUSB",
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/comportisactive.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/comportisactive.htm).

    Args:
                  ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If the instruction has a ResultCode parameter and a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. ComPort can also be a virtual ComPort, such as the result of a TCPOpen instruction. This can be used to determine if the socket connection is still available.
    Must be one of following options: ComUSB (Datalogger USB port), ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"ComPortIsActive({ComPort})"


def Cos(
    angle: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cos.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cos.htm).

                The COS function takes an angle and returns the ratio of two sides of a right triangle. The ratio is the length of the side adjacent to the angle divided by the length of the hypotenuse. The result lies in the range -1 to 1.
    The Angle argument can be any valid numeric expression measured in radians.
    AngleDegrees can be used to change the source for this function to degrees instead of radians.

    Args:
                    angle (Variable | Constant | Expression | Array | Integer | ConstantInteger): angle (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Cos({angle})"


def Cosh(
    expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cosh.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cosh.htm).

    Args:
        expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): expression (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Cosh({expression})"


def CSAT3(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Command: Literal["90", "91", "92", "97", "98", "99"],
    CSAT3Option: Literal[
        "1", "2", "3", "5", "6", "10", "12", "15", "20", "30", "60", "61", "62"
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3.htm).

              Refer to the CSAT3 product manual for complete information on this instruction.

    Args:
                  Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): The datalogger variable name to receive the CSAT3 data. This variable must be dimensioned to a length of five to hold the CSAT3 Ux, Uy, Uz, speed of sound and diagnostic data. Right-click the parameter to display a list of defined variables.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CSAT3 instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.  NOTE: CRBasic dataloggers use base 10 when addressing SDM devices. Edlog programmed dataloggers (e.g., CR10X, CR23X) used base 4 for addressing. For more information, see Base 10 to Base 4 Reference Chart.

          Command (Constant): Commands 90 - 92 send a measurement trigger to the CSAT3 with the SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. address specified by the SDMAddress argument. The CSAT3 also sends data to the datalogger. Options 97 - 99 get data after a group trigger, SDMTrigger(), from the CSAT3 specified by the SDMAddress parameter without triggering a new CSAT3 measurements. The CSAT() instruction must be preceded by the SDMTrigger() instruction in order to use Options 97 - 99. Right-click the parameter to display a list.
    Must be one of following options: 90 (Trigger and get wind & speed of sound data.), 91 (Trigger and get wind & sonic temperature data.), 92 (Trigger and get wind & speed of sound data minus 340 m/s.), 97 (Get wind & speed of sound data minus 340 m/s after a group trigger.), 98 (Get wind & sonic temperature data after a group trigger.), 99 (Get wind & speed of sound data after a group trigger.)

          CSAT3 Option (Constant): The Option argument sets the CSAT3’s execution parameter. This parameter tells the CSAT3 which measurement parameters to use and what frequency to expect the measurement trigger from the datalogger. See the table below for a brief description of each of the parameter and the CSAT3 manual for a detailed description. Right-click the parameter to display a list.
    Must be one of following options: 1 (Set execution parameter to 1 Hz), 2 (Set execution parameter to 2 Hz), 3 (Set execution parameter to 3 Hz), 5 (Set execution parameter to 5 Hz), 6 (Set execution parameter to 6 Hz), 10 (Set execution parameter to 10 Hz), 12 (Set execution parameter to 12 Hz), 15 (Set execution parameter to 15 Hz), 20 (Set execution parameter to 20 Hz), 30 (Set execution parameter to 30 Hz), 60 (Set execution parameter to 60 Hz), 61 (Set execution parameter to 60 Hz to 10 Hz oversample mode), 62 (Set execution parameter to 60 Hz to 20 Hz oversample mode)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CSAT3({Dest},{Reps},{SDMAddress},{Command},{CSAT3Option})"


def CSAT3B(
    Dest: Variable,
    Bus: Constant,
    Address: Constant,
    Mode: Literal["0", "5", "10", "25"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3b.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3b.htm).

                This instruction sets the operating mode of the anemometer and retrieves the wind, sonic temperature, and diagnostic information from the CSAT3B. The instruction should appear in the main scan of the program, operating in pipeline mode.
    Each CSAT3B must have its own instruction because there is state information that is maintained for each module. The allocation of the state information is done when the instruction is compiled.

    Args:
                    Dest (Variable): A variable array that stores the values returned by the anemometer. It must be declared as a float with at least 5 elements in the array. The sensor returns the following data in response to a measurement trigger: Dest(1): ux, x-axis wind speed in meters per secondDest(2): uy, y-axis wind speed in meters per secondDest(3): uz, z-axis wind speed in meters per secondDest(4): Ts, sonic temperature in degrees CDest(5): Diagnostic word (refer to the CSAT3B manual for a table of diagnostic word flags)

            Bus (Constant): Determines whether communication with the CSAT3B is via the SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. or CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. bus. Enter 0 for SDM or 1 for CPI.

            Address (Constant): Identifies the unique address of the CSAT3B on the communication bus. For SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific., valid addresses are 1 through 14. For CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices., valid addresses are 1 through 120.

            Mode (Constant): Defines the trigger source and application of filters to the anemometer data. NOTE: With  the SDM Bus, only Mode 0 is supported. All other options require the CPI bus.
      Must be one of following options: 0 (Datalogger triggered/no filter/datalogger prompted output), 5 (Self triggered/5 Hz bandwidth filter/datalogger prompted output), 10 (Self triggered/10 Hz bandwidth filter/datalogger prompted output), 25 (Self triggered/25 Hz bandwidth filter/datalogger prompted output)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CSAT3B({Dest},{Bus},{Address},{Mode})"


def CSAT3BMonitor(Dest: Variable, Bus: Constant, Address: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3bmonitor.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/csat3bmonitor.htm).

        The CSAT3BMonitor instruction retrieves the internal temperature and relative humidity of the electronics enclosure, and also the inclination of the anemometer. This instruction should be placed within a SlowSequence in the datalogger program.

    Args:
            Dest (Variable): A variable array that stores the values returned by the anemometer. It must be declared as a float with at least 4 elements in the array. The sensor returns the following data in response to this instruction: Dest(1): Electronics temperature in degrees CDest(2): Electronics RH as a percentDest(3): Inclinometer pitch in degreesDest(4): Inclinometer roll in degrees

    Bus (Constant): Determines whether communication with the CSAT3B is via the SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. or CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices. bus. Enter 0 for SDM or 1 for CPI.

    Address (Constant): Identifies the unique address of the CSAT3B on the communication bus. For SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific., valid addresses are 1 through 14. For CPI CPI is a proprietary interface for communications between Campbell Scientific dataloggers and Campbell Scientific CDM peripheral devices. It consists of a physical layer definition and a data protocol. CDM devices are similar to Campbell Scientific SDM devices in concept, but the use of the CPI bus enables higher data-throughput rates and use of longer cables. CDM devices require more power to operate in general than do SDM devices., valid addresses are 1 through 120.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CSAT3BMonitor({Dest},{Bus},{Address})"


def CS616(
    Dest: Variable | Array,
    Reps: Constant,
    CS616Chan: Constant,
    CS616Port: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    MeasPerPort: Variable | Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cs616.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cs616.htm).

                This instruction outputs a period measurement in microseconds.
    Note that channel assignments for this instruction must fall within the guidelines for universal terminal pairs.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the CS616 instruction Dest must be dimensioned to at least the number of Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CS616 instruction, if Reps is greater than 1, Dest must be an array dimensioned to the size of Reps.

            CS616Chan (Constant): The number of the single-ended  terminal on which to make the first measurement. If the Reps parameter is greater than 1, the additional measurements will be made on sequential terminals.

            CS616Port (Constant): The control port that will be used to enable the CS616 sensor(s). If Reps is greater than 1, this is the first port that should be used by the instruction. Right-click the parameter to display a list of the control ports. If Reps is greater than 1, this is the first port that should be used by the instruction. This is the control port used to enable the CS616 sensor.
      Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

            MeasPerPort (Variable | Constant): The number of control terminals to be used to control the CS616 sensor(s). If Reps is set to 4: MeasPerPort = 4 will result in the same terminal being used for all measurements.MeasPerPort = 1 will result in four sequential ports being used for the measurements.MeasPerPort = 2 will result in one port being used for the first two measurements, and the next port being used for the next two measurements.

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CS616({Dest},{Reps},{CS616Chan},{CS616Port},{MeasPerPort},{Mult},{Offset})"


def CS7500(
    Dest: Literal["0", "2", "3", "4", "5", "6"],
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    CS7500Cmd: Literal["0", "1", "2", "3", "4", "5", "6"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cs7500.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cs7500.htm).

              The CS7500 instruction is used to communicate with the LI-7500(A) via SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific..

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the CS7500 instruction, the Dest parameter is the input variable name in which to store the data from each gas analyzer associated with this instruction. The length of the input variable array will depend on the number of repetitions and on the selected command.
    Must be one of following options: 0 (2), 2 (4), 3 (3), 4 (11), 5 (3), 6 (4)

          Reps (Constant): The number of repetitions for the measurement or instruction. For the CS7500 instruction, the Reps parameter determines the number of gas analyzers with which to communicate using this instruction. The devices must have sequential SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses if the Reps parameter is greater than 1.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          CS7500Cmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): Requests the data to retrieve from the sensor. The command is sent first to the device specified by the SDMAddress parameter. If the Reps parameter is greater than 1, subsequent devices will be issued the command with each rep. The results for the command will be returned in the array specified by the Dest parameter. A numeric code is entered to request the data. Right click the parameter to display a drop-down list box.
    Must be one of following options: 0 (Get CO2 & H2O molar density (mmol/m^3).), 1 (Get CO2 & H2O absorptance.), 2 (Get pressure (kPa), temperature (C), auxiliary measurement 1, and cooler voltage (V).), 3 (Get cell diagnostic value, output bandwidth (Hz), and programmed delay.), 4 (Get CO2 molar density (mmol/m^3), H2O molar density (mmol/m^3), CO2 absorptance, H2O absorptance, pressure (kPa), temperature (C), auxiliary measurement 1, cooler voltage (V), diagnostic value, output bandwidth (Hz), and programmed delay.), 5 (Get CO2 & H2O molar density (mmol/m^3) and pressure (kPa).), 6 (Get CO2 and H2O molar density (mmol/m^3), pressure (kPa), and diagnostic.)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CS7500({Dest},{Reps},{SDMAddress},{CS7500Cmd})"


def CheckPort(Port: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"]) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/checkport.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/checkport.htm).

              CheckPort returns True (-1) if the specified digital channel is high or False (0) if the digital channel is low. CheckPort can be used on the right side of an expression (e.g., Variable = CheckPort (Port)) or as an expression. CheckPort has only one parameter:

    Args:
                  Port (Constant): The number of the port to use in this instruction. An alphanumeric code is entered. Right-click to display a list. Caution: The value returned may not be valid if using the control port as a serial port or as a pulse counting port.
    Must be one of following options: C1 (Control terminal 1), C2 (Control terminal 2), C3 (Control terminal 3), C4 (Control  terminal 4), C5 (Control terminal 5), C6 (Control terminal 6), C7 (Control  terminal 7), C8 (Control  terminal 8)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"CheckPort({Port})"


def ClockSet(
    SourceArray: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/clockset.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/clockset.htm).

    A typical use of the ClockSet instruction is when the datalogger can input the time from a more accurate clock than its own (for example, a GPS receiver). The input time would periodically or conditionally be converted into the required variable array and ClockSet would be used to set the datalogger clock.

    Args:
        SourceArray (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Source Array that holds the time values. The Source must be a seven element array in which the year, month, day, hours, minutes, seconds, and microseconds should be contained. Array(1) through Array(7) should hold the year, month, day, hours, minutes, seconds, and microseconds, respectively.

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"ClockSet({SourceArray})"


def Covariance(
    DimX: Constant,
    XVal: Array,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
    NumOfCov: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/covariance.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/covariance.htm).

              The Covariance of X and Y is calculated as:

    Args:
                  DimX (Constant): The number of elements in the source array for which covariance relationships will be calculated.

          XVal (Array): The first element of the source array to be included in the covariance calculations. The X source must be an array that is dimensioned to at least the value of DIMX. Right-click the parameter to display a list of defined variables.

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

          DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep. This follows the use of the input source such that Disable(i) would apply to Cov(Xi,Xj) for every j.

          NumOfCov (Constant): The number of Covariances to be computed. The maximum number is (DimX/2)*(DimX+1). If The Covariance instruction is Covariance(3,X(1),FP2,False,6) then there will be 6 covariance relationships calculated and sent to the output table: Cov(X(1),X(1)), Cov(X(1),X(2)), Cov(X(1),X(3)), Cov(X(2),X(2)), Cov(X(2),X(3)), Cov(X(3),X(3))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Covariance({DimX},{XVal},{DataType},{DisableVar},{NumOfCov})"


def CovSpa(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumOfCov: Constant,
    SizeOfSets: Constant,
    CoreSets: Array,
    DataSets: Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/covspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/covspa.htm).

                This instruction allows the user to perform spatial covariances on multiple sets of data against one core set of data. An individual covariance comparison is performed for each of the multiple sets against the base set.
    Both Source and Dest must be a Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. data type (for example, Strings A data type used when declaring a variable consisting of alphanumeric characters. or Longs Data type used when declaring a variable as an integer. will not work).

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable in which to store the results of the instruction. The array must be dimensioned to at least the value of NumOfCov.

            NumOfCov (Constant): The number of Covariances to be calculated. If four data sets are to be compared against a fifth set, this argument would be set to four.

            SizeOfSets (Constant): The size of the data sets that are to be compared.

            CoreSets (Array): The array element that holds the core data set's first value. This core data set will be compared to each of the other sets of data independently for calculating the covariances.

            DataSets (Array): The array element that contains the first set's first data point that will be compared to the CoreSet for calculating the covariances. If multiple covariances are to be performed, the data sets have to be loaded consecutively into one array. This argument must be dimensioned to at least the value of NumOfCov multiplied by SizeOfSets. For example, if each set of data has 100 elements (SizeOfSets) and there are 4 sets of data (NumOfCov) that are to be compared against the CoreSet, then the DataSets array would need to be dimensioned to 400 (4 X 100) and the DataSets argument would be set to DataSets(1). If the CovSpa instruction is SpaCov(Dest(1),4,100,Core(1),DataSets(1)) then there will be four covariance relationship values calculated and sent to the Dest array. Dest will need to be dimensioned as a one dimensional, four element array.  NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CovSpa({Dest},{NumOfCov},{SizeOfSets},{CoreSets},{DataSets})"


def CardOut(StopRing: Constant, Size: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cardout.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cardout.htm).

                A CardOut instruction must be entered within each DataTable declaration for which data should be written to a memory card. The data table is saved to both the datalogger’s internal memory and the card. The internal memory is used as a buffer to transfer data to the card. When there is enough data to warrant a write to the card the data is flushed to the card. This results in duplicate data, up to the internal table size, that will exist on the internal memory and the card files.
    The data is written to the card in a binary format (TOB3) with a name consisting of the datalogger's Station Name (if one is assigned), the DataTable name, and a .DAT extension (stationname.tablename.dat). The file will be dated based on the time the program was compiled in the datalogger. If the TOB3 file is copied directly from the card to a PC, the binary data must be converted to a human-readable format using CardConvert software (included in LoggerNet, PC400, PC200W, and other software). However, if the data table is collected from the card using LoggerNet or data collection software it can be stored in TOA5 or other ASCII formats.
    The file created on the card becomes an extension of the table memory. Any time the table data is retrieved via LoggerNet data collection or by using the TableFile instruction, the internal SRAM is searched first, then the card. If a file is found on the card with the same name, the data will be appended to that file if the file header is identical. The fields included in this header check are model type, serial number, station name, program name, and all table field information. Thus, to be identical the file must have been created on the same datalogger using the same program, with no changes to the table. If it is not identical, the datalogger will generate a compile error and no data will be stored to the card. To resume data storage to the card, delete the old files or edit the program to rename the new ones. The datalogger can be set to delete card files automatically if the header is not identical by setting the datalogger Setting DeleteCardFilesonMismatch to true (SetSetting (“DeleteCardFilesonMismatch”, -1). However, this option should be set with caution to avoid deleting important data unintentionally.

    Args:
                    StopRing (Constant): Specify whether the DataTable created should be a Ring Mode table (0) or a Fill and Stop table (1). In Ring Mode, once the number of records reaches the specified size, new records are stored over the oldest records. For Fill and Stop, when the table is full no more data is stored.

            Size (Constant): Defines the number of records (or rows) that should be allocated for the DataTable. The number of values (or columns) in the DataTable is determined by the output processing instructions contained in the DataTable declaration. Size can be defined as a fixed number of records or as auto-allocate. To set the table size to a fixed number of records, enter that value. To set the size to autoallocate, enter a -1. If a table is set to auto-allocate, all memory that remains after creating fixed-sized tables will be allocated to this table. If multiple DataTables are declared with a -1 for size, the available memory will be divided among the tables. The datalogger attempts to allocate memory to the tables so that all tables are filled at the same time. By default, data storage memory sectors are organized as ring memory. When the ring is full, oldest data are overwritten by newest data. Using the FillStop statement sets a program to stop writing to the data table when it is full, and no more data are stored until the table is reset. For the CardOut instruction, enter -1000 to set the size of the data table on the card to the size of the data table in datalogger memory. NOTE: For extended-memory dataloggers, auto-allocated data tables are automatically written to the extended internal memory (which is 72 MB), unless CardOut() or Tablefile() is used.  In the case of CardOut() or Tablefile(), data from the CPU is streamed to the card in 1 KB frames and the internal extended memory is not used.  Therefore, on extended-memory dataloggers, table fill times for auto-allocated tables on the CPU are greater if  CardOut() or Tablefile() is not used.  However, note that total final data storage for the table is greatly extended with external memory (up to 2 GB per table). In order to tell if the datalogger has extended internal memory, view the datalogger CPU  Bytes Free in File Control. Dataloggers with extended internal memory show 30 MB Bytes Free for an empty CPU, compared to 1 MB Bytes Free for dataloggers that do not have extended internal memory. NOTE: If CardOut is set to Fill and Stop, when data storage stops in the card it will also stop in the data table, regardless of whether the data table in the datalogger is configured as fill and stop or has reached its maximum number of records. Similarly, if a data table is set to Fill and Stop, when data storage stops in the table it will also stop in the card.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CardOut({StopRing},{Size})"


def CTYPE(
    Expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Type: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ctype.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ctype.htm).

        This function returns the Expression as the data type specified by the Type parameter.

    Args:
            Expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Expression parameter is the value or string that should be cast into the specified data type.

    Type (Variable | Constant | Expression | Array | Integer | ConstantInteger): Valid data types for the Type parameter are Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. (or IEEE4 Four-byte, floating-point data type. IEEE Standard 754. Same format as Float.), Long Data type used when declaring a variable as an integer., String A data type used when declaring a variable consisting of alphanumeric characters., or Double.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CTYPE({Expression},{Type})"


def CWB100(CWBPort: Constant, CWSDest: Variable, CWSConfig: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb1002.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb1002.htm).

                Each time the CWB100 instruction is executed, the wireless sensor base polls the network of wireless sensors for data. The fastest polling rate that can be achieved in a wireless sensor network is determined by the number of sensors in the network, along with the number of hops to each sensor (a hop is a sensor's link through a routing sensor back to the wireless base). At least 15 seconds is required to poll each sensor and retrieve its data. Each hop adds 15 seconds. Thus, the rate at which the CWB100 instruction is executed should be no faster than 15 seconds per sensor, per hop. If the polling rate of the sensor network is too fast, sensor values will alternate between NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. and a good value with each scan.
    In addition to polling for data, the wireless base will report back to the datalogger any new sensors that are discovered in the network. Newly added sensors may take 10 minutes or longer to be discovered. This auto-discovery of sensors allows new sensors to be added to the network without reprogramming the datalogger. The programmer just needs to consider future requirements for sensors and ensure the CWSDest array is dimensioned large enough to accommodate any new sensors added.
    Note that the CWB100 instruction is a processing instruction, not a measurement instruction. Thus, the data from this instruction can lag behind other measurements (since measurements take priority over processing in the datalogger). If the wireless sensor data you are storing to a table needs to be synchronized with other measured sensors, the CWB100 instruction and the CallTable can be placed within an IfTime statement. The program should be run in PipelineMode and the BufferSize in the Scan instruction set large enough to hold the measurement data being stored while the CWB100 instruction is being executed.

    Args:
                    CWBPort (Constant): The CWBPort parameter is used to specify the terminal pair on the datalogger to which the wireless sensor base’s Data/A terminal will be connected. Valid options are C1, C3, U1, U3, U5, U7, U9, or U11. Right-click the parameter to display a drop-down list of valid options.

            CWSDest (Variable): A variable array that will hold the sensor values returned by the base. CWSDest should be dimensioned large enough to accommodate all sensor values that will be returned. If CWSDest is not dimensioned large enough to hold all values from a sensor, then no values will be reflected for that sensor and it will appear as if the sensor has not been discovered (i.e., the last few elements of the array will remain at the name of the CWSDestArray rather than changing to reflect the name of the new sensor). If the base is not properly connected to the datalogger as specified by the CWB100 instruction, a -1 will be returned in the first element of this array and the remaining elements will be NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.. If a device other than the CWB100 is connected to the control port, a -2 will be returned. If the signature of the field names held by the CWB100 does not match that held by the datalogger, a -3 will be returned (though this error will be corrected on the next scan). All sensors return at least 4 values: at least one measurement value and three status values (internal temperature Ti, battery voltage BV, and RF signal strength SS). Signal strength will remain NAN until the CWB100RSSI instruction is executed. Refer to the wireless sensor manual for complete information on what values are returned by each sensor.

            CWSConfig (Constant): The use of the CWSConfig parameter is optional and can be left blank. This parameter is a string or the path to a file that contains the sensor name and variable names that the datalogger will use for each sensor. The string or file also determines the order in which each sensor's data will be stored in the datalogger. CWSConfig string – The configuration string contains a sensor ID and sensor name for each sensor, the number of values to include for each sensor, and the fieldnames (in the order they are returned by the sensor) to be used by the datalogger (i.e., Public variables). Each part of the string for a sensor is separated by a space. As an example, a string for one sensor would contain: SensorID SensorName NumberOfValues Field1Name Field2Name Field3Name Strings for multiple sensors are separated by a comma. If a sensor returns 10 values, but 4 is specified for the NumberOfValues, then only 4 values will be stored by the datalogger for that sensor. CWSConfig filename – Rather than entering a string for the CWSConfig parameter, a filename can be entered. It is specified as Device:CWSConfig.txt, where Device is CPU, CRD, USB, or USR. If the Network Planner or Wireless Sensor Planner is used to configure the wireless sensors, this file will be created when the "Send a config string to the datalogger" task is chosen (or it can be created manually by the user). Any sensors in the network not contained in the CWSConfig string will assume their default names when discovered in the network.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CWB100({CWBPort},{CWSDest},{CWSConfig})"


def CWB100Diagnostics(CWBPort: Constant, CWSDiag: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100diagnostics.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100diagnostics.htm).

        This instruction, when executed, returns the results from the last poll of the sensor network (it does not initiate a new poll).

    Args:
            CWBPort (Constant): The CWBPort parameter is used to specify the terminal pair on the datalogger to which the wireless sensor base’s Data/A terminal will be connected. Valid options are C1, C3, U1, U3, U5, U7, U9, or U11. Right-click the parameter to display a drop-down list of valid options.

    CWSDiag (Variable): A variable array that holds the results of the instruction. Results are formatted as Longs.  Array(1): Number of sensors discovered by the base.  Array(2): Number of sensors polled by the base. Array(3): Number of retries the base has performed when polling the sensors. Array(4): Time to poll all the sensors, in seconds. Array(5): Network health value. This is a number from 0 to 100, and is the ratio of the actual polled time to the best case poll time for the network, scaled to the difference between the worst and best case times. The value assumes a best case time of 5 seconds per sensor per hop. The maximum number of retries during an attempt is four. Thus, as an example of a network that has 10 single-hop nodes, 5 two-hop nodes, and 4 three-hop nodes, the best case is: (10*5) + (5 * 10) + (4 * 15) = 160 seconds And worst case is: (10*20) + (5*40) + (4*60) = 640 seconds If the network is polled in 160 seconds or less, the network health would be 100; if it is polled in 640 seconds or more, the network health would be 0. Times falling between these two values would be scaled accordingly.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"CWB100Diagnostics({CWBPort},{CWSDiag})"


def CWB100RSSI(CWBPort: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100rssi2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100rssi2.htm).

    When the CWB100RSSI instruction is executed, a separate RF transmission goes out to the wireless sensors in the network. The RSSI values are returned during the next measurement cycle along with the other measurements. RSSI values range from 0 (worst) to 32 (best). The RSSI values for each sensor in the network will be NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. if the CWB100RSSI instruction has not been executed. If a sensor communicates with the base through other sensors (hops), the signal strength returned is from the sensor to its closest hop.

    Args:
        CWBPort (Constant): The CWBPort parameter is used to specify the terminal pair on the datalogger to which the wireless sensor base’s Data/A terminal will be connected. Valid options are C1, C3, U1, U3, U5, U7, U9, or U11. Right-click the parameter to display a drop-down list of valid options.

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"CWB100RSSI({CWBPort})"


def CWB100Routes(
    CWBPort: Constant,
    CWSRoutes: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100routes2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/cwb100routes2.htm).

                This instruction returns the name and any hops to the base for each wireless sensor in the network (a hop is a sensor's link through a routing sensor back to the wireless base) and the time required (in seconds) for the last poll for each sensor. The format of the returned string is:
    Radio ID SensorName Hop1 Hop2 Hop3 Time
    If a sensor transmits directly to the base with no hops, only the RadioID, SensorName, and time will be returned. The information for each sensor is terminated by a carriage return/line feed.
    This instruction does not trigger any additional communication to the sensors in the wireless sensor network, and thus, does not affect power consumption of the sensors.

    Args:
                    CWBPort (Constant): The CWBPort parameter is used to specify the terminal pair on the datalogger to which the wireless sensor base’s Data/A terminal will be connected. Valid options are C1, C3, U1, U3, U5, U7, U9, or U11. Right-click the parameter to display a drop-down list of valid options.

            CWSRoutes (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable, defined as a string, that holds the results of the CWB100Routes instruction. If this parameter is an array, each route will be returned into a separate element of that array.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CWB100Routes({CWBPort},{CWSRoutes})"


def DataGram(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    BaudRate: Constant,
    PakBusAddr: Integer,
    DestAppID: Integer,
    SrcAppID: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datagram.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datagram.htm).

                The DataGram instruction enables the datalogger to act as a PakBus serial server, routing non-PakBus messages in a PakBus Network over a specified port using the PakBus Datagram Protocol. The PakBus Datagram Protocol extends PakBus communication for general application use, including sending commands to mixed array dataloggers or Modbus Communication protocol published by Modicon in 1979 for use in programmable logic controllers (PLCs). devices.
    In networks using the DataGram instruction to communicate with a non-PakBus datalogger, extra response time may be needed in the software setup to allow for the time needed to transfer packets.

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. For the DataGram instruction, a variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP Transmission Control Protocol / Internet Protocol., enter the variable for the socket returned by TCPOpen.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            DestAppID (Integer): An application ID number that the user assigns to the destination device. The number can be any value from 0 to 65535. NOTE: Application IDs 0 through 999 are reserved for common applications (for instance, 502 is reserved for Modbus Communication protocol published by Modicon in 1979 for use in programmable logic controllers (PLCs). protocol). Therefore, a user application ID should be in the range of 1000 to 65535.

            SrcAppID (Integer): An application ID number that the user assigns to the source device, which will be used to identify the application in the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. network. The number can be any value from 0 to 65535. NOTE: Application IDs 0 through 999 are reserved for common applications (for instance, 502 is reserved for Modbus Communication protocol published by Modicon in 1979 for use in programmable logic controllers (PLCs). protocol). Therefore, a user application ID should be in the range of 1000 to 65535.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DataGram({ComPort},{BaudRate},{PakBusAddr},{DestAppID},{SrcAppID})"


def DaylightSavingUS(
    DSTSet: Constant,
    DSTnStart: Literal["1", "2", "3", "4", "5"],
    DSTDayStart: Literal["1", "2", "3", "4", "5", "6", "7"],
    DSTMonthStart: Literal[
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
    ],
    DSTnEnd: Literal["1", "2", "3", "4", "5"],
    DSTDayEnd: Literal["1", "2", "3", "4", "5", "6", "7"],
    DSTMonthEnd: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    DSTHour: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "22",
        "23",
        "24",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/daylightsavingdaylightsavingus.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/daylightsavingdaylightsavingus.htm).

                These two functions return 3600 when the datalogger crosses over into the daylight saving time window recognized by the region; otherwise, the functions return 0. The parameters for the DaylightSaving function are used to specify the daylight saving period. The DaylightSavingUS function assumes the period as recognized in the U.S. (and takes into account the changes made for 2007). These functions will also adjust the UTC Offset setting in the datalogger, if it is being used.
    These functions adjust the clock only when the datalogger crosses the daylight saving time boundary. Downloading a program with this instruction to a datalogger running on standard time when it should be running on daylight saving time will not change the datalogger time.

    Args:
                    DSTSet (Constant): Used to specify whether or not the datalogger should automatically adjust its clock for daylight savings time. Enter -1 to adjust the clock automatically; otherwise, enter 0.

            DSTnStart (Constant): Specifies the occurrence of the day (DSTDayStart) that daylight saving begins. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (First), 2 (Second), 3 (Third), 4 (Fourth), 5 (Last)

            DSTDayStart (Constant): Specifies the day of the week on which daylight saving begins. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (Sunday), 2 (Monday), 3 (Tuesday), 4 (Wednesday), 5 (Thursday), 6 (Friday), 7 (Saturday)

            DSTMonthStart (Constant): Specifies the month on which daylight saving begins. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (January), 2 (February), 3 (March), 4 (April), 5 (May), 6 (June), 7 (July), 8 (August), 9 (September), 10 (October), 11 (November), 12 (December)

            DSTnEnd (Constant): Specifies the occurrence of the day that daylight saving ends. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (First), 2 (Second), 3 (Third), 4 (Fourth), 5 (Last)

            DSTDayEnd (Constant): Specifies the day of the week on which daylight saving ends. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (Sunday), 2 (Monday), 3 (Tuesday), 4 (Wednesday), 5 (Thursday), 6 (Friday), 7 (Saturday)

            DSTMonthEnd (Constant): Specifies the month on which daylight saving ends. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (January), 2 (February), 3 (March), 4 (April), 5 (May), 6 (June), 7 (July), 8 (August), 9 (September), 10 (October), 11 (November), 12 (December)

            DSTHour (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the hour at which daylight saving begins/ends. Right-click the parameter to display a list of options:
      Must be one of following options: 0 (midnight,
     beginning of day), 1 (1 AM), 2 (2 AM), 3 (3 AM), 4 (4 AM), 5 (5 AM), 6 (6 AM), 7 (7 AM), 8 (8 AM), 9 (9 AM), 10 (10 AM), 11 (11 AM), 12 (12 AM), 13 (1 PM), 14 (2 PM), 15 (3 PM), 16 (4 PM), 17 (5 PM), 18 (6 PM), 19 (7 PM), 20 (8 PM), 21 (9 PM), 22 (10 PM), 23 (11 PM), 24 (midnight, end of day)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DaylightSavingUS({DSTSet},{DSTnStart},{DSTDayStart},{DSTMonthStart},{DSTnEnd},{DSTDayEnd},{DSTMonthEnd},{DSTHour})"


def DaylightSaving(
    DSTSet: Constant,
    DSTnStart: Literal["1", "2", "3", "4", "5"],
    DSTDayStart: Literal["1", "2", "3", "4", "5", "6", "7"],
    DSTMonthStart: Literal[
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
    ],
    DSTnEnd: Literal["1", "2", "3", "4", "5"],
    DSTDayEnd: Literal["1", "2", "3", "4", "5", "6", "7"],
    DSTMonthEnd: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    DSTHour: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "22",
        "23",
        "24",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/daylightsavingdaylightsavingus.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/daylightsavingdaylightsavingus.htm).

                These two functions return 3600 when the datalogger crosses over into the daylight saving time window recognized by the region; otherwise, the functions return 0. The parameters for the DaylightSaving function are used to specify the daylight saving period. The DaylightSavingUS function assumes the period as recognized in the U.S. (and takes into account the changes made for 2007). These functions will also adjust the UTC Offset setting in the datalogger, if it is being used.
    These functions adjust the clock only when the datalogger crosses the daylight saving time boundary. Downloading a program with this instruction to a datalogger running on standard time when it should be running on daylight saving time will not change the datalogger time.

    Args:
                    DSTSet (Constant): Used to specify whether or not the datalogger should automatically adjust its clock for daylight savings time. Enter -1 to adjust the clock automatically; otherwise, enter 0.

            DSTnStart (Constant): Specifies the occurrence of the day (DSTDayStart) that daylight saving begins. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (First), 2 (Second), 3 (Third), 4 (Fourth), 5 (Last)

            DSTDayStart (Constant): Specifies the day of the week on which daylight saving begins. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (Sunday), 2 (Monday), 3 (Tuesday), 4 (Wednesday), 5 (Thursday), 6 (Friday), 7 (Saturday)

            DSTMonthStart (Constant): Specifies the month on which daylight saving begins. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (January), 2 (February), 3 (March), 4 (April), 5 (May), 6 (June), 7 (July), 8 (August), 9 (September), 10 (October), 11 (November), 12 (December)

            DSTnEnd (Constant): Specifies the occurrence of the day that daylight saving ends. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (First), 2 (Second), 3 (Third), 4 (Fourth), 5 (Last)

            DSTDayEnd (Constant): Specifies the day of the week on which daylight saving ends. Right-click the parameter to display a list of options:
      Must be one of following options: 1 (Sunday), 2 (Monday), 3 (Tuesday), 4 (Wednesday), 5 (Thursday), 6 (Friday), 7 (Saturday)

            DSTMonthEnd (Constant): Specifies the month on which daylight saving ends. Right-click the parameter to display a list of options.
      Must be one of following options: 1 (January), 2 (February), 3 (March), 4 (April), 5 (May), 6 (June), 7 (July), 8 (August), 9 (September), 10 (October), 11 (November), 12 (December)

            DSTHour (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the hour at which daylight saving begins/ends. Right-click the parameter to display a list of options:
      Must be one of following options: 0 (midnight,
     beginning of day), 1 (1 AM), 2 (2 AM), 3 (3 AM), 4 (4 AM), 5 (5 AM), 6 (6 AM), 7 (7 AM), 8 (8 AM), 9 (9 AM), 10 (10 AM), 11 (11 AM), 12 (12 AM), 13 (1 PM), 14 (2 PM), 15 (3 PM), 16 (4 PM), 17 (5 PM), 18 (6 PM), 19 (7 PM), 20 (8 PM), 21 (9 PM), 22 (10 PM), 23 (11 PM), 24 (midnight, end of day)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DaylightSaving({DSTSet},{DSTnStart},{DSTDayStart},{DSTMonthStart},{DSTnEnd},{DSTDayEnd},{DSTMonthEnd},{DSTHour})"


def DataTime(DataTimeOpt: Literal["0", "1"]) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datatime.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datatime.htm).

              By default, timestamps are recorded in data tables with the datalogger's system time at the top of the scan. However, for some applications it may be desired to record timestamps at the time of storing data, rather than at the top of the scan. The DataTime instruction is used in a data table to specify whether timestamps are recorded with the datalogger's system time at the top of the scan, or with the datalogger's system time at the time of storing data.

    Args:
                  DataTimeOpt (Constant): Use the drop-down list in the CRBasic Editor to select one of two option codes: If DataTime is not used in a data table, the records are timestamped with the time at the top of the scan.  The use of DataTime does not affect the DataInterval. It still triggers based on the time at the top of the scan.
    Must be one of following options: 0 (Scan time: Timestamps records in the table with the datalogger's system time at the top of the scan.), 1 (System time: Timestamps records in the table with the datalogger's system time at the time of storing the data.)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"DataTime({DataTimeOpt})"


def DataEvent(
    RecBefore: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    StartTrig: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    EndTrig: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RecAfter: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dataevent.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dataevent.htm).

                When the DataEvent instruction is in a program, the datalogger sets up a buffer the size of the RecBefore parameter times the number of data values to be output. Any statistical outputs in the data table (for example, average, maximum, or total), will include values from this buffer. If data is stored to a data table from multiple data events, a filemark is stored in the data table between each data storage event.
    NOTE: Conditionally called data tables generally hold fewer records than time-interval driven data tables. Therefore, to avoid wasting data-storage memory, best practice is to use a fixed number of records for the size parameter of conditional tables, rather than using auto-allocate. If auto-allocate is used for the size of a conditional table, memory allocation will assume that the condition is always met, and a larger portion of memory will be allocated for the conditional table than is necessary.
    If Tablefile with option 64 is used with DataEvent, then 3 times the Tablefile Interval (or Numrecs) of memory is pre-allocated for the Tablefile.
    NOTE: Data Event with Tablefile option 64 is fully implemented in CR1000X OS4 and greater.
    Other options of Tablefile do not pre-allocate memory.  Rather, a Tablefile is created at the baling interval (time or number of records).
    NOTE: For non-option 64 Tablefiles, the processing time required for writing new files increases as the number of files increases due to file system overhead when creating a new file. In other words, it takes a long time for the datalogger file system to read through numerous files and determine how much room is left for new files. Hence, best practice is to limit the number of tablefiles stored to 1000 or less.
    NOTE: To reduce processing time, the DataInterval instruction, with at least 1 lapse, should always precede the DataEvent instruction.
    CardOut is an alternative to Tablefile.

    Args:
                    RecBefore (Variable | Constant | Expression | Array | Integer | ConstantInteger): The RecBefore parameter is used to define the number of records to be stored in the DataTable prior to when the data storage event was triggered.  Type -- Constant

            StartTrig (Variable | Constant | Expression | Array | Integer | ConstantInteger): The StartTrig is a constant A non-varying fixed number., variable, or expression to be evaluated for starting the data storage event. Data storage begins when this expression evaluates as True or not equal to 0. StartTrig can be any legal expression, such as TBlk1(2) > 72. In this case, when the variable TBlk1(2) contains a value greater than 72 the StartTrig argument is true and the data storage event starts. Type -- Constant, Variable, or Expression

            EndTrig (Variable | Constant | Expression | Array | Integer | ConstantInteger): The EndTrig is the variable, expression, or constant to be evaluated for stopping the data storage event. If a non-zero constant is entered, the number of records stored equals RecBefore + 1 + RecAfter. If 0 is entered, once the data storage event begins it is never stopped. Type -- Constant, Variable, or Expression

            RecAfter (Variable | Constant | Expression | Array | Integer | ConstantInteger): The RecAfter parameter is used to define the number of records to be stored in the DataTable after the data storage event is stopped. If the RecAfter parameter is negated (for example, -N where N is the number of records), then a new event occurring during the RecAfter interval will stop the RecAfter count and begin a new DataEvent. Type – Constant

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DataEvent({RecBefore},{StartTrig},{EndTrig},{RecAfter})"


def DataInterval(
    TintoInt: Variable | Constant,
    Interval: Constant,
    Units: Literal["msec", "sec", "min", "hr", "day", "mon"],
    Lapses: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datainterval.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/datainterval.htm).

                The DataInterval statement is inserted into a DataTable declaration following the DataTable instruction to establish a fixed interval on which the DataTable is run. This fixed interval defined by TintoInt (time into interval) and Interval is independent of, but must coincide with, the program execution interval. That is, the data interval must be integrally divisible by the program scan interval. The only exception to this rule is when DataInterval is used in a table that is the destination of a GetDataRecord instruction. Beginning with OS 2, the data interval for a GetDataRecord destination table is not required to be integrally divisible by the program scan interval.  This results in correct timestamps in the case that a remote datalogger is storing data faster than the local program with GetDataRecord() maxrecords > 1.
    When DataInterval is included in a data table, the datalogger will use only values from within the defined interval for time series processing. If an output interval is skipped (for example, the table was not called for any reason) processing memory that holds the intermediate values is reset the next time the data table is called. Thus, data from the previous interval is discarded. OpenInterval can be included in the data table declaration to keep the data from the old interval in memory, and use it in calculating the time series data on the next interval. Note, however, that this means the data used for time series processing could span multiple output intervals.
    Note that even if the DataInterval to store data to the DataTable is met, the Trigger Variable defined in the DataTable instruction must also be true or data storage will not occur.
    The DataInterval instruction is optional. If it is not used, data is stored each time the CallTable is executed and a time stamp is stored with each record. Using a DataInterval is an efficient means of data storage, because a time stamp is not stored with each record. The datalogger still stores time but on a fixed interval (about once per 1K of memory used for the table). As each new record is stored, time is checked to ensure that the interval is correct. The time stamp for the data is calculated when data is retrieved from the datalogger, based on the number of records in the table and the last successful data storage event.
    If the Interval parameter is set to 0, the data storage interval is the scan interval of the scan (main scan or slow sequence) from which the table is called. If a scan contains multiple calls to a table (for instance, within a For/Next loop) only one record is stored since the next scan interval has not occurred.
    NOTE: DataInterval is typically not used for tables that are called conditionally (and in some instances may result in statistical data loss if included). The data storage efficiencies that would normally be gained are lost due to timestamp tracking markers. In this instance, it is more efficient for the datalogger to store a timestamp with each record.Be careful to ensure that the interval defined by TintoInt and Interval occurs when a program scan occurs or no data will be stored.

    Args:
                    TintoInt (Variable | Constant): Allows an offset to the specified Interval. The Units for time are the same as for the Interval. This parameter must be an integer. Use of non-integers may result in the interval not evaluating as True when expected. In the DataInterval instruction, this parameter must be a constant (a variable is not allowed). If a variable is used in this parameter, it is recommended to define it as a Long. TintoInt parameter example usage: if the Interval is set at 60 minutes, and TintoInt is set to 5, then data storage will occur at 5 minutes into the hour, every hour, based on the datalogger's real-time clock. If the TintoInt is set to 0, data storage will occur at the top of the hour.

            Interval (Constant): The Interval is how frequently data will be stored to the DataTable, based on the datalogger's real-time clock. Enter the time interval on which the data in the table is to be recorded. The interval may be in milliseconds, seconds, or minutes, whichever is selected with the Units parameter. Enter 0 to make the data interval the same as the scan interval. DataInterval does not override the trigger in the DataTable instruction. If the trigger is not always true, it is a condition that must be met in addition to the time interval prior to data being stored.

            Units (Constant): The units for the interval parameter. Right-click the parameter to display a list. For the DataInterval instruction, the Units argument is used to specify the units on which the TintoInt and Interval arguments are based. When month (mon) is used for the Units parameter, the Interval parameter is specified in months and the TimeIntoInt parameter is specified as seconds into the month. The Interval is synchronized to the beginning of the year (January). If the current month of the year modulo the Interval equals 1 and the seconds into the current month matches the TimeIntoInt, then the condition is true. If TimeIntoInt is negative, then the True condition is in the current month.
      Must be one of following options: msec (milliseconds), sec (seconds), min (minutes), hr (hours), day (days), mon (month (seconds into the month))

            Lapses (Variable | Constant | Expression | Array | Integer | ConstantInteger): A Lapse is any discontinuity of records in a DataTable. As each record is stored in a DataTable, the time is compared to the last record stored to ensure that a data storage interval has not been missed (that is, that a Lapse has not occurred). If a Lapse has occurred, a time stamp is stored along with the data. The Lapse argument allocates the additional memory in the data table for tracking these lapses and storing the timestamp (for more information, see Lapses). Entering a zero will cause every record in the DataTable to be time stamped, which requires an additional 16 bytes per record. If a negative value is entered, the datalogger will not adjust the timestamps of records due to lapses. Note that if several data storage intervals are missed in sequence, only one lapse is recorded for the missed records.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DataInterval({TintoInt},{Interval},{Units},{Lapses})"


def Delay(
    Option: Literal["0", "1", "2"],
    Delay: Constant,
    Units: Literal["0", "1", "2", "3", "4", "5"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/delay3.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/delay3.htm).

                The Delay instruction is used to delay the measurement task sequence or the processing instructions for the time period specified by the Delay and Units arguments, before progressing to the next measurement or processing instruction.
    The Scan Interval should be sufficiently long to process all measurements plus the delay period. If the delay is applied to the measurement task sequence and the scan interval is not long enough to process all measurements plus the delay, the program will not compile when sent to the datalogger. If the delay is applied to the processing task sequence, the program will compile but scans will be skipped.

    Args:
                    Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): When a program is compiled in Pipelinemode, the Option parameter determines whether the delay should apply to the measurement task sequence or the processing instructions. In Sequentialmode, instructions are executed sequentially as they occur in the program, regardless of Option. Right-click the parameter to display a list of options.
      Must be one of following options: 0 (Delay will affect the measurement task sequence. Processing will continue to take place as needed in the background. When this option is chosen, the Delay instruction must not be placed in a conditional statement.), 1 (Delay will affect processing. Measurements will continue as called for by the task sequencer.), 2 (Delay will affect digital measurements. This option is used to insert a delay between successive accesses to an SDM device.)

            Delay (Constant): The time to delay the program at the designated place (10 microsecond resolution). The time units are selected by the Units argument.

            Units (Constant): For the Delay instruction, the Units parameter is the time units for the delay. A numeric  code is entered. Right-click the parameter to display a list.
      Must be one of following options: 0 (usec), 1 (msec), 2 (sec), 3 (min), 4 (hr), 5 (day)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Delay({Option},{Delay},{Units})"


def DewPoint(Dest: Variable | Array, Temp: Variable, RH: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dewpoint.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dewpoint.htm).

                The dew point temperature is found from the vapor pressure, relative humidity, and the saturation vapor pressure. The saturation vapor pressure is found from the dry bulb temperature, and the vapor pressure from saturation vapor pressure and relative humidity.
    The dew point is found from Tetens' equation solved for dew point with coefficients optimized for the temperature range of -35 to +50 degrees C. .
    Td = dew point temperature
    The result is in degrees C. Error rate with this formula is less than 0.1 degrees C.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Temp (Variable): The variable in the program that contains the measurement, in degrees C, for temperature.

            RH (Variable): The variable in the program that contains the measurement for relative humidity. For the DewPoint instruction, the RH parameter must be in percent. For additional information, see Estimation of Dew Point.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DewPoint({Dest},{Temp},{RH})"


def DialModem(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    BaudRate: Constant,
    DialString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ResponseString: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dialmodem.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dialmodem.htm).

                The DialModem function performs a SerialOpen, multiple SerialOuts, and a SerialClose. This function returns a -1 if the ResponseString is successfully received or a 0 will be returned if it isn't.
    DialModem can be used within the DialSequence/EndDialSequence commands to specify a communication route to be used for a PakBus device, or it can be used within the BeginProg/EndProg statements to send the dial string any time the instruction is executed. When used within the DialSequence/EndDialSequence commands, use this function as the expression that will be used for the DialSuccess parameter in EndDialSequence. The variable will be monitored by the EndDialSequence instruction. If the call is unsuccessful, the link will be closed.
    NOTE: This instruction runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode.

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list.

            DialString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The telephone number and any other codes used to dial the modem. A semi-colon is used to separate multiple commands. Two semi-colons in a row will insert a 1 second delay before continuing to the next characters in the string. A comma inserts a 2 second delay before continuing to the next character.

            ResponseString (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to specify the response code expected back from the modem when a connection is made. An entry for this parameter is required. When using the COM220 modem, enter a null string (""). The COM220 can return one of eight responses, depending upon the baud rate at which the connection is made. When a null string is entered, the datalogger will compare the modem's response with these eight known responses in an attempt to establish communication.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DialModem({ComPort},{BaudRate},{DialString},{ResponseString})"


def DNP(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    BaudRate: Constant,
    Confirmation: Variable | Constant,
    TimeOffset: Variable | Constant,
    MaxTimeDiff: Variable | Constant,
    DNPTLS: Variable | Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnp.htm).

              This instruction sets up a datalogger COM port to service DNP commands.

    Args:
                  ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. DNP PakBus datagram routing - DNP datagram allows remote DNP outstation devices to talk with a DNP Master without being directly connected to the Master. In order to implement DNP datagram, the ComPort parameter on a router datalogger is preceded with a minus sign (for example, -ComRS232) and the comport parameter on the remote datalogger is set to 0. You must use a different COM port for DNP3 and PakBus communications. The PakBus address of the DNP slave must match the DNP address of the slave. DNP over TCP - Setting the ComPort parameter to a number >= 100 specifies a TCP port number and will enable listening on this TCP port for a socket connection instead of using one of the physical ComPorts. The default port number for DNP over TCP is 20000. The port number must match the port number specified in the DNP master for the master to make a connection with the datalogger.
    Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

          BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list.

          Confirmation (Variable | Constant): A parameter that is used to determine whether DNP3 data link layer confirmation is enabled or disabled, and to set the timeout interval for data link layer and application layer confirmation. In general, the use of data link layer confirmation is not recommended. Data link layer confirmation is always disabled for a TCP/IP link. The datalogger will always use application layer confirmation when transmitting event data or multi-fragment responses. The parameter is entered in the form of XSSS. X = 0 enables data link layer confirmation. X = 1 disables data link layer confirmation. SSS is the number of seconds the datalogger should wait for a response to data link layer confirmation and/or application layer confirmation before timing out. A timeout > 0 should always be entered. Examples:  1010: Disable link layer confirmation and set the application layer confirmation timeout to 10 seconds.0006: Enable data link layer confirmation and set data link layer confirmation and application layer confirmation timeout to 6 seconds. When using ComRS232, the datalogger usually goes into sleep mode after 40 seconds of inactivity on the communications port. After going to sleep with some interface methods it sometimes takes a packet of incoming data to wake it up and then a retry packet to get the message through. If packets continue arriving before the 40 second timeout, the datalogger should respond very quickly to the new packets.

          TimeOffset (Variable | Constant): The local time offset, in seconds, from UTC. If the datalogger setting "UTC Offset" is a value other than -1 (disabled), this offset will be ignored and the UTC Offset value will be used. This parameter can be used to keep the datalogger clock set to local time when the DNP3 master is sending time synchronization commands to the datalogger, which are in UTC.

          MaxTimeDiff (Variable | Constant): The maximum difference in time (ms) between the datalogger clock and the DNP3 Distributed Network Protocol is a set of communications protocols used between components in process automation systems. Its main use is in utilities such as electric and water companies. master clock that will be tolerated before the clock is changed upon command from the DNP3 master. If a 0 is entered, the datalogger clock will be set upon receipt of a time synchronization command from the DNP3 master. If a -1 is entered, the datalogger clock will not be set. If the datalogger is connected to a DNP3 master and a Loggernet server, a -1 can be entered in order to avoid problems that can arise from a DNP3 master and Loggernet server both setting the datalogger clock.

          DNPTLS (Variable | Constant): The DNPTLS parameter is an optional parameter used to enable TLS. If the parameter is set to 0 or is omitted, TLS is disabled. If the parameter is set to 1, TLS is enabled. Note that the CR800 Series, CR1000 and CR3000 do not support TLS.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return (
        f"DNP({ComPort},{BaudRate},{Confirmation},{TimeOffset},{MaxTimeDiff},{DNPTLS})"
    )


def DNPUpdate(
    DNPSlaveAddr: Variable | Constant,
    DNPMasterAddr: Variable | Constant,
    Timeout: Constant,
    Retries: Constant,
    ConnectHandle: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnpupdate.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnpupdate.htm).

                This instruction must execute in order for the DNP outstation to update its arrays. It is typically placed in a program after the elements in the array are updated. If this instruction is not included in a program, the DNP array will never be updated with new values. The datalogger can support communication for up to three masters. If communications are required for multiple masters, a DNPUpdate instruction must be included in the datalogger program for each one.
    When a DNP master comes in with a request, the amount of time to process the scan running DNPUpdate can increase. If DNPUpdate is in the main scan, increasing the number of scan buffers can help to avoid skipped scans.

    Args:
                    DNPSlaveAddr (Variable | Constant): Assigns an address to the DNP outstation. The valid address range is 1 - 65520.

            DNPMasterAddr (Variable | Constant): Assigns the address of the DNP master / client to which the datalogger will respond. Valid address range is 1 - 65520. The datalogger will respond to any DNP master regardless of its address. Up to 3 masters are supported. Optional Parameters Unsolicited response transmission can be enabled in the datalogger. This allows the datalogger to transmit changes or events without having received a specific request for the data. This mode is useful if the master station requires notification as soon as possible after a change occurs, rather than waiting for the master station to poll the outstation. If the unsolicited response parameters are not present or if the unsolicited response confirmation timeout is 0, then unsolicited responses are disabled.

            Timeout (Constant): The time, in seconds, that the datalogger will wait for confirmation that an unsolicited response was received, before attempting the transmission again. If this value is set to 0, unsolicited responses are disabled.

            Retries (Constant): The number of times the datalogger will attempt a transmission if the initial attempt fails. If this parameter is 0, then unsolicited responses (with data) will retry forever or until confirmed by the master.

            ConnectHandle (Variable): A variable that is controlled by the TCPOpen instruction that connects the master station as if the datalogger received an incoming request. This is useful in the case that the outstation needs to make a TCP connection instead of the master station.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return (
        f"DNPUpdate({DNPSlaveAddr},{DNPMasterAddr},{Timeout},{Retries},{ConnectHandle})"
    )


def DNPVariable(
    Source: Variable,
    Swath: Constant,
    DNPObject: Constant,
    DNPVariation: Literal[
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "1",
        "1",
        "2",
        "2",
        "2",
        "10",
        "10",
        "12",
        "20",
        "20",
        "20",
        "20",
        "20",
        "20",
        "20",
        "20",
        "21",
        "21",
        "21",
        "21",
        "21",
        "21",
        "22",
        "22",
        "22",
        "22",
        "30",
        "30",
        "30",
        "30",
        "30",
        "32",
        "32",
        "32",
        "32",
        "32",
        "32",
        "40",
        "40",
        "40",
        "41",
        "41",
        "41",
        "50",
        "60",
        "60",
        "60",
        "110",
    ],
    DNPClass: Constant,
    DNPFlag: Variable | Constant,
    DNPEvent: Variable,
    DNPNumEvents: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnpvariable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/dnpvariable.htm).

              DNPVariable is a DNP outstation instruction and must be used with a DNP and DNPUpdate instruction.

    Args:
                  Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the DNPVariable instruction, the Source parameter is a public variable or variable array that specifies the source of data to populate the DNP outstation array. This variable must be of type Long Data type used when declaring a variable as an integer. for Analog Input or Analog Output Objects, unless the variation specified is single precision floating point (see DNPObject), in which case the variable must be of type Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4.. If the object specified is a Binary Input or Binary Output, then the source variable must be of type Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports..

          Swath (Constant): The number of values of the array over which to perform the specified operation. For the DNPVariable instruction, the Swath parameter is the number of elements that are in the DNP outstation array. This number must be equal to or less than the length of the array the data is mapped from in the Source parameter. An array index can be specified in Swath to write a class to a specific element or series of elements within the array. For example, with an array of 10, such as BinaryInput(10): DNPVariable (BinaryInput(1),5,2,1,1,BinaryInput_Flag(),0,20) 'writes class 1 data to array elements 1-5.DNPVariable (BinaryInput(6),5,2,1,2,BinaryInput_Flag(),0,20) 'writes class 2 data to array elements 6-10.

          DNPObject (Constant): The DNPObject parameter assigns the Source parameter to a specific DNP object type. DNP data is organized into arrays with different Object types. The Objects are divided into groups and each group has variations of that group. All communications are referenced from the DNP master. For example the “Analog Input” object means the Master is requesting data from a datalogger DNP outstation array.

          DNPVariation (Constant): Assigns the Source parameter to a specific variation, which describes the data format within its Object group. Datalogger supported DNP objects and variations: NOTE: Object 0 device attribute variations are read only and cannot be specified in the DNPVariable instruction. Rather, they are sent only when requested by a master device.
    Must be one of following options: 0 (240), 0 (241), 0 (242), 0 (243), 0 (247), 0 (248), 0 (250), 0 (252), 0 (254), 0 (255), 1 (1), 1 (2), 2 (1), 2 (2), 2 (3), 10 (1), 10 (2), 12 (1), 20 (1), 20 (2), 20 (3), 20 (4), 20 (5), 20 (6), 20 (7), 20 (8), 21 (1), 21 (2), 21 (5), 21 (6), 21 (9), 21 (10), 22 (1), 22 (2), 22 (5), 22 (6), 30 (1), 30 (2), 30 (3), 30 (4), 30 (5), 32 (1), 32 (2), 32 (3), 32 (4), 32 (5), 32 (7), 40 (1), 40 (2), 40 (3), 41 (1), 41 (2), 41 (3), 50 (1), 60 (2), 60 (3), 60 (4), 110 (X)

          DNPClass (Constant): Assigns the Object class to the Source parameter. Valid classes are 0 for static data or 1, 2, and 3 for event data.

          DNPFlag (Variable | Constant): A constant, expression, variable, or variable array that indicates the value of the DNP3 data quality flag corresponding to the Source parameter. If a constant is used, then by default, all quality flags will be set to online, regardless of the value entered (for example, 0 or 1 both evaluate to ‘online’). If a variable or variable array is used, the variable must be declared as a data type of Long, and the DNP3 flags will reflect the value of the variable or variable array. The variable or variable array can then be set under program control. A 1 sets a quality flag to online; a 0 sets a flag to offline. If the array for the flag parameter is smaller than the array for the source parameter, then the last element of the flag array is used for all of the remaining source array elements. A single variable (scalar) is treated like an array of one element.

          DNPEvent (Variable): Used to create event data. An expression or variable array may be entered and used to trigger the creation of change events. If a variable or variable array is used, it must be of type Long. If the array is smaller than the source array, the last element of the array is used for all the remaining array elements. A single variable (scalar) is treated like an array of one element. Any time the event trigger variable evaluates as true, a change event will be created for the Source parameter.  This allows the user to define the conditions that create change events. The default value is zero and indicates that a change event will be created whenever there is any change to the value of the Source parameter.

          DNPNumEvents (Constant): The number of events that will be saved in the history before events are successfully received at the master; that is, the size of the history. For event objects, this number must be greater than 0.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"DNPVariable({Source},{Swath},{DNPObject},{DNPVariation},{DNPClass},{DNPFlag},{DNPEvent},{DNPNumEvents})"


def EC100(
    Destination: Literal["0", "1", "2"],
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    EC100Cmd: Literal["0", "1", "2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ec100.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ec100.htm).

    Args:
                  Destination (Array): The input variable name in which to store the data from the EC150 or EC155. The length of the input variable array will depend on the selected command. A value of -99999 will be loaded into Dest(1) if a signature error on SDM data occurs.
    Must be one of following options: 0 (8), 1 (12), 2 (13)

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          EC100Cmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): Requests the data to be retrieved from the sensor. The results for the command will be returned in the array specified by the Dest parameter. A numeric code is entered to request the data: *An EC150 outputs CO2 density (mg/m^3) and H2O density (g/m^3). An EC155 outputs CO2 molar mixing ratio (umol/mol) and H2O molar mixing ratio (mmol/mol). Molar mixing ratio is the concentration relative to dry air. **If EC100 OS version 7.01 or later is loaded and an open-path gas analyzer (i.e., EC150 or IRGASON) is connected to the EC100, the 13th data field will be CO2 density (mg/m^3) calculated from fast-response temperature. Specifically, this additional CO2 density output uses humidity-corrected sonic temperature, instead of ambient temperature measured by the EC100 temperature probe, in the conversion of absorption measurements to CO2 density. Using the sonic anemometer’s fast-response temperature measurements compensates for spectroscopic effects during high sensible heat flux regimes as explained in Helbig et al. (2016). For open-path gas analyzers connected to an EC100 running an OS version less than 7.01, the 13th data field is unused. Reference: Helbig, M., Wischnewski, K., Gosselin, G.H., Biraud, S.C., Bogoev, I., Chan, W.S., Euskirchen, E.S., Glenn, A.J., Marsh, P.M., Quinton, W.L., and Sonnentag, O.: 2016, “Addressing a Systematic Bias in Carbon Dioxide Flux Measurements with the EC150 and the IRGASON Open-Path Gas Analyzers”, Agricultural and Forest Meteorol., 228-229 (2016), 349-359.
    Must be one of following options: 0 (Ux (m/s), Uy (m/s), Uz (m/s), Ts (C), sonic diagnostic (arb), CO2*, H2O*, gas diagnostic (arb)), 1 (Ux (m/s), Uy (m/s), Uz (m/s), Ts (C), sonic diagnostic (arb), CO2*, H2O*, gas diagnostic (arb), ambient temperature (C), ambient pressure (kPa), CO2 signal strength (arb), H2O signal strength (arb)), 2 (Ux (m/s), Uy (m/s), Uz (m/s), Ts (C), sonic diagnostic (arb), CO2*, H2O*, gas diagnostic (arb), cell temperature (C), cell pressure (kPa), CO2 signal strength (arb), H2O signal strength (arb), sample cell pressure differential (kPa).** (Available only from EC155))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"EC100({Destination},{SDMAddress},{EC100Cmd})"


def EC100Configure(
    EC100Result: Variable,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    EC100ConfigCmd: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "99",
    ],
    DestSource: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ec100configure.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ec100configure.htm).

                This instruction is a processing instruction. Whether running in pipeline mode or sequential mode the datalogger will execute the instruction from processing. This functionality allows the instruction to be placed in conditional statements. Running from processing also introduces ramifications when attempting to execute the EC100Configure instruction while other SDM instructions are executing in pipeline mode. This instruction locks the SDM port during the duration of its execution. If the pipelined SDM task sequencer needs to run while the SDM is locked it will be held off until the instruction completes. This locking will likely result in skipped scans when reconfiguring an EC150 or EC155.
    For the EC150 or EC155 to save settings, it must go through a lengthy write/read/verify process. To avoid saving the settings after each set command, the result code can be used to determine if any settings were modified from their original value. When a change is detected the save settings command (command code 99) can then be sent to the EC150 or EC155. The DestSource parameter variable should be set to 2718 to save settings. The reception of this command is acknowledged but since it takes up to a second to complete, a successful return code does not mean that all of the data was successfully written to the appropriate non-volatile memory.
    The EC150 or EC155 can also be configured outside of the datalogger program using Device Configuration Utility or ECMon.

    Args:
                    EC100Result (Variable): A variable that contains a value indicating the success or failure of the command. A result code of 0 means that the command was successfully executed. If reading a setting, 0 in the result code means that the value in the DestSource variable is the value the desired setting has in the EC150 or EC155. When writing a setting if the result code is 0 the value and setting were compatible, but the value was not changed because it contained the same value that was sent. A return code of 1 from the set operation means that the value was valid, different, set and acknowledged. This allows CRBasic code to control whether or not to save the settings. NAN indicates that the setting was not changed or acknowledged or a signature failure occurred.

            SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

            EC100ConfigCmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable that indicates whether to get or set a setting. The options are: Span/Zero Control – To perform zeroing of CO2 and H2O the Span/Zero Control setting is written to 1. After the EC150 or EC155 completes the zero, it will write the setting to -1. The datalogger can poll this value or simply wait for a period of time to allow the zeroing to complete. To perform CO2 span, the CO2 Span Concentration setting (ConfigCmd 12) must be written to the proper value in PPM CO2 prior to writing the Span/Zero Control setting (ConfigCmd 11) to 2. After the CO2 span is complete, the value for the Span/Zero Control setting will be written to -2. H2O span is similar to CO2. First the H2O Span Dew Point value (ConfigCmd 13) must be written to the desired value, then the Span/Zero Control setting is set to 3. After the EC150 or EC155 completes the H2O Span, the Span/Zero Control setting is written to -3. *ConfigCmd 218 – Normally, EC100Configure is run in the datalogger's processing task. Skipped scans can occur when the EC100Configure instruction executes. When changing operational parameters, these skipped scans are acceptable. However, it may not be acceptable when changing the heater voltage. ConfigCmd 218 allows the EC100Configure instruction to operate in the SDM task, thus avoiding skipped scans. When using ConfigCmd 218, the command must be a constant and the instruction cannot be placed in a conditional statement.
      Must be one of following options: 0 (100), 1 (101), 2 (102), 3 (103), 4 (104), 5 (105), 6 (106), 7 (107), 8 (108), 9 (109), 10 (110), 11 (111), 12 (112), 13 (113), 14 (114), 15 (115), 16 (116), 17 (117), 18 (118), 19 (119), 20 (120), 21 (121), 99 (N/A)

            DestSource (Variable): A variable that will contain the value to read when getting a setting, or that will contain the value to send when writing a setting to the EC150 or EC155.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"EC100Configure({EC100Result},{SDMAddress},{EC100ConfigCmd},{DestSource})"


def EncryptExempt(
    BeginPakBusAddr: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
    EndPakBusAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/encryptexempt.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/encryptexempt.htm).

                The datalogger can be configured to send all PakBus communication encrypted using the 128-bit Advanced Encryption Standard (AES-128). If there are PakBus devices the datalogger needs to communicate with that do not support PakBus encryption (such as a CR200 or an AVW200), encryption can be disabled for those devices.This is accomplished by setting a range of PakBus addresses that are exempt from PakBus encryption using this instruction.
    The BeginPakBusAddr and EndPakBusAddr parameters are used to define the range. More than one EncryptExempt instruction can be used to define multiple ranges of PakBus addresses.
    'Do not use encryption when communicating with PakBus addresses 15, 16, 17, 18, 19, 20, and 25

    Args:
                    BeginPakBusAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): BeginPakBusAddr (No description provided)

            EndPakBusAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): EndPakBusAddr (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"EncryptExempt({BeginPakBusAddr},{EndPakBusAddr})"


def EmailSend(
    Result: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ServerAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ToAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FromAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Subject: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Message: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Attach: Variable,
    UserName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Password: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ServerResponse: Variable,
    NumRecsTimeIntoInterval: Constant,
    Interval: Literal["0", ">=0", ">0", "<0", "0"],
    Units: Constant,
    FileOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
    ],
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailsend.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailsend.htm).

                The EmailSend function returns -1 if successful, 0 if the email transmission fails, or -2 if execution did not occur when the instruction was called. The email can be sent to one or more recipients and it can include attachments. The ServerResponse variable can be used to monitor the status of the email transmission.
    If a response back from the email server is not received after 75 seconds from sending the email (or sending the last attachment of the email), the instruction will time out. The datalogger waits for the instruction to return a result; thus, it can hold up the scan. However, it can be placed in a slow sequence scan. In a slow sequence, it will run in the background and will not hold up the main program waiting for the transaction to be completed.
    The type of email authorization to be used can be specified by appending a type to the user name. Authorizations supported are CRAM-MD5, PLAIN, STARTTLS, and LOGIN. The syntax is username, followed by a semi-colon, followed by authorization type; for example, MyUserName;PLAIN
    The last several parameters are optional. They can be used to send data from a data table directly to a server, without the datalogger first having to write the data to a file.
    An IPTrace code of 4 in the datalogger's settings table can be used to analyze messages during an email send or receive to troubleshoot errors.

    Args:
                    Result (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Result variable indicates if execution succeeded (-1) or failed (0), or if execution did not occur when called (-2). If using optional parameters to stream data from a data table/field, result is set to -2 if the instruction is called but does not execute because the number of records or time into interval conditions are not met.

            ServerAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the IP address (for example, “100.10.200.20”) or fully-qualified domain name (for example, “smtp.server.com”) of the mail server to be used for message delivery. If a different port number is required, follow the server address with a colon and the desired port number (for example, “smtp.server.com:587”).The IP address for a  DNS must be set in the datalogger (using Device Configuration Utility) to use a qualified domain name. For the EmailSend instruction, the default port number used is 25.

            ToAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the recipient email address. Multiple recipients are specified as a comma separated list of addresses; for example “jack@email.com,jill@email.com”.

            FromAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing an email address identifying the author.

            Subject (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the text used in the Subject field of the message.

            Message (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the text used in the body of the email or text message. For messages being sent, variables can be included in the message using CRBasic's standard string syntax (for example, "The temperature is " + TempVar + " degrees C").

            Attach (Variable): A string expression containing a local file name, comma separated list of local file names, data table name, or data table field name. Local files are generally created by TableFile or a Campbell Scientific camera. Multiple local file names can be specified as a comma separated list (for example, “USR:file1.dat,USR:image.jpg”). Make sure to include the file directory along with the file name. The directories in the datalogger are CPU (datalogger CPU), CRD (memory card), USR (user-defined drive), and USB (SC115). If streaming data directly from a data table or table field to an email attachment, this parameter should be a constant specifying the table name (for example, “TableOne”) or table field name (for example, “TableOne.BattV_Min”) that is used as the data source. Or, to stream all data tables, specify the optional data table parameters required for streaming and specify the data source as an empty string (“"). If an attachment is not required, specify this parameter as an empty string (“”) and do not specify the optional data table parameters.

            UserName (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression specifying the account username required to access to the mail server. For the EmailSend instruction, the UserName parameter is a string expression specifying the account username required to access to the SMTP server. The type of email authorization to use can be specified by appending the specification type to the user name. Options are CRAM-MD5, PLAIN, STARTTLS, and LOGIN; for example, MyUserName;STARTTLS

            Password (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression specifying the account password required to access the mail server.

            ServerResponse (Variable): A variable formatted as String that will be populated with mail server response messages during email transmission. Look at the content of this variable when monitoring the email send process or diagnosing problems.

            NumRecs/TimeIntoInterval (Constant): Used only when streaming data directly from a data table or data table field. NOTE: For more details, see the Data Streaming document.  If Interval is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unsent records should be written to file on the server.  If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be written to file on the server. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will be written to file on the server each time the function is called.

            Interval (Constant): Used only when streaming data directly from a data table or data table field. If greater than 0, the Interval parameter determines the interval at which previously unsent data will be written to file. If equal to zero, the NumRecs parameter will control when data is written. A negative Interval will cause the datalogger to write the most recent records within this time interval each time the function is called.
      Must be one of following options: 0 (0), >=0 (>0), >0 (0), <0 (0), 0 (<0)

            Units (Constant): Used only when streaming data directly from a data table or data table field. It is used to specify the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days.

            FileOption (Constant): Used only when streaming data directly from a data table or data table field. It specifies the format of the file sent in the email. The file  will automatically be appended with an incrementing file number and a “.dat” file extension. If 1000 is added to the format (for example, 1008), the datalogger will not automatically append the incrementing number or “.dat” extension to the  file. Options 0, 8, 16, and 32 correspond to Campbell Scientific's defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds). WARNING: The datalogger must be assigned an IP address or be set up for DHCP (datalogger IP address of 0.0.0.0). If a fixed IP address is assigned to the datalogger, a subnet mask and IP gateway address must also be defined. A DNS address must be set if you want to use a qualified domain name instead of the IP address of the mail server. These settings, which are obtained from your network administrator, are set in the datalogger using Device Configuration Utility.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"EmailSend({Result},{ServerAddr},{ToAddr},{FromAddr},{Subject},{Message},{Attach},{UserName},{Password},{ServerResponse},{NumRecsTimeIntoInterval},{Interval},{Units},{FileOption},{TimeOut})"


def EmailRelay(
    Result: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ToAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Subject: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Message: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ServerResponse: Variable,
    Attach: Variable,
    NumRecsTimeIntoInterval: Constant,
    Interval: Literal["0", ">=0", ">0", "<0", "0"],
    Units: Constant,
    FileOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
    ],
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailrelay.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailrelay.htm).

                The EmailRelay function returns -1 if the relay server has received and sent the message, 0 if the connection to the server fails, -2 if execution of the function did not occur (for instance if the time or number of records interval are not met), or -3 if a connection was made but the relay server returns an error.
    The email can be sent to one or more recipients and it can include attachments. The ServerResponse variable can be used to monitor the status of the email transmission. Note that with all communication functions, the transmission time will vary as a function of network bandwidth as well as datalogger type.
    NOTE:  When multiple IP interfaces (for example, Ethernet port, CS I/O port, Wi-Fi, PPP) are active, the IPRoute() instruction is used to direct outgoing IP traffic.
    If a connection to the email relay server is not made after 75 seconds, the instruction will time out. The optional TimeOut parameter can be used to change the default 75 second timeout. The datalogger waits for the instruction to return a result; thus, it can hold up the scan. However, the instruction can be placed in a slow sequence scan. In a slow sequence, EmailRelay will run in the background and will not hold up the main program waiting for the transaction to be completed. The ServerResponse variable can be used to monitor the status of email transmission.
    The last several parameters are optional. The optional parameters can be used to send data from a data table directly to a server, without the datalogger first having to write the data to a file.
    An IPTrace Function associated with IP data transmissions. IP trace information was originally accessed through the CRBasic instruction IPTrace() and stored in a string variable. Files Manager setting is now modified to allow for creation of a file on a datalogger memory drive, such as USR:, to store information in ring memory. code of 4800 in the datalogger's settings table can be used to analyze messages during an email send or receive to troubleshoot errors.

    Args:
                    Result (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Result variable indicates if execution succeeded (-1), failed (0), did not occur when called (-2), or the server response contains an error message (-3). If using optional parameters to stream data from a data table/field, result is set to -2 if the instruction is called but does not execute because the number of records or time into interval conditions are not met.

            ToAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the recipient email address. Multiple recipients are specified as a comma separated list of addresses; for example “jack@email.com,jill@email.com”.

            Subject (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the text used in the Subject field of the message.

            Message (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the text used in the body of the email or text message. For messages being sent, variables can be included in the message using CRBasic's standard string syntax (for example, "The temperature is " + TempVar + " degrees C").

            ServerResponse (Variable): A variable formatted as String that will be populated with mail server response messages during email transmission. Look at the content of this variable when monitoring the email send process or diagnosing problems.

            Attach (Variable): A string expression containing a local file name, comma separated list of local file names, data table name, or data table field name. Local files are generally created by TableFile or a Campbell Scientific camera. Multiple local file names can be specified as a comma separated list (for example, “USR:file1.dat,USR:image.jpg”). Make sure to include the file directory along with the file name. The directories in the datalogger are CPU (datalogger CPU), CRD (memory card), USR (user-defined drive), and USB (SC115). If streaming data directly from a data table or table field to an email attachment, this parameter should be a constant specifying the table name (for example, “TableOne”) or table field name (for example, “TableOne.BattV_Min”) that is used as the data source. Or, to stream all data tables, specify the optional data table parameters required for streaming and specify the data source as an empty string (“"). If an attachment is not required, specify this parameter as an empty string (“”) and do not specify the optional data table parameters.

            NumRecs/TimeIntoInterval (Constant): Used only when streaming data directly from a data table or data table field. NOTE: For more details, see the Data Streaming document.  If Interval is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unsent records should be written to file on the server.  If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be written to file on the server. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will be written to file on the server each time the function is called.

            Interval (Constant): Used only when streaming data directly from a data table or data table field. If greater than 0, the Interval parameter determines the interval at which previously unsent data will be written to file. If equal to zero, the NumRecs parameter will control when data is written. A negative Interval will cause the datalogger to write the most recent records within this time interval each time the function is called.
      Must be one of following options: 0 (0), >=0 (>0), >0 (0), <0 (0), 0 (<0)

            Units (Constant): Used only when streaming data directly from a data table or data table field. It is used to specify the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days.

            FileOption (Constant): Used only when streaming data directly from a data table or data table field. It specifies the format of the file sent in the email. The file  will automatically be appended with an incrementing file number and a “.dat” file extension. If 1000 is added to the format (for example, 1008), the datalogger will not automatically append the incrementing number or “.dat” extension to the  file. Options 0, 8, 16, and 32 correspond to Campbell Scientific's defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON)

            TimeOut (Constant): An optional parameter that specifies how long the datalogger will wait (specified in 0.01 seconds) before considering the attempt to connect to the server failed and returning the appropriate result code. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds). To specify a custom timeout without using the other optional parameters (that is, if not streaming data), use commas as placeholders for the unused parameters. For example,  EmailRelay (“ToAddr, "Subject", "Message", "Attach", Result,,,,,,500). In this example, 6 commas precede 500, which sets the timeout to 5 seconds. WARNING: The datalogger must have a working Ethernet, Wi-Fi, or PPP/cellular interface for email functions to work. A CR1000X datalogger is capable of email functionality, such as EmailRelay and EmailRecv, when it is capable of accessing a compatible email server via an internal or external Ethernet interface. When using an external serial device to access the email server, the external device must serve as a PPP host. The datalogger must obtain or be assigned a valid IP address, subnet mask, IP gateway, and in nearly all cases a DNS address. In order to resolve a qualified domain name, access to a domain name server is required.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"EmailRelay({Result},{ToAddr},{Subject},{Message},{ServerResponse},{Attach},{NumRecsTimeIntoInterval},{Interval},{Units},{FileOption},{TimeOut})"


def EMailRecv(
    ServerAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ToAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FromAddr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Subject: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Message: Variable,
    Authen: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    UserName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Password: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Result: Variable,
    RecvFrom: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RecvSubj: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RecvDate: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailrecv.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/emailrecv.htm).

                The EMailRecv function uses POP3 to query a mail server for messages. One or more filters can be set to limit the email messages the datalogger will retrieve. The function returns True (-1) if the mailbox was accessed successfully, otherwise it returns False (0). If the datalogger successfully retrieves a message from the mailbox, the message is deleted from the email server. The email to be retrieved must be formatted in plain text (not HTML).
    The datalogger waits for the instruction to return a result; thus, it can hold up the scan. However, it can be placed in a slow sequence scan. In a slow sequence, it will run in the background and will not hold up the main program waiting for the transaction to be completed.
    Each time the POP3 server is queried, the Message string is replaced with either a new message or a null string. Therefore, you will most likely want to save the message to a data table after it is retrieved because it will be overwritten by the next query (see the example program).
    Some email servers require the use of TLS Transport Layer Security. An Internet communication security protocol. protocol. When an EmailSend or EmailRecv instruction is in a program, TLS is automatically set to true.
    An IPTrace Function associated with IP data transmissions. IP trace information was originally accessed through the CRBasic instruction IPTrace() and stored in a string variable. Files Manager setting is now modified to allow for creation of a file on a datalogger memory drive, such as USR:, to store information in ring memory. code of 4 in the datalogger's settings table can be used to analyze messages during an email send or receive to troubleshoot errors.

    Args:
                    ServerAddr (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the IP address (for example, “100.10.200.20”) or fully-qualified domain name (for example, “smtp.server.com”) of the mail server to be used for message delivery. If a different port number is required, follow the server address with a colon and the desired port number (for example, “smtp.server.com:587”).The IP address for a  DNS must be set in the datalogger (using Device Configuration Utility) to use a qualified domain name. For the EmailRcv instruction, the default port number used is 110.

            "ToAddr" (Variable | Constant | Expression | Array | Integer | ConstantInteger): A filter string that can be used to control the emails the datalogger will retrieve. The string must be enclosed in quotes. Only emails with a To address that match the string are retrieved; all other messages are ignored. If a null string is entered for this parameter, "" , the filter is not used.

            "FromAddr" (Variable | Constant | Expression | Array | Integer | ConstantInteger): A filter string that can be used to control the emails the datalogger will retrieve. The string must be enclosed in quotes. Only emails with a From address that match the string are retrieved; all other messages are ignored. If a null string is entered for this parameter, "" , the filter is not used.

            "Subject" (Variable | Constant | Expression | Array | Integer | ConstantInteger): A filter string that can be used to control the emails the datalogger will retrieve. The string must be enclosed in quotes. Only emails with a Subject line that match that string are retrieved; all other messages are ignored. If a null string is entered for this parameter, "" , the filter is not used.

            Message (Variable): A variable formatted as a string into which the incoming message will be written. The variable must be sized large enough to accommodate the incoming message

            "Authen" (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string specifying the type of authentication to be used when logging in to the email server. The datalogger supports APOP, Plain, and TLS Transport Layer Security. An Internet communication security protocol. authentication. APOP is recommended if it is supported by the mail server. APOP uses the MD5 16 byte checksum of the TCP/IP VTP configuration. hash function to encrypt the user name and password. Gmail requires TLS.

            UserName (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression specifying the account username required to access to the mail server.

            Password (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression specifying the account password required to access the mail server.

            Result (Variable): A variable formatted as a string that holds messages returned by the mail server as a result of the email transmission. If the result is "+OK" then the email server accepted the command. If the result is "-ERR" or "Error" followed by an explanation then some error has occurred.  Optional Parameters

            RecvFrom (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that holds the email header's From information.

            RecvSubj (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that holds the email header's subject information.

            RecvDate (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that holds the email header's date information, in the format ddd, MM/DD/YYYY HH:MM:SS GMT.  Where: ddd = three-letter abbreviation for the day of week (for example, Mon)MM/DD/YYYY = Month, day, year (for example, 12/31/2010)HH:MM:SS = Hour, minutes, seconds (for example, 12:00:00)GMT = the offset from GMT (for example, -0600)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds). NOTE: The datalogger must have a working Ethernet, Wi-Fi, or PPP/cellular interface for email functions to work. CR1000X dataloggers are capable of email functionality, such as EmailSend and EmailRecv, when they are capable of accessing a compatible email server via an internal or external Ethernet interface. When using an external serial device to access the email server, the external device must serve as a PPP host. The datalogger must obtain or be assigned a valid IP address, subnet mask, IP gateway, and in nearly all cases a DNS address. In order to resolve a qualified domain name, access to a domain name server is required.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"EMailRecv({ServerAddr},{ToAddr},{FromAddr},{Subject},{Message},{Authen},{UserName},{Password},{Result},{RecvFrom},{RecvSubj},{RecvDate},{TimeOut})"


def Encryption(
    Dest: Variable | Array,
    EncryptSrc: Variable | Array,
    SrcLen: Variable,
    EncryptKey: Constant,
    EncryptInit: Variable,
    EncryptInitLen: Integer,
    EncryptOption: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/encryption1.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/encryption1.htm).

                The Encryption function uses the Advanced Encryption Standard (AES) 128 as established by the U.S. National Institute of Standards and Technology. AES uses a symmetric key algorithm; thus, the encryption key used for both encrypting and decrypting the contents of a variable must be the same.
    This function returns the number of bytes written to the destination variable. 0 is returned if the function fails or if the destination is not large enough to hold the resulting encrypted or decrypted message.
    Two uses of the the Encryption function are:
    The initialization process sets up a context (CTX) for the encryption/decryption process. Subsequent calls to encryption/decryption reference this CTX. Thus, only one encryption process at a time can be run by the datalogger.

    Args:
                    Dest (Variable | Array): Variable or variable array that holds the output of the encryption or decryption. Note that output to the destination variable can cross array element boundaries. When encrypting, Dest should be declared with a Size greater than the length of EncryptSrc, rounded up to the next multiple of 8 bytes. (For example, if source is 10 bytes, 16 bytes will be placed in destination.)

            EncryptSrc (Variable | Array): The variable or variable array that holds the information to be encrypted or decrypted.

            SrcLen (Variable): Variable that holds the number of bytes from the source to be encrypted or decrypted. A length of 0 indicates that a length of up to and including the first null character should be used.

            EncryptKey (Constant): Contains the encryption key. The string can be up to 63 bytes in length. If this parameter is null (""), the datalogger's PakBus Encryption Key setting will be used. If neither the EncryptKey parameter nor the PakBus Encryption Key setting contains a value and the Encryption function is in the program, a compile error will be returned.

            EncryptInit (Variable): A 16-byte value used as the initialization vector for the encryption or decryption process. At the beginning of encryption/decryption, the initialization vector must be initialized. After that, further calls to the encryption/decryption process will use and modify the initialization as part of the encryption/decryption algorithm.

            EncryptInitLen (Integer): The length of the initialization vector. Valid entry is an integer between 0 and 16. If a non-zero length is used, an MD5 16 byte checksum of the TCP/IP VTP configuration. checksum of the initialization EncryptInit is calculated and used as the initialization vector for the encryption.  If the process being encrypted is large and requires more than one packet to be transferred, length should be set to 0 after the first packet. This causes the EncryptInit parameter to be ignored and the encryption algorithm uses the initialization vector saved internally.

            EncryptOption (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines whether EncryptSrc will be encrypted (EncryptOption=0) or decrypted (EncryptOption=1). Right-click to display a pick list of the two options. NOTE: The FileEncrypt function can be used to encrypt a file stored on the datalogger's file system. FileEncrypt uses a proprietary algorithm and can only be unencrypted by the datalogger. It is typically used to encrypt a program or a portion of a program contained in an Include file that the user would like to hide.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Encryption({Dest},{EncryptSrc},{SrcLen},{EncryptKey},{EncryptInit},{EncryptInitLen},{EncryptOption})"


def Erase(
    EraseVar: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/erase.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/erase.htm).

                The Erase instruction sets all bytes of a variable in memory to 0, from the starting point (specified by EraseVar) to the end of the variable or variable array. It can be used to clear variables of any data type (including strings), and the variable can be a scalar or an array. The exception is that Erase cannot be used on dereferenced pointers.
    The EraseVar parameter is the name of the variable in the program to be cleared. In its simplest form, you can clear all bytes in a variable/variable array, or you can specify a starting point and the variable/array is cleared to the end.
    Erase (MyVar()) will set all bytes to 0 in the entire variable array
    Erase (MyVar(3) will set all bytes to 0 in MyVar(3), MyVar(4), and MyVar(5)

    Args:
                    EraseVar (Variable | Constant | Expression | Array | Integer | ConstantInteger): EraseVar (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Erase({EraseVar})"


def DisplayValue(
    MenuItemName: Variable | Constant, MenuExpression: Variable | Expression
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/displayvalue.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/displayvalue.htm).

                The MenuItemName parameter is the name that will appear on the custom menu. The name should be enclosed in quotation marks. The Expression parameter defines the value from a data table (tablename.fieldname) or variable to be displayed. When displaying a variable from the public table, use the variable name only ("Public" is not needed). Values displayed using DisplayValue cannot be edited.
    NOTE: Use MenuItem to display editable variables in a custom menu.

    Args:
                    MenuItemName (Variable | Constant): The name that will be displayed on the custom menu for a measurement or datatable value. The name is limited to 512 characters, including characters for the associated measurement value. However, its practical size is much less because of the small size of the keyboard display.  MenuItemName should be enclosed in quotation marks.

            MenuExpression (Variable | Expression): Defines the value from a data table (tablename.fieldname) or variable to be displayed, or any valid expression. When displaying a variable, the table name (public) is not included.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DisplayValue({MenuItemName},{MenuExpression})"


def DisplayLine(Value: Variable | Constant | Expression) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/displayline.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/displayline.htm).

                The value to display can be a string, variable, constant, evaluation, or an expression containing a combination of these items. String values must be enclosed in quotes. Use an ampersand, &, to concatenate variables with strings.
    When the custom menu is viewed using a datalogger's keyboard display, only 20 characters of text can be displayed in the viewable menu window. If the DisplayLine exceeds 20 characters, press the right or left arrow key to display up to 7 lines of 20 characters on the screen. If Value includes more than 7 lines of text, use the up and down arrow keys, or page up/page down, to scroll through the remaining text.

    Args:
                    Value (Variable | Constant | Expression): The Read-only text to display in the custom menu. String values must be enclosed in quotes. Use an ampersand, &, to concatenate variables with strings.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"DisplayLine({Value})"


def ExciteV(
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    ExmV: Variable | Constant,
    Delay: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/excitev.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/excitev.htm).

                This instruction is used to set to the voltage excitation level (in millivolts) for a specified voltage excitation channel. The Delay parameter is used to specify the length of time the excitation channel is enabled, after which, the channel is set low and the datalogger moves on to the next instruction. If the Delay is set to 0, the excitation channel will be enabled and the voltage will be held until the end of the program scan, until another instruction sets an excitation voltage, or until the instruction is interrupted by a measurement. When the measurement is finished the excitation channel is returned to the value that was set prior to the measurement. Instructions that will not return the excitation to its former state are: PanelTemp, AM25T (if measuring the temp on the AM25T), Calibrate, Therm107, 108, and 109, and all bridge measurements.
    Note that any time the measurement hardware is accessed when ExciteV is exciting a channel, the excitation will be turned off for the measurement and then turned back on. This includes when the MeasOff parameter of a subsequent voltage measurement instruction is set to True (and thus a measurement is made), or when an ExciteV resides in a slow sequence scan and the main scan makes a measurement. This interruption in ExciteV may adversely affect the sensor measurement. In general, the use of ExciteV in a slow sequence scan should be avoided.

    Args:
                    ExChan (Constant): Specifies the excitation terminal to use to excite the first measurement. If the Reps parameter is greater than 1, the excitation terminal used for subsequent measurements will be incremented with each measurement based on the MeasPEx parameter.  An alphanumeric code is entered. Right-click within the parameter to display a list.
      Must be one of following options: VX1 (Excitation channel 1), VX2 (Excitation channel 2), VX3 (Excitation channel 3), VX4 (Excitation channel 4)

            ExmV (Variable | Constant): The excitation, in millivolts, to apply to the excitation channel. The allowable range is ±4000 mV.

            Delay (Constant): The amount of time, in microseconds, to delay before moving on to the next instruction. Excitation is turned off after the specified delay. If the Delay is set to 0 (default), the datalogger will apply the desired excitation and immediately move to the next instruction without turning excitation off. The excitation will be held until the end of the program scan or until another instruction sets an excitation.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ExciteV({ExChan},{ExmV},{Delay})"


def Exp(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/exp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/exp.htm).

    If the value of the Number argument exceeds 709.782712893, an overflow error occurs. The constant e is approximately 2.718282.

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Exp({number})"


def EthernetPower(
    State: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ethernetpower.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ethernetpower.htm).

    EthernetPower controls power to all Ethernet networks within the datalogger (Ethernet, WiFi, NL200, NL240, internal cellular modem, etc.). The State variable determines whether the power is on or off. A non-zero value turns the power on; zero turns the power off. By default, Ethernet power is ON unless turned off.

    Args:
        State (Variable | Constant | Expression | Array | Integer | ConstantInteger): State (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"EthernetPower({State})"


def I2COpen(BeginPort: Constant, BitRate: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2copen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2copen.htm).

                I2C uses two bidirectional open-drain lines, the Serial Data Line (SDA) and Serial Clock Line (SCL) pulled up with resistors. By definition, I2C is a Multi-Controller, Multi-Peripheral communication interface; however the datalogger only supports Single-Controller, Muti-Peripheral configurations. The datalogger provides pull-ups to allow communications, but the pull resistors are not strong enough for high speed communications. If higher speeds are required, external pull-up resistors will be necessary. The datalogger does not support “clock stretching”, where the peripheral can slow down the clock by holding the SCL line low. However, the BitRate parameter can be used to slow or speed up the clock.
    NOTE: A prior understanding of the operation and details of the I2C protocol is assumed.
    I2COpen must be declared prior to using I2CRead or I2CWrite.

    Args:
                    BeginPort (Constant): Specifies the beginning port used for the two signals for I2C communications. The first port is the clock signal and the next higher port is used for the data signal. Valid options are C1, C3, C5, and C7.

            BitRate (Constant): The bit rate, in Hertz, to use for communications.  NOTE: The datalogger's 100k ohm pull-up resistors are too weak for communication at the standard clock frequency of 100kHz.  Therefore, to run at faster speeds,  an external pull-up resistor should be added.  The external resistor can either be pulled to the +5V supply on the terminal blocks or it can be pulled high by another control port that is not being used for the I2C function.  The control port (Cx) can be configured to drive at either +5V or +3.3V with the PortPairConfig() instruction.  The external pull-up resistor should be sized appropriately for the speed and capacitance of the cable. Refer to the following graph  to determine the appropriate external pullup resistor size.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"I2COpen({BeginPort},{BitRate})"


def I2CRead(
    BeginPort: Constant,
    Address: Constant,
    Dest: Variable,
    NumBytes: Variable,
    Option: Literal["B0", "B1", "B2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2cread.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2cread.htm).

                I2C uses two bidirectional open-drain lines, the Serial Data Line (SDA) and Serial Clock Line (SCL) pulled up with resistors. The datalogger provides pull-ups to allow communications, but the pull resistors are not strong enough for high speed communications. If higher speeds are required, external pull-up resistors will be required.
    Note that a prior understanding of the operation and details of the I2C protocol is assumed.

    Args:
                    BeginPort (Constant): Specifies the beginning port used for the two signals for I2C communications. The first port is the clock signal and the next higher port is used for the data signal. Valid options are C1, C3, C5, and C7.

            Address (Constant): The address of the I2C peripheral device. The read bit is appended to the address and should not be specified in the address. Note: this is a 7-bit address. To represent the address correctly, rotate the bit pattern to the right by one bit.  for example., an I2C address of &HB8 would be &H5C.

            Dest (Variable): The variable in which to store the data read from the I2C device.

            NumBytes (Variable): The number of bytes to read from/write to the I2C device.

            Option (Constant): A bit field parameter used to specify how the I2C transaction starts and ends.        If Start or Restart are asserted the address will be sent prior to any data. If the stop is not set, it is assumed that another I2C instruction will occur, and the bus is left in control of the controller. When all of the bytes are read and a stop is specified, the controller will send a NACK on the last byte. This is in accordance with the I2C specification and allows slave devices to reset their control state machines to a known state. Examples of the “Option” parameter include: &H02 = Start with no stop at the end&H03 = Start, then Stop at the end&H05 = Restart, then Stop at the end
      Must be one of following options: B0 (Stop. Send a stop condition at the end of the transaction), B1 (Start. Send a start condition at the beginning of the transaction. The address will be sent following the start.), B2 (Restart. Send a restart condition at the beginning of the transaction. The address will be sent following the restart.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"I2CRead({BeginPort},{Address},{Dest},{NumBytes},{Option})"


def I2CWrite(
    BeginPort: Constant,
    Address: Constant,
    Source: Variable,
    NumBytes: Variable,
    Option: Literal["B0", "B1", "B2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2cwrite.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/i2cwrite.htm).

                I2C uses two bidirectional open-drain lines, the Serial Data Line (SDA) and Serial Clock Line (SCL) pulled up with resistors. The datalogger provides pull-ups to allow communications, but the pull resistors are not strong enough for high speed communications. If higher speeds are required, external pull-up resistors will be required.
    Note that a prior understanding of the operation and details of the I2C protocol is assumed.

    Args:
                    BeginPort (Constant): Specifies the beginning port used for the two signals for I2C communications. The first port is the clock signal and the next higher port is used for the data signal. Valid options are C1, C3, C5, and C7.

            Address (Constant): The address of the I2C peripheral device. The read bit is appended to the address and should not be specified in the address. Note: this is a 7-bit address. To represent the address correctly, rotate the bit pattern to the right by one bit.  for example., an I2C address of &HB8 would be &H5C.

            Source (Variable): The  variable in which the data to be written to the I2C device is stored.

            NumBytes (Variable): The number of bytes to read from/write to the I2C device.

            Option (Constant): A bit field parameter used to specify how the I2C transaction starts and ends.        If Start or Restart are asserted the address will be sent prior to any data. If the stop is not set, it is assumed that another I2C instruction will occur, and the bus is left in control of the controller. When all of the bytes are read and a stop is specified, the controller will send a NACK on the last byte. This is in accordance with the I2C specification and allows slave devices to reset their control state machines to a known state. Examples of the “Option” parameter include: &H02 = Start with no stop at the end&H03 = Start, then Stop at the end&H05 = Restart, then Stop at the end
      Must be one of following options: B0 (Stop. Send a stop condition at the end of the transaction), B1 (Start. Send a start condition at the beginning of the transaction. The address will be sent following the start.), B2 (Restart. Send a restart condition at the beginning of the transaction. The address will be sent following the restart.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"I2CWrite({BeginPort},{Address},{Source},{NumBytes},{Option})"


def SPIOpen(
    BeginPort: Constant, BitRate: Constant, Option: Literal["7", "6", "5", "4"]
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiopen.htm).

                Note that a prior understanding of the operation and details of the SPI protocol is assumed.
    SPIOpen must be declared prior to using SPIRead or SPIWrite.
    Serial Peripheral Interface (SPI) protocol is a clocked synchronous interface that is used for short-distance communication, generally between embedded devices. When SPIOpen() is executed, three terminal blocks are dedicated to function as the SPI clock signal (SCK), Controller-Out, Peripheral-In signal (COPI), and Controller-In, Peripheral-Out signal (CIPO).

    Args:
                    BeginPort (Constant): The beginning port used for the three signals for SPI communications. The first port is the SPI clock signal. The next higher port from the clock port is the Controller Out Peripheral In (COPI) signal, and the next higher port is Controller In Peripheral Out (CIPO). BeginPort can be C1 or C5. If an additional chip select (CS) signal is required, it can be managed with PortSet instructions surrounding the SPI accesses.

            BitRate (Constant): The synchronous clock rate in hertz for the clock signal.

            Option (Constant): A bit field that is used to configure the operation of the SPI interface. The bits are defined as:  For example: Option field of &H60 Phase=0, Polarity=1, Data=1 and Length=0 Or Option field of &H30 Phase=0, Polarity=0, Data=1 and Length=1 The Diagram below demonstrates different SPI interface configurations and may be used to match the configuration needed for your specific sensor:  Source: https://commons.wikimedia.org/wiki/File:SPI_timing_diagram.svg
      Must be one of following options: 7 (0 = Data is changed on the first CLK edge and captured on the following edge.
    1 = Data is captured on the first CLK edge and changed on the following edge.), 6 (0 = The inactive state is low; 1 = The inactive state is high.), 5 (0 = LSB first; 1 = MSB first), 4 (0 = 8 bit and 1 =7 bit)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SPIOpen({BeginPort},{BitRate},{Option})"


def SPIRead(BeginPort: Constant, Dest: Variable, NumBytes: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiread.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiread.htm).

                Serial Peripheral Interface (SPI) protocol is a clocked synchronous interface, used for short distance communication, generally between embedded devices.
    Note that a prior understanding of the operation and details of the SPI protocol is assumed.

    Args:
                    BeginPort (Constant): The beginning port used for the three signals for SPI communications. The first port is the SPI clock signal. The next higher port from the clock port is the Controller Out Peripheral In (COPI) signal, and the next higher port is Controller In Peripheral Out (CIPO). BeginPort can be C1 or C5. If an additional chip select (CS) signal is required, it can be managed with PortSet instructions surrounding the SPI accesses.

            Dest (Variable): The variable in which the bytes read in will be stored.

            NumBytes (Variable): The number of bytes to clock from the periphreal device.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SPIRead({BeginPort},{Dest},{NumBytes})"


def SPIWrite(BeginPort: Constant, Source: Variable, NumBytes: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiwrite.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/spiwrite.htm).

                Serial Peripheral Interface (SPI) protocol is a clocked synchronous interface, used for short distance communication, generally between embedded devices.
    Note that a prior understanding of the operation and details of the SPI protocol is assumed.

    Args:
                    BeginPort (Constant): The beginning port used for the three signals for SPI communications. The first port is the SPI clock signal. The next higher port from the clock port is the Controller Out Peripheral In (COPI) signal, and the next higher port is Controller In Peripheral Out (CIPO). BeginPort can be C1 or C5. If an additional chip select (CS) signal is required, it can be managed with PortSet instructions surrounding the SPI accesses.

            Source (Variable): The variable in which the bytes to be written are stored.

            NumBytes (Variable): The number of bytes that will be sent to the peripheral device.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SPIWrite({BeginPort},{Source},{NumBytes})"


def IPNetPower(IPNetInterface: Constant, State: Constant, Timeout: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ipnetpower.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ipnetpower.htm).

                The first parameter is used to select the interface to control. The State parameter determines whether the power is on or off. When State is 0, a command is sent to the interface to put it into sleep mode. This instruction is the same as the Ethernet Interface Enabled setting in the datalogger’s Settings table. The Timeout parameter is optional and if the state is non-zero, the interface will be powered on and remain on for the time specified by the Timeout. The Timeout is refreshed when activity is detected, thus keeping the interface on while communications are active. The interface will be powered off the number of seconds specified by Timeout after the last detected activity.
    To control power to all Ethernet interfaces with one instruction, use the EthernetPower instruction.

    Args:
                    IPNetInterface (Constant): Used to select the interface to be powered on or off: 1 = internal Ethernet; 2 = CS I/O Interface(1) (NL201 by default); 3 = CS I/O Interface(2) (NL241 by default); 5 = CS Cell2XX-Series cellular modem. Right-click the parameter to display a drop-down list with the valid options.

            State (Constant): Determines whether the power is on or off. A non-zero value turns the power on; zero turns the power off. Right click the parameter for a drop-down list.

            Timeout  (Constant): The Timeout parameter is the number of seconds the interface will stay powered on after the last activity is detected on the Interface. The Timeout parameter is optional and if the state is non-zero, the interface will be powered on and remain on for the time specified by the Timeout. The Timeout is refreshed when activity is detected, thus keeping the interface on while communications are active. The interface will be powered off the number of seconds specified by Timeout after the last detected activity. NOTE:   Cell interfaces often experience frequent network traffic, which typically prevents them from shutting down. If shutting down a cell interface is desired, setting a short timeout (minimum of one second), in the optional timeout parameter can be used to prompt a shutdown.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"IPNetPower({IPNetInterface},{State},{Timeout})"


def ETsz(
    Temp: Variable,
    RH: Variable,
    uZ: Variable,
    Rs: Variable,
    Longitude: Constant,
    Latitude: Constant,
    Altitude: Constant,
    Zw: Variable,
    Sz: Integer,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/etsz.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/etsz.htm).

                This instruction follows the implementation in "The ASCE Standardized Reference Evapotranspiration Equation" published by the ASCE in 2005 and edited by Richard G. Allen and colleagues.  Specifically, it uses the calculations for hourly intervals with modifications for tall reference wind from Appendix B and modifications to clear-sky short wave radiation in Appendix D. The user can choose from a short reference or tall reference crop calculation.
    NOTE: This instruction uses an algorithm which is intended for hourly output. Use at other output intervals will lead to invalid results. Note that the datalogger's clock must be set to Standard time, not daylight saving time.
    There are two outputs: water loss in millimeters and the calculated clear sky solar radiation value for the site in MJ m-2. Calculated clear sky solar radiation (Rso) is defined as the amount of solar radiation that would be received at the weather measurement site under conditions of clear sky (i.e., cloud-free). Both values are the totals for the output interval of the data table in which the instruction is used (normally hourly). Calculated clear sky solar radiation is returned to help the user determine if the solar radiation sensor is functioning properly.
    Crop evapotranspiration (ETc) can be calculated by post-processing the ETo estimates as follows:
    ETc = crop evapotranspiration
    and ETo = reference crop evapotranspiration
    A variety of sources exist for obtaining crop coefficients for specific crops and crop growth stages.
    If the DisableVar is true for the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Also, If a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 is -7999, so NAN for FP2 data will appear in a data table as -7999. If the data type is Long, NAN will appear in the data table as -2147483648.
    The variable names ETos and ETrs are used for the short and long reference calculations, respectively, with a default unit of mm assigned. Default unit for Rso is MJ/m^2.

    Args:
                    Temp (Variable): The variable in which the value for temperature is stored. The value must be in degrees C. While not critical for the ETsz instruction, temperature is usually measured at a height of 1.5 to 2.5 meters.

            RH (Variable): The variable in which the value for relative humidity is stored. The value must be in percent.

            uZ (Variable): The uZ parameter is the variable in which the wind speed measurement is stored that will be used for the ETsz calculation. The wind speed measurement must be in meters per second. The wind sensor height entered below (Zw) is used to derive the wind at 2 meters needed for the ET calculation.

            Rs (Variable): The variable in which the solar radiation measurement is stored that will be used for the ETsz calculation. The solar radiation measurement must be scaled to give total MegaJoules per meter squared (MJ m-2) received during the period between calling the table with the ETsz instruction in it (this is normally the scan interval). If the sensor is scaled to output flux; for example Wm-2 , this would need to be multiplied by the scan interval in seconds and a multiplier applied to convert to MJ; for example, 10-6 to convert from W.

            Longitude (Constant): A constant or variable that provides the longitude for the datalogger station, expressed in decimal degrees west of the Greenwich meridian. For longitudes measured going east from the Greenwich meridian,  a corrected value (360 – EastDegrees) can be used.

            Latitude (Constant): A constant or variable that provides the latitude for the datalogger station. The range for Latitude is 0 to ±90 (positive value for Northern hemisphere and negative value for Southern hemisphere).

            Altitude (Constant): A constant or variable that provides the altitude above sea level for the datalogger station. This value must be in meters.

            Zw (Variable): The height of the wind speed sensor in meters.

            Sz (Integer): Used to select which crop reference to use for the ETsz calculation. Enter 0 for short reference calculation (similar to clipped grass) or 1 for tall reference calculation (similar to full-cover alfalfa). Right click the parameter to display a list.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ETsz({Temp},{RH},{uZ},{Rs},{Longitude},{Latitude},{Altitude},{Zw},{Sz},{DataType},{DisableVar})"


def FFT(
    SrcArray: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    N: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SampleInterval: Constant,
    Units: Literal["usec", "msec", "sec", "min"],
    Option: Literal["0", "1", "2", "3", "4", "5"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fft.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fft.htm).

                An inverse FFT can also be performed with this instruction, generating a time series from the results of an FFT.

    Args:
                    SrcArray (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the Source Array for FFT. Right-click the parameter to display a list of defined variables.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            N (Variable | Constant | Expression | Array | Integer | ConstantInteger): The number of points in the time series (must be a power of 2).

            SampleInterval (Constant): In normal operation (non-burst mode), this is the  datalogger scan rate, or the time series data interval. If the measurement instruction that created the time-series data used burst mode (that is, the channel was entered as a negative number), the CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible. For the FFT instruction, the exact sampling interval can be calculated as Tsample = 1.085069 * INT(SettleUSEC/1.085069) + 0.5), where SettleUSEC is the sample interval entered in the settling time parameter of the source instruction.

            Units (Constant): The units for the interval parameter. An alphabetical code is entered. Right-click the parameter to display a list.
      Must be one of following options: usec (microseconds), msec (milliseconds), sec (seconds), min (minutes)

            Option (Constant): Used to select the processing option for FFT. Right-click the parameter to display a list. If 100 is added to the option code (100, 101, 102, etc.), no FFT will be performed on an array of data that was processed by an FFTSpa instruction. The data will be stored to the data table with the appropriate description fields in the data file/header/table definitions so that it can be appropriately processed/graphed by the software. Normalization Details Complex FFT result I i = 1 .. N / 2: ai * cos( wi * t ) + bi * sin( wi * t ). wi =2 π ( I - 1 ) / T. φi =atan2( bi, ai ) ( 4 quadrant arctan ) Power(1) = ( a12 + b12 ) / N2 ( DC ) Power(i) = 2 * ( ai2 + bi2 ) / N2 ( i = 2..N / 2, AC ) PSD(i) = Power( I ) * T = Power( I ) * N * tau A1 = sqrt( a12 + b12 ) / N ( DC ) Ai = 2 * sqrt( ai2 + bi2 ) / N ( AC ) Notes Power is independent of the sampling rate (1/tau) and of the number of samples (N). The PSD is proportional to the length of the sampling period (T=N*tau), since the “width” of each bin is 1/T.The sum of the AC bins (excluding DC) of the Power Spectrum is the Variance (AC Power) of the time series.The factor of 2 in the Power(i) calculation is due to the power series being mirrored about the Nyquist frequency N/(2*T); only half the power is represented in the FFT bins below N/2, with the exception of DC. Hence, DC does not have the factor or 2.The Inverse FFT option assumes that the data array input is the transform of a real time series. Filtering is performed by taking an FFT on a data set, zeroing certain frequency bins, and then taking the Inverse FFT. Interpolation is performed by taking an FFT, zero padding the result, and then taking the Inverse FFT of the larger array. The resolution in the time domain is increased by the ratio of the size of the padded FFT to the size of the unpadded FFT. This can be used to increase the resolution of a maximum or minimum, as long as aliasing is avoided.
      Must be one of following options: 0 (FFT. The output is (N/2)+1 complex data points, i.e., the real and imaginary
    parts of the FFT. The first pair is the DC pair; the last pair is the Nyquist
    pair.  Zero is seen for their imaginary component.), 1 (Amplitude spectrum. The output is (N/2)+1 magnitudes. With Acos( ωt ); A is
    magnitude.), 2 (Amplitude and Phase Spectrum. The output is (N/2)+1 pairs of magnitude and phase; with Acos(ωt - φ); A is amplitude, φ is phase ( - π, π ).), 3 (Power Spectrum. The output is (N/2)+1 values normalized to give a power spectrum. With Acos(ωt - φ), the power is A2 / 2. The summation of the (N/2)+1 values yields the total power in the time series signal.), 4 (Power Spectral Density ( PSD ). The output is (N/2)+1 values normalized to give a power spectral density ( power per hertz ). The Power Spectrum multiplied by T
    = N * tau yields the PSD. The integral of the PSD over a given bandwidth yields the total power in that band. Note that the bandwidth of each value is 1 / T hertz.), 5 (Inverse FFT. The input is (N/2)+1 complex numbers, organized as in the output of option 0, which is assumed to be the transform of some real time series. The
    output is the time series (N values) whose FFT would result in the input array.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FFT({SrcArray},{DataType},{N},{SampleInterval},{Units},{Option})"


def FFTSpa(
    Dest: Variable | Array,
    N: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SrcArray: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SampleInterval: Constant,
    Units: Literal["usec", "msec", "sec", "min"],
    Option: Literal["0", "1", "2", "3", "4", "5"],
    FFTSpaInit: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fftspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fftspa.htm).

                An inverse FFT can also be performed with this instruction, generating a time series from the results of an FFT.
    The difference in this instruction and FFT is that the results are stored in an array instead of output to a table.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            N (Variable | Constant | Expression | Array | Integer | ConstantInteger): The number of points in the time series (must be a power of 2).

            SrcArray (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the Source Array for FFT. Right-click the parameter to display a list of defined variables.  For the FFTSpa instruction, the SrcArray is the name of the Variable array that contains the input data for the FFTSpa function.

            SampleInterval (Constant): In normal operation (non-burst mode), this is the  datalogger scan rate, or the time series data interval. If the measurement instruction that created the time-series data used burst mode (that is, the channel was entered as a negative number), the CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible. For the FFTSpa instruction, this is the sampling interval of the time series. Exact sampling interval can be calculated as Tsample = 1.085069 * INT(SettleUSEC/1.085069) + 0.5), where SettleUSEC is the sample interval entered in the settling time parameter of the source instruction.

            Units (Constant): The units for the interval parameter. An alphabetical code is entered. Right-click the parameter to display a list.
      Must be one of following options: usec (microseconds), msec (milliseconds), sec (seconds), min (minutes)

            Option (Constant): Used to select the processing option for FFT. Right-click the parameter to display a list. If 100 is added to the option code (100, 101, 102, etc.), no FFT will be performed on an array of data that was processed by an FFTSpa instruction. The data will be stored to the data table with the appropriate description fields in the data file/header/table definitions so that it can be appropriately processed/graphed by the software.
      Must be one of following options: 0 (FFT. The output is (N/2)+1 complex data points, i.e., the real and imaginary
    parts of the FFT. The first pair is the DC pair; the last pair is the Nyquist
    pair.  Zero is seen for their imaginary component.), 1 (Amplitude spectrum. The output is (N/2)+1 magnitudes. With Acos( ωt ); A is
    magnitude.), 2 (Amplitude and Phase Spectrum. The output is (N/2)+1 pairs of magnitude and phase; with Acos(ωt - φ); A is amplitude, φ is phase ( - π, π ).), 3 (Power Spectrum. The output is (N/2)+1 values normalized to give a power spectrum. With Acos(ωt - φ), the power is A2 / 2. The summation of the (N/2)+1 values yields the total power in the time series signal.), 4 (Power Spectral Density ( PSD ). The output is (N/2)+1 values normalized to give a power spectral density ( power per hertz ). The Power Spectrum multiplied by T
    = N * tau yields the PSD. The integral of the PSD over a given bandwidth yields the total power in that band. Note that the bandwidth of each value is 1 / T hertz.), 5 (Inverse FFT. The input is (N/2)+1 complex numbers, organized as in the output of option 0, which is assumed to be the transform of some real time series. The
    output is the time series (N values) whose FFT would result in the input array.)

            FFTSpaInit (Variable): This is an optional parameter. FFTSpaInit is a variable array that will be initialized at compile time with the frequency axis of the FFT, from DC to the Nyquist frequency, in units of Hertz. The array is not updated at run time.  The array can be dimensioned to hold less than the N/2+1 frequencies, or if it is dimensioned greater than N/2+1, the remainder will be initialized to 0. Normalization Details Complex FFT result I i = 1 .. N / 2: ai * cos( wi * t ) + bi * sin( wi * t ). wi =2 π ( I - 1 ) / T. φi =atan2( bi, ai ) ( 4 quadrant arctan ) Power(1) = ( a12 + b12 ) / N2 ( DC ) Power(i) = 2 * ( ai2 + bi2 ) / N2 ( i = 2..N / 2, AC ) PSD(i) = Power( I ) * T = Power( I ) * N * tau A1 = sqrt( a12 + b12 ) / N ( DC ) Ai = 2 * sqrt( ai2 + bi2 ) / N ( AC ) Notes Power is independent of the sampling rate (1/tau) and of the number of samples (N). The PSD is proportional to the length of the sampling period (T=N*tau), since the “width” of each bin is 1/T.The sum of the AC bins (excluding DC) of the Power Spectrum is the Variance (AC Power) of the time series.The factor of 2 in the Power(i) calculation is due to the power series being mirrored about the Nyquist frequency N/(2*T); only half the power is represented in the FFT bins below N/2, with the exception of DC. Hence, DC does not have the factor or 2.The Inverse FFT option assumes that the data array input is the transform of a real time series. Filtering is performed by taking an FFT on a data set, zeroing certain frequency bins, and then taking the Inverse FFT. Interpolation is performed by taking an FFT, zero padding the result, and then taking the Inverse FFT of the larger array. The resolution in the time domain is increased by the ratio of the size of the padded FFT to the size of the unpadded FFT. This can be used to increase the resolution of a maximum or minimum, as long as aliasing is avoided.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return (
        f"FFTSpa({Dest},{N},{SrcArray},{SampleInterval},{Units},{Option},{FFTSpaInit})"
    )


def FileManage(
    DeviceFileName: Literal["CPU:", "CRD:", "USR:", "USB:"],
    Attribute: Literal["bit", "bit", "bit", "bits", "bit", "bit", "bit"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filemanage.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filemanage.htm).

              FileManage is an instruction that allows the active datalogger program to manipulate program files that are stored in the datalogger.

    Args:
                  "Device:FileName" (Variable): "Device:FileName" is the device and name of the program file that will be executed (RunProgram) or manipulated (FileManage). The Device on which the file is stored must be specified and the entire string must be enclosed in quotation marks. Valid devices are:  The USR device is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512-byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up).
    Must be one of following options: CPU: (Internal CPU), CRD: (External Memory Card), USR: (User-Defined Drive), USB: (SC115)

          Attribute (Constant): A numeric code to determine what should happen to the file affected by the FileManage instruction. Attribute codes are a bit field. The codes are as follows: Setting a file's attributes to Hide makes it inaccessible using communications or the keyboard, but it can still be set as Run Now or Run on Power Up. A program marked as Run on Power Up can be disabled when power is first applied to the datalogger by pressing and holding the DEL key on the (optional) CR1000KD. The Restart instruction can be used to restart a datalogger program under program control, rather than using FileManage to Run Now/Run On Powerup.
    Must be one of following options: bit (1), bit (2), bit (4), bits (6), bit (8), bit (16), bit (32)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"FileManage({DeviceFileName},{Attribute})"


def FileMark(
    Name: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filemark.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filemark.htm).

                After the FileMark instruction is encountered, a filemark will be added to the next record written to the specified Table. The filemark inserted by this instruction indicates to the software processing the file that a new file should be started after the marked record. To make use of FileMarks, the DataTable must be kept in TOB3 format and processed using the CardConvert binary file utility (e.g., move the card to the PC and convert the files from the card, or collect the TOB3 file from the card using FileControl. Once the data is converted to some other ASCII or binary format, FileMarks are lost.)
    Note that this instruction marks the affected record as the last record of a file. The next record in the DataTable will be the first record of the new file. Therefore, the program logic should ensure that the FileMark instruction is encountered immediately prior to writing the record desired to be the last record of a file.

    Args:
                    Name (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the output table defined in the program.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileMark({Name})"


def FindSpa(
    SoughtLow: Variable, SoughtHigh: Variable, Step: Variable, Source: Variable | Array
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/findspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/findspa.htm).

                The FindSpa function returns the first position in the array of the sought after value. If the value is not found, 0 is returned. SoughtLow and SoughtHigh allow for a range to be specified for the searched value (they are included in the search).
    Note that the data types for Source and Sought values must be the same.

    Args:
                    SoughtLow (Variable): The lower limit for the value being sought. This value is included in the search.

            SoughtHigh (Variable): The upper limit for the value being sought. This value is included in the search.

            Step (Variable): The step to be used when searching through the source. It is useful in specifying row or dimension when searching a two or three dimensional array. Note that when Step is used, the value returned takes these "steps" into account. For instance, if a Step of 2 is used in a one dimensional array, a value that is found in the eighth element of an array will return a value of 4. If a Step of 1 was used, the returned value would be 8. Step values greater than one are more often used in multi-dimensional arrays

            Source (Variable | Array): The array to be searched for the sought value. Source can be a one, two, or three dimensional array. In a two dimensional array, the first element is the row and the second is the column. In a three dimensional array, the first element is depth, the second is row, and the third is column.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FindSpa({SoughtLow},{SoughtHigh},{Step},{Source})"


def Fix(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/intfix.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/intfix.htm).

                The Number argument can be any valid numeric expression. Both INT and FIX remove the fractional part of number and return the resulting integer value.
    If the numeric expression results in a Null value, INT and FIX return a NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN..
    FIX(number) is equivalent to:

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Fix({number})"


def FieldNames(
    Fieldname: Constant,
    Description: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldnames.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldnames.htm).

                The FieldNames instruction must be placed inside the DataTable declaration immediately following the output instruction for which names are being created. The names are entered in the form of "Fieldname:Description". The fieldname and description must be separated by a colon, and the entire string must be enclosed in quotation marks.
    As an example, the processing description and fieldname description for a Sample instruction might look like the following:
    "TempSmp:This is a sample air temp"
    If an output instruction generates multiple fields, individual names may be entered for each or a constant string with an index parameter indicating the number of times the string should be repeated may be used (for example, "NewNames(3)"). Individual names should be separated by a comma. If a String with an index is used, the name and reps must be specified (i.e., "NewNames(4)" specifies four field names; NewNames(1) through NewNames(4)). When the program is compiled, the datalogger will determine how many fields are created. If the list of names is greater than the number of fields, the extra names are ignored. If the number of fields is greater than the number names in the list of field names, the default names are used for the remaining fields.

    Args:
                    Fieldname (Constant): The name to be used for the value being output. It is a string that can be entered directly or represented by a constant. Field names are limited to 39 characters and cannot contain spaces. If an output instruction generates multiple fields, individual names may be entered for each or a constant string with an index parameter indicating the number of times the string should be repeated may be used.

            Description (Variable | Constant | Expression | Array | Integer | ConstantInteger): Provides a way for the user to include further information about the field; this element is optional. In a collected data file, the Description is included in the header file below the Fieldname, along with the processing description.The maximum number of characters for the Description is 64, including quotation marks, spaces, and other characters.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FieldNames({Fieldname},{Description})"


def LoadFieldCal(
    CheckSig: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/loadfieldcal.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/loadfieldcal.htm).

    Before loading the FieldCal values, the datalogger will check the program signature of the currently running program and the program signature stored in the FieldCal file. The CheckSig parameter is a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. variable that determines whether or not the datalogger will load the FieldCal values if the program signatures do not match. If CheckSig is True, the program signature must match the signature in the .cal file for the values to load. If CheckSig is False, only the fields in the .cal field need to match for the values to load. The LoadFieldCal function returns True if the .cal found was successfully loaded or false if it is not.

    Args:
        CheckSig (Variable | Constant | Expression | Array | Integer | ConstantInteger): CheckSig (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"LoadFieldCal({CheckSig})"


def IIF(
    Expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TrueValue: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FalseValue: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iif.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iif.htm).

        The Expression to be evaluated is defined in parameter 1. If the Expression is True, the TrueValue (parameter 2) is returned. If the Expression is False, the FalseValue (parameter 3) is returned. By default, the values returned are of type Float. TrueValue and FalseValue can be Strings. For a string to be returned, the parameter must be enclosed in quotes. For example, IIF(1,”1”,”0”). To obtain an output of type Long, apply FormatLong() in both true and false conditions. For example, IIF (1,FormatLong (ValueA,"%d"),FormatLong (ValueB,"%d")).

    Args:
            Expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): Expression (No description provided)

    TrueValue (Variable | Constant | Expression | Array | Integer | ConstantInteger): TrueValue (No description provided)

    FalseValue (Variable | Constant | Expression | Array | Integer | ConstantInteger): FalseValue (No description provided)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"IIF({Expression},{TrueValue},{FalseValue})"


def SampleFieldCal(
    TableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NewFieldCal: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Size: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/samplefieldcal.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/samplefieldcal.htm).

    Args:
            TableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): TableName (No description provided)

    NewFieldCal (Variable | Constant | Expression | Array | Integer | ConstantInteger): NewFieldCal (No description provided)

    Size (Variable | Constant | Expression | Array | Integer | ConstantInteger): Size (No description provided)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SampleFieldCal({TableName},{NewFieldCal},{Size})"


def NewFieldCal(
    TableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NewFieldCal: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Size: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfieldcal.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfieldcal.htm).

    Args:
            TableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): TableName (No description provided)

    NewFieldCal (Variable | Constant | Expression | Array | Integer | ConstantInteger): NewFieldCal (No description provided)

    Size (Variable | Constant | Expression | Array | Integer | ConstantInteger): Size (No description provided)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"NewFieldCal({TableName},{NewFieldCal},{Size})"


def NewFieldNames(
    GenericName: Variable,
    NewNames: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfieldnames.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfieldnames.htm).

                When using the NewFieldNames instruction, a variable array is given a generic name. Whenever the NewFieldNames instruction is executed, the next available generic variable in a data table is assigned a new name from the NewNames string.
    This instruction accommodates smart sensors that return a unique name as part of a data string (where the unique name can be parsed out of the string and used for the NewName) or the addition of a Campbell Scientific wireless sensor into an existing wireless sensor network.
    NOTE: When a NewName is assigned to a generic variable, the table definitions in the datalogger will change. Thus, any operation that relies on datalogger table definitions is affected. For example, if scheduled data collection is taking place, when the generic variable name is changed a backup file is created for the existing *.dat file and a new file, with the new header information, is written.
    Only one NewFieldNames instruction is allowed in a program.
    GenericName (Generic Name)
    The name for the variable array assigned to the generic variable(s).
    A string that will be used to populate the generic variable field names when the NewFieldNames instruction is run. Multiple names in a list should be separated with commas.

    Args:
                    GenericName (Variable): The name for the variable array assigned to the generic variable(s).

            NewNames (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that will be used to populate the generic variable field names when the NewFieldNames instruction is run. Multiple names in a list should be separated with commas.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"NewFieldNames({GenericName},{NewNames})"


def FieldCal(
    Function: Literal["0", "1", "2", "3", "4"],
    MeasureVar: Variable,
    Reps: Variable | Constant,
    MultVar: Variable,
    OffsetVar: Variable,
    Mode: Literal["-1", "-2", "-3", "0", "1", "2", "3", "4", "5", "6", "-6"],
    KnownVar: Variable,
    Index: Variable | Constant,
    Avg: Variable | Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldcal.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldcal.htm).

                When the FieldCal instruction is in a program, a Cal file with calibration values will be written to datalogger memory. The name of the calibration file is the same as the running program that created it with a *.CAL file extension. The values from this file can be loaded back into the variables in the datalogger if the datalogger experiences a power failure (see LoadFieldCal (Load Calibration Values from FieldCal)). Best practice is to put the FieldCal instruction in the same scan loop as the measurements being calibrated
    NOTE: It is recommended that the Reps and Index parameters be non-constant variables that are initialized to the desired values after the BeginProg instruction. This rule can be ignored if setting up calibrations on single element variables, and the Mode variable parameter for each FieldCal instruction in the program is represented by a unique variable.
    The keyboard display or software interface can be used to set the calibration values in the datalogger.
    The following describes how to use FieldCal with Function  2 (Two Point, Multiplier and Offset) or 3 (Two Point, Multiplier Only) where manual input of a measurement is required.  An example is calibrating a datalogger measurement to a secondary measurement from a hand-held meter.
    The transition through the various calibration steps or Modes  is done automatically except Modes 1 and 4.  Once the 1st calibration data point is in the variable MeasureVar, the FieldCal Mode is manually changed from 0 to 1 to start the process. The FieldCal function reads the datalogger input being calibrated multiple times as indicated by the Avg parameter.  FieldCal will automatically increment from Mode 1 to 2 and from 2 to 3.  Mode 3 indicates the data has been processed and FieldCal is ready for the 2nd set of data points.  Once the 2nd data point is input into the MeasureVar variable the FieldCal Mode is manually changed to 4 to initiate the processing of the 2nd set of data points and perform the calibration calculations. The FieldCal function reads the datalogger input being calibrated multiple times as indicated by the Avg parameter.  FieldCal will automatically increment from Mode 4 to 5 and from 5 to 6.  Mode 6 indicates the calibration is complete.
    Here is the process used to perform Two Point, Multiplier and Offset calibration with manual manipulation of FieldCal Mode and manual data entry:
    1.	Set the system being measured to the 1st of two measurements (ex. lowest voltage setting). The datalogger reads the 1st data point and puts the value into the MeasureVar(1) variable.
    2.	Enter the 1st value (from the meter reading) into the KnownVar variable
    3.	The Mode starts at 0 by default. Manually or programmatically set the Mode to 1 to initiate the calibration routine.
    4.	The Fieldcal Mode will change to 2 indicating that it is calculating and then change to 3 when the 1st data point processing is complete
    5.	Set the system being measured to the 2nd of two measurements (ex. highest voltage setting). The datalogger reads the 2nd data point and puts the value into the MeasureVar(1) variable.
    6.	 Enter the 2nd value (from the meter reading) into the KnownVar variable
    7.	Manually or programmatically set the Mode to 4 to initiate the calibration routine.
    8.	The Fieldcal Mode will change to 5 indicating that it is calculating and then change to 6 when the processing is complete
    9.	The  MultVar and OffsetVar variables are populated with the multiplier and offset values.  Use these values in commands like VoltDiff for calibrated measurements.
    See Example #2 for a program that uses this process.
    See the Calibration and Zeroing section in the LoggerNet or RTDAQ manual for more information on using the FieldCal instruction.

    Args:
                    Function (Integer): Specifies the type of calibration to be performed. Right click the parameter to display a list:
      Must be one of following options: 0 (Zeroing Calibration. The offset value is adjusted so that the measurement result is exactly zero while the sensor is in the calibrated state (known zero condition). The multiplier is not adjusted.), 1 (Offset Calibration. The offset value is adjusted so that the measurement result gives a specified, desired value while the sensor is in its calibrated state (known condition). The multiplier is not adjusted.), 2 (Two Point, Multiplier and Offset. The multiplier and offset values are adjusted to make a linear fit between the two calibration input states (two known
    conditions).), 3 (Two Point, Multiplier Only. The multiplier value is adjusted to make a best fit between the two calibration input states (two known conditions). The offset is not adjusted.), 4 (Zero Basis Point. A measurement value (usually non-zero) is stored for later reference, comparison, or calculation purposes (Baseline or Datum point).
    This value corresponds to a zero condition or baseline sensor state. Neither the multiplier nor the offset is adjusted.)

            MeasureVar (Variable): The variable or variable array being calibrated. Note that for the FieldCal instruction, the MeasureVar parameter must be dimensioned large enough to accommodate the number of Reps.

            Reps (Variable | Constant): The Reps parameter is a constant or variable used to specify how many values in the array to calibrate. Reps must be equal to either 1 or the size of the MeasureVar parameter array. When Reps is equal to the size of the MeasureVar array, all elements of the MeasureVar array will be calibrated in a single scan (the Index parameter must be set to 1). When Reps is set to 1, a single element of the MeasureVar array, specified by the Index parameter will be calibrated. If the Reps parameter is declared as a variable, the number of reps can be changed during program operation. This allows the calibration of a complete array or a single element at different points in time. Reps should be initialized to either 1 or the size of the MeasureVar array prior to starting a calibration. If Reps is set to zero, no calibration will occur for this instruction.

            MultVar (Variable): The MultVar parameter is the variable or variable array that will be populated with the computed Multiplier(s) from the calibration(s). This variable should also be used for the Multiplier parameter in the measurement instruction for which the calibration is being made. MultVar should be dimensioned to the same size as the MeasureVar variable array. The element of the array for the calibration is set by the Index parameter. If MultVar is equal to 0 or NAN at the start of calibration, it will be set to 1 during the calibration process.

            OffsetVar (Variable): The OffsetVar parameter is the variable or variable array that will be populated with the computed Offset(s) from the calibration(s). This variable should also be used for the Offset parameter in the measurement instruction for which the calibration is being made. When performing a Multiplier Only Two Point calibration, zero can be entered for this parameter. When performing any other calibration function, the OffsetVar should be dimensioned to the same size as the MeasureVar variable array. The element of the array for the calibration is set by the Index parameter. If OffsetVar is equal to NAN at the start of calibration, it will be set to 0 during the calibration process.

            Mode (Variable): A variable that stores an integer that indicates the current state of the calibration. This is both a trigger value to start a process and a status value reporting an operational state or error state. States are as follows: If multiple FieldCal instructions are used in the program, you must define a Mode variable for each instruction.
      Must be one of following options: -1 (Error in the calibration setup), -2 (Multiplier set to 0 or = NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.; measurement = NAN), -3 (Reps is set to a value other than 1 or the size of MeasureVar), 0 (No calibration), 1 (Ready to calculate (KnownVar holds the first of a two point calibration)), 2 (Working), 3 (First point done (only applicable for two point calibration)), 4 (Ready to calculate (KnownVar holds the second of a two point calibration)), 5 (Working (only applicable for two point calibration)), 6 (Calibration complete), -6 (New calibration attempted before datalogger is ready for calibration (one full scan must execute after calibration is complete, and before another calibration
    can be started))

            KnownVar (Variable): The KnownVar parameter is a variable array that holds the set point value(s) to be used in the calibration routine. 0 can be entered when performing a Zero calibration. When performing any other calibration function, the KnownVar must be dimensioned to the same size as the MeasureVar. The element of the array used for the first calibration is set by the Index parameter.

            Index (Variable | Constant): If Reps is set to 1, then Index specifies which element of the MeasureVar array will be calibrated. If Reps is set to the size of the MeasureVar, then Index must be set equal to 1 (complete array will be calibrated starting with the first element). This parameter can be a constant or a variable. It must be initialized to a non-zero value before a calibration can be performed.

            Avg (Variable | Integer): Specifies the number of points to average when performing the calibration. In the Calibration Wizard (available from RTDAQ or the LoggerNet Connect screen), if a program has been configured to zero multiple measurements using the same mode variable, and the Reps argument of the FieldCal instruction is using a variable, then specific measurements can be excluded from the calibration by setting the value of the Reps variable to zero. This will ensure that the measurement is not calibrated, even though its mode variable is activated. NOTE: When performing the calibration, the FieldCal instruction automatically compensates for any existing multiplier and offset for the measurement instruction. There is no need for the user to do this under program control.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FieldCal({Function},{MeasureVar},{Reps},{MultVar},{OffsetVar},{Mode},{KnownVar},{Index},{Avg})"


def FieldCalStrain(
    Function: Literal["10", "13", "33", "43"],
    MeasureVar: Variable,
    Reps: Variable | Constant,
    GFAdj: Variable,
    ZeromVV: Variable,
    Mode: Literal["-1", "-2", "-3", "0", "1", "2", "3", "4", "5", "6"],
    KnownRs: Variable,
    Index: Variable | Constant,
    Avg: Variable | Integer,
    GFRaw: Variable,
    uStrainDest: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldcalstrain.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fieldcalstrain.htm).

                This instruction is a specialized form of the FieldCal instruction used to perform zeroing and shunt calibrations on quarter bridge strain, half bridge bending strain, and full bridge bending strain measurements using the StrainCalc function. It should be noted that Shunt Calibration does not calibrate the strain gauge, but adjusts the gauge manufacturer supplied calibration gauge factor (GF) to compensate for errors introduced by non-linearity in the Wheat-stone bridge, long leads, and/or errors in the measurement system.
    When the FieldCalStrain instruction is in a program, a Cal file with calibration values is written to datalogger memory. The location (CPU or Card) of this file is the same as the running program that created it. The name of the calibration file is the same as the running program that created it with a *.CAL file extension. The values from this file can be loaded back in to the variables in the datalogger if the datalogger experiences a power failure (see LoadFieldCal).
    NOTE: It is recommended that the Reps and Index parameters be declared as non-constant variables that are initialized to the desired values after the BeginProg instruction. This rule can be ignored if setting up calibrations on single element variables, and the Mode variable parameter for each FieldCalStrain instruction in the program is represented by a unique variable.
    The keyboard display or software interface can be used to set the calibration values in the datalogger.

    Args:
                    Function (Integer): Specifies the type of calibration to be performed. Right click the parameter to display a list:
      Must be one of following options: 10 (Zeroing calibration), 13 (Quarter bridge strain shunt calibration), 33 (Bending half bridge strain shunt calibration), 43 (Bending full bridge strain shunt calibration)

            MeasureVar (Variable): The variable or variable array holding the result of the StrainCalc instruction for the gauges being calibrated. The MeasureVar must be dimensioned large enough to accommodate the number of Reps.

            Reps (Variable | Constant): Specifies how many values to calibrate. Reps must be set to 1 or the number of elements in the MeasureVar array. When Reps is equal to the size of the MeasureVar parameter, all elements of the MeasureVar array will be calibrated in a single scan. When Reps is set to 1, the element of the MeasureVar specified by the Index parameter will be calibrated.

            GFAdj (Variable): Not used for zero calibration. Enter 0. For shunt calibration, this parameter is the variable or variable array that is populated with the computed gauge factors used in the StrainCalc instruction for computing the microstrain. It should be dimensioned large enough to hold values for all the elements in the MeasureVar array. GFAdj is set equal to GFRaw during the calibration process.

            ZeromV/V (Variable): For Zero calibration, this parameter is the variable or variable array that will be populated with the zero mV/V values. It should be dimensioned large enough to hold values for all of the Reps of the source MeasureVar array. If ZeromV/V is a NAN, it will be set to 0 during the calibration process. ZeromV/V is not used for shunt calibration. Enter 0

            Mode (Variable): A variable that stores an integer that indicates the current state of the calibration. States are as follows:
      Must be one of following options: -1 (Error in the calibration setup), -2 (Multiplier set to 0 or = NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.; measurement = NAN), -3 (Reps is set to a value other than 1 or the size of MeasureVar), 0 (No calibration), 1 (Ready to calculate), 2 (Working), 3 (Ready to enter the shunt resistance into KnownRs (only for shunt
    calibration)), 4 (Ready to calculate), 5 (Working (only applicable for two point calibration)), 6 (Calibration complete)

            KnownRs (Variable): The KnownRs parameter is a variable array that holds the set point value(s) to be used in the calibration routine. 0 can be entered when performing a Zero calibration. When performing any other calibration function, the KnownVar must be dimensioned to the size of MeasureVar. If Reps is set to 1, the element of the array used for the calibration is set by the Index parameter. Enter the resistance value as a positive number if shunting across the arm that holds the strain gauge for function 13, the arm that holds the gauge that is parallel to +ε for function 33, or the arm that holds the gauge that is parallel to to +ε for function 43. Enter the resistance value as a negative number if shunting across the arm that holds the completion resistor for function 13, the arm that holds the gauge that is parallel to -ε for function 33, or the arm that holds the gauge that is parallel to -ε for function 43.

            Index (Variable | Constant): If Reps is set to 1, then Index specifies which element of the MeasureVar array will be calibrated. If Reps is set to the size of the MeasureVar, then Index must be set equal to 1 (complete array will be calibrated starting with the first element). This parameter can be a constant or a variable. It must be initialized to a non-zero value before a calibration can be performed.

            Avg (Variable | Integer): Specifies the number of points to average when performing the calibration.

            GFRaw (Variable): Zero calibration: Zero can be entered for this parameter (not used). Shunt calibration: When setting up a Shunt Calibration, this is the variable or variable array that holds the raw gauge factor(s) for the strain gauges. It should be a different array than that used for the adjusted gauge factors in the StrainCalc instruction, and the value(s) should never be changed. This variable array must be dimension to the same size as the MeasureVar.

            uStrainDest (Variable): Zero calibration: Variable array that is used to store the micro-strain reading result from the StrainCalc instruction. Informs the Zero wizard of the variable array that is being zeroed. Should be dimensioned to the size of the MeasVar. Shunt calibration: This value is not required. Enter 0.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FieldCalStrain({Function},{MeasureVar},{Reps},{GFAdj},{ZeromVV},{Mode},{KnownRs},{Index},{Avg},{GFRaw},{uStrainDest})"


def FileOpen(
    FileName: Variable,
    Mode: Literal[
        '"a"',
        '"ab"',
        '"a+"',
        '"a+b"',
        '"d"',
        '"r"',
        '"rb"',
        '"r+"',
        '"r+b"',
        '"w"',
        '"wb"',
        '"w+"',
        '"w+b"',
    ],
    SeekPoint: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileopen.htm).

                The FileOpen function returns a FileHandle, which can then be used by subsequent file read/write functions (FileWrite, FileRead, FileReadLine, FileClose). The FileHandle variable must be declared as a Long variable type. The file to be read from or written to can be either an ASCII text file or a binary file. If FileOpen fails, 0 is returned.
    With files opened for writing in ASCII text, every line feed character is replaced with a carriage return. When reading ASCII text files, all carriage return characters (CHR(13)) are discarded and line feed characters (CHR(10)) are converted to end of line.

    Args:
                    FileName (Variable): Used to specify the Device and FileName for the file written to or read from. FileName must be enclosed in quotes. It is entered in the format of "Device:FileName" where Device is CPU, CRD (memory card), USR (user-defined drive), or USB (SC115). The USR drive is the recommended device if a card is not being used and a file is being written. Since frequent writes to datalogger CPU memory could quickly surpass the number of write cycles for the flash memory.

            Mode (Variable): Determines whether the file is being read from or written to, and whether the file format is ASCII or binary. Mode must be enclosed in quotes. Right-click the parameter to display a list of the following options: NOTE: If the file is opened with a mode that specifies ASCII, when a Chr(10) (line feed) is encountered, a Chr(13) (carriage return) is inserted before the line feed.The MoveBytes instruction should be used to move floats into a string variable if TOB1 binary files are being written.
      Must be one of following options: "a" (Append to ASCII file at EOF End of file. (write). Set SeekPoint to -1 to append to end of
    file, or specify a value to begin writing other than end of file.), "ab" (Append to binary file at EOF (write). Set SeekPoint to -1 to append to end of
    file, or specify a value to begin writing other than end of file.), "a+" (Append to ASCII file at EOF (read/write). Set SeekPoint to -1 to append to end of file, or specify a value to begin writing other than end of file.), "a+b" (Append to binary file at EOF (read/write). Set SeekPoint to -1 to append to end of file, or specify a value to begin writing other than end of file.), “d” (Opens a connection to a specified directory; used to determine if a drive is available.), "r" (Open ASCII file for reading at SeekPoint (read).), "rb" (Open binary file for reading at SeekPoint (read).), "r+" (Open ASCII file for update at SeekPoint (read/write).), "r+b" (Open binary file
    for update at SeekPoint (read/write).), "w" (Open/overwrite ASCII file (write). SeekPoint is not valid; leave at 0.), "wb" (Open/overwrite binary file (write). SeekPoint is not valid; leave at 0.), "w+" (Open/overwrite ASCII file (read/write). SeekPoint is not valid; leave at 0.), "w+b" (Open/overwrite binary file (read/write). SeekPoint is not valid; leave at 0.)

            SeekPoint (Variable): Specifies the byte position to begin reading from or writing to when the file is opened. The value is in bytes, and the read or write begins after the specified SeekPoint. For instance, if 100 is entered, the read or write begins at byte 101. If 0 is entered and a file is being written, existing data will be overwritten. If one of the four "a" options is being used to write data, enter -1 to append to the end of the file or enter a value to begin at a specific byte. SeekPoint has no affect with the "w" options, which always begin at byte 0, overwriting the existing data. If one of the four "a" options is being used to write data, enter -1 to append to the end of the file or enter a value to begin at a specific byte. SeekPoint has no affect with the "w" options, which always begin at byte 0, overwriting the existing data. Multiple reads or writes (prior to a FileClose for the FileHandle) begin where the previous file operation left off. When a FileClose instruction is executed for the FileHandle, the FileHandle is deleted.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileOpen({FileName},{Mode},{SeekPoint})"


def FileClose(FileHandle: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileclose.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileclose.htm).

                This function returns 0 if successful or -1 if the FileHandle referenced is not valid. FileHandle is the variable that was created by the FileOpen instruction. FileClose will return -1 if the handle specified was not opened by FileOpen or the file was already closed.
    Note that this instruction does not reset the original value assigned to FileHandle.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileClose({FileHandle})"


def FileCopy(
    FromFileName: Literal["CPU:", "CRD:", "USR:", "USB:"],
    ToFileName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filecopy.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filecopy.htm).

              The FileCopy function returns True if the operation is successful or False if it fails. If a file with the same name already exists, the existing file will be overwritten. The FileHandle for the file must be closed (FileClose) before the file can be copied.

    Args:
                  FromFileName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the file to be copied. It is a string entered in the format "Device:FileName". If a Device is not specified, the CPU drive will be assumed. Valid devices are: The USR device is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512-byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up).
    Must be one of following options: CPU: (Internal CPU), CRD: (External Memory Card), USR: (User-Defined Drive), USB: (SC115)

          ToFileName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The destination (drive) and name for the copied file. Like the FromFileName parameter, it is a string entered in the format "Device:FileName". If a Device is not specified, the CPU drive will be assumed.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"FileCopy({FromFileName},{ToFileName})"


def FileEncrypt(
    DeviceFileName: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileencrypt.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileencrypt.htm).

                FileEncrypt creates a binary encrypted file that is the same size as the original file. The encrypted file is decoded automatically at compile time if it is used in a CRBasic program. This function allow distribution of CRBasic files without exposing the source code.
    FileEncrypt returns true if the file is successfully encrypted. If the file is already encrypted, is not found, or cannot be opened, the function returns false.
    The contents of a variable can be encrypted (and subsequently decrypted) using the Encryption function.
    NOTE: Ideally, file encryption is done by CRBasic's Save and Encrypt functionality (see File Menu for more information). If using a datalogger program to encrypt a file, a "run once" program should be created that encrypts the file and then stops execution. Putting FileEncrypt in a running program will slow down program execution time and possibly cause erratic behavior.

    Args:
                    "Device:FileName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string, enclosed in quotes, that contains the name of the file to be encrypted. The Device on which the file is stored is specified as CPU, CRD (memory card), USR (user-defined drive), or USB (SC115)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileEncrypt({DeviceFileName})"


def FileWrite(FileHandle: Variable, Source: Constant, Length: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filewrite.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filewrite.htm).

                This function writes the data in the Source variable to a FileHandle created by FileOpen. This function returns the number of bytes successfully written to the file.
    With files opened for writing in ASCII text, every line feed character is replaced with a carriage return. When reading ASCII text files, all carriage return characters (CHR(13)) are discarded and line feed characters (CHR(10)) are converted to end of line.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

            Source (Constant): The constant, variable, or array of variables to be written to file.

            Length (Variable): The maximum number of characters of Source to be written to the file. Length should be equal to or less than the number of bytes in Source. If Length is set to 0, Source should be a string. Note that in this instance, all bytes up to the first null will be written. To write each file using a unique name, refer to FilesManager.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileWrite({FileHandle},{Source},{Length})"


def FileRead(FileHandle: Variable, Destination: Variable, Length: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileread.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/fileread.htm).

                The FileRead function returns the number of bytes successfully read. This function reads to the end of the file or to the maximum number of bytes (Length parameter). To read only one line of a file, use the FileReadLine function.
    With files opened for writing in ASCII text, every line feed character is replaced with a carriage return. When reading ASCII text files, all carriage return characters (CHR(13)) are discarded and line feed characters (CHR(10)) are converted to end of line.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

            Destination (Variable): The variable in which the results of the read should be stored.

            Length (Variable): Specifies the maximum number of characters to be read in to the Destination variable. If Destination is an array, Length must equal to at least the total of the number of bytes for all elements in the array. For example, if you are reading 3 elements of an array and each element is 4 bytes, Length must be at least 12. To read each file using a unique name, refer to FilesManager.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileRead({FileHandle},{Destination},{Length})"


def FileReadLine(FileHandle: Variable, Destination: Variable, Length: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filereadline.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filereadline.htm).

                The FileReadLine function reads to the end of a line (as indicated by a carriage return or line feed) or until the maximum number of bytes is reached (specified by Length). The FileReadLine function returns the number of bytes successfully read,  -1 if the end of the file is reached, or 0 if the file handle is not good (for example, if the file to read from is not there). To read multiple lines or an entire file, use FileRead.
    With files opened for writing in ASCII text, every line feed character is replaced with a carriage return. When reading ASCII text files, all carriage return characters (CHR(13)) are discarded and line feed characters (CHR(10)) are converted to end of line. FileReadLine is terminated after the end of line is encountered.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

            Destination (Variable): The variable in which the results of the read should be stored.

            Length (Variable): Specifies the maximum number of characters to be read in to the Destination variable. If Destination is an array, Length must equal to at least the total of the number of bytes for all elements in the array. For example, if you are reading 3 elements of an array and each element is 4 bytes, Length must be at least 12.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileReadLine({FileHandle},{Destination},{Length})"


def FileRename(
    OldFileName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NewFileName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filerename.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filerename.htm).

                The FileRename function returns True if the operation is successful or False if it fails. If the drive location (Device) for the OldFileName and NewFileName are the same and a file with the same name already exists, the function will fail.
    If the drive location (Device) for the OldFileName and NewFileName are different, the new file is copied to the NewFileName and the OldFileName is deleted. If a file with the same name exists on the new drive, the operation acts like a file copy and replace (i.e., the existing file is overwritten rather than the operation failing).
    The FileHandle for the file must be closed (FileClose) before the file can be renamed.

    Args:
                    OldFileName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the file to be renamed. It is a string entered in the format "Device:FileName". If Device = CPU, the file is stored in datalogger memory. If Device = CRD, the file is stored on a memory card. If Device = USB, the file is stored on the SC115. If Device = USR, the file is stored in a user-created memory space.   The USR drive is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512 byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up).  If a Device is not specified, the CPU drive will be assumed.

            NewFileName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The new name for the file. It is a string entered in the format "Device:FileName". If Device = CPU, the file is stored in datalogger memory. If Device = CRD, the file is stored on a memory card. If Device = USB, the file is stored on the SC115. If Device = USR, the file is stored in a user-created memory space. If a Device is not specified, the CPU drive will be assumed.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileRename({OldFileName},{NewFileName})"


def FileTime(FileHandle: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filetime.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filetime.htm).

                The FileHandle parameter specifies the file for which a timestamp should be returned. The value returned is the last modified timestamp, in seconds since January 1, 1990, with a resolution of 2 seconds. . If FileHandle is a string expression, then it references the location and name of the file. E.g., "Device:FileName" where Device is CPU, CRD (memory card), USR (user-defined drive), or USB (SC115)  Else, FileHandle references the return from the FileOpen function.
    If Variable is declared as Long, it can be sampled into a data table using the NSEC data format to return a formatted timestamp (mm/dd/7777 hh:mm:ss). If the function fails it will return -2,147,483,648, which, if sampled using NSEC results in a date of 12/13/1921 20:45:52. The function may fail because the file is opened for writing or the file cannot be found. If FileHandle is formatted as a string, make sure the string is sized large enough to accommodate the entire file name.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileTime({FileHandle})"


def FileSize(FileHandle: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filesize.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filesize.htm).

                The FileHandle parameter specifies the file for which the size should be returned. If FileHandle is a string expression, then it references the location and name of the file. E.g., "Device:FileName" where Device is CPU, CRD (memory card), USR (user-defined drive, or USB (SC115). Else, FileHandle references the return from the FileOpen function.
    If the FileSize function fails it will return 0. The function may fail because the file is opened for writing or the file cannot be found.
    If FileClose is used to close the file, FileSize must appear prior to FileClose. Once FileClose is executed, the FileHandle no longer exists.

    Args:
                    FileHandle (Variable): The program reference to the file being read from, written to, or otherwise affected by the function. A FileHandle is created by a FileOpen function and deleted by FileClose. Recommended variable type is Long.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FileSize({FileHandle})"


def FileList(
    Device: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FileListDest: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filelist.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/filelist.htm).

        The FileList function writes a list of file names, with path, from the specified device into the Destination array. FileList returns to Variable the number of files written to the array if successful. If the Device does not exist a -1 is returned. If the Destination array cannot be written to, a -2 is returned. Files opened for writing are excluded from the list of files.

    Args:
            Device (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that indicates the device that will be queried for files. The Device parameter may be a string literal or a string variable. The options are "CPU" (datalogger CPU), "USR" (user-defined drive), "CRD" (memory card), or "USB" (SC115).

    FileListDest (Variable): The Dest parameter is the string variable or string variable array in which the names of the files will be stored. Each element of the array will hold one file name. File names returned included the file path. The Dest array will not be cleared before being written to. File names will be added to the array starting with the first element indicated by the Dest argument up through the number of file names returned or until the end of the specified array dimension is reached. This allows the same array to be utilized as the destination for multiple instructions. If the desire is to clear the array before using FileList(), consider using the Erase() or Move() instructions to clear the array or fill it with a known value first. If the Dest argument is a two-dimensional array, the list of files will terminate at the end of the dimension specified. For example, if Dest is a 2x2 two-dimensional array, Dest(1,1) is used as the argument, and there are 4 files in the device directory, only two file names will be returned into elements Dest(1,1) and Dest(1,2). To query more than one device type for a list of files in a program, Dest should be a two dimensional array, where the most significant array is used for the device type. For example, Dest(2, 10) would allow two FileList functions, FileList(“CPU”, File(1,1)) and FileList(“CRD”,File(2,1)), without the second function overwriting the results of the first. Results from the first FileList function would be stored in FileList(1,1) through FileList(1,n) and results from the second FileList function would be stored in FileList(2,) through FileList(2,n)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"FileList({Device},{FileListDest})"


def Frac(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/frac.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/frac.htm).

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Frac({number})"


def FormatFloat(
    Float: Variable | Constant,
    FormatString: Literal["%f", "%e", "%g", "%Y.Zf", "%0Y.0Zf", "%Ye", "%Yg"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatfloat.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatfloat.htm).

              The string conversion of the floating point value is formatted based on the FormatString parameter.

    Args:
                  Float (Variable | Constant): The variable or constant that holds the floating point value to be converted.

          FormatString (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines how the floating point value will be represented in the converted string The options are (m = mantissa; d = decimal; x = exponent): Right-click the parameter to display a list of options. The format string must be enclosed in quotes. NOTE: Other ASCII characters can be included in the FormatString (for example, FormatFloat(Variable,"The current reading is %2.3G").
    Must be one of following options: %f (Decimal notation in the form of ±mmm.dddddd; precision is 6 places to the right of the decimal.), %e (Decimal notation in the form of ±m.dddddd e±xx; precision is 6 places to the right of the decimal.), %g (Mantissa and decimal are variable; trailing 0s and decimals are omitted if the input has a precision less than specified by the format string.), %Y.Zf (Decimal notation in the form of ±m.d; field width is defined by Y and includes the sign and decimal place. Precision is defined by Z.), %0Y.0Zf (Decimal notation in the form of ±m.d; field width is defined by Y and includes the sign and decimal place. The mantissa will be padded by leading 0s if necessary. Precision is defined by Z. The decimal will be padded with trailing 0s.), %Ye (Decimal notation in the form of ±m.d e±xx; field width is defined by Y and includes the sign and decimal place.), %Yg (Mantissa and decimal are variable; field width is defined by Y and includes the sign and decimal place.)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"FormatFloat({Float},{FormatString})"


def FormatLong(
    LongVar: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FormatString: Literal["%d", "%i", "%u", "%x", "%X", "%o", "%b"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatlong.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatlong.htm).

              FormatLong can be used to store a formatted Long into a string, or it can be used within another instruction to format a Long.

    Args:
                  LongVar (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable that will be formatted.

          FormatString (Variable): A code used to apply formatting to the Long variable. Options are: The formatted Long can be padded with zeros (or spaces), using the notation %#code (right justified) or %-#code (left justified), where # is the number of spaces for the field.  Consider the following examples, where the Long variable is 12345. If FormatString = %8d the result is (space)(space)(space)12345If FormatString = %-8d the result is 12345(space)(space)(space)If FormatString = %08d the result is 00012345If FormatString = %-08d the result is 12345000 Note that multiple format specifiers are not allowed.
    Must be one of following options: %d (Signed decimal integer (same as i)), %i (Signed decimal integer (same as d)), %u (Unsigned decimal integer), %x (Hexadecimal integer, lower case), %X (Hexadecimal integer, upper case), %o (Octal (base 8)), %b (Binary (base 2))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"FormatLong({LongVar},{FormatString})"


def FormatLongLong(
    LongLongVar: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatlonglong.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/formatlonglong.htm).

    Args:
        LongLongVar(1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): LongLongVar(1 (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"FormatLongLong({LongLongVar})"


def FTPClient(
    IPAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    User: Constant,
    Password: Constant,
    LocalFileName: Constant,
    RemoteFileName: Constant,
    PutGetOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "24",
        "25",
        "26",
        "27",
        "28",
    ],
    NumRecsTimeIntoInterval: Constant,
    Interval: Literal["0", ">=0", ">0", "<0", "0"],
    Units: Constant,
    FileOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
    ],
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ftpclient.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ftpclient.htm).

                The FTPClient function opens an FTP socket to a remote machine. The remote machine can be either a datalogger or a computer, but it must have an FTP server running. FTPClient can be used to monitor the success/failure of transferring a file.
    Most commonly, FTPClient is used to send data or image files from the datalogger’s local file system to a remote FTP server hosted by a computer or another datalogger. These files are commonly created by TableFile, custom File I/O routines, or collected from a Campbell Scientific camera. FTPClient can also be used to manage these files.
    FTPClient can be used to stream data directly from a data table to the server, eliminating the need to first write the data to a local file prior to transfer. This is accomplished using the last four parameters, which are optional and used only for this streaming functionality.
    NOTE:  When multiple IP interfaces (for example, Ethernet port, CS I/O port, Wi-Fi, PPP) are active, the IPRoute() instruction is used to direct outgoing IP traffic.
    The datalogger waits up to 75 seconds for FTPClient to return a result; thus, it can hold up the scan. Because of this, it should generally be run in a SlowSequence so that it does not hold up the main program scan while waiting for the transaction to be completed.
    This function returns -1 if successful, 0 if it fails, or -2 if execution did not occur when the instruction was called (for instance, when using the optional parameters to stream data from a table and the number of records or time into interval conditions are not met).
    For more information on using the FTPClient instruction for streaming data see the Data Streaming application note. For more information on troublshooting, see the FTP Troubleshooting application note.

    Args:
                    IPAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): The IP address for the device you are trying to send a file to or retrieve a file from. This is a string expression, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255) or a fully-qualified domain name (for example, "computer-name.domain.com"). FTP URL syntax (for example, ftp://server.com) should not be used. The default port number used is 21. If a different port number is required, follow the IPAddress with a colon and enter the port number (for example, 192.168.3.45:35).

            User (Constant): The User Name that must be entered to gain access to the FTP functions of the remote device.

            Password (Constant): The password that must be entered to gain access to the FTP functions of the remote device.

            LocalFileName (Constant): A string expression containing a local file name, comma separated list of local file names, data table name, or data table field name. Multiple files can be specified by separating their names with a comma (note that you cannot use multiple file names when streaming data). Make sure to include the file directory along with the file name. To stream all data tables, specify the optional parameters necessary for streaming and specifiy the source parameter as an empty string (“”). If a directory listing is retrieved with this function, LocalFileName will specify a file name in which to write the results, or an array in which to write the results, where the name of each file will be written into its own array element. CR/LF characters are replaced with null. If an array element exists beyond the number of files listed, a null is written into that element. If retrieving a file, this parameter is the filename to use when writing the file on the datalogger’s drive; alternately, if the parameter is a string variable that does not specify a drive (i.e., the fourth character is not “:”), the results will be written to the variable directly. If using the delete action, this parameter will often be an empty string (“”). If using the rename action, this parameter should contain the name of the remote file(s) to be renamed.  If streaming data directly from a data table or table field to a file on the FTP server, this parameter should specify the table name (for example, “TableOne”) or table field name (for example, “TableOne.BattV_Min”) that will be used as the data source. Note that when specifying a fieldname, if Tablename.Fieldname is a variable, the length of the Tablename.fieldname is limited to 63 characters.

            RemoteFileName (Constant): This parameter specifies the remote file name or a comma-separated list of file names for sending, retrieving, or deleting data, or for listing directory contents. For renaming, it indicates the new file name(s). Include the directory and file name (e.g., “/Data/file01.dat”). Multiple files should be listed as “file01.dat,/Data/file02.dat”. Use forward slashes (/) for directories, suitable for all operating systems. If no directory is specified, the root directory is assumed. The specified directory must pre-exist on the server. To add a timestamp to the remote file name, include this exact string of characters “YYYY-MM-DD_HH-MM-SS” in the RemoteFileName parameter (For example “tabledata_YYYY-MM-DD_HH-MM-SS.xml”). When the file is written, a timestamp will be put into the remote file name in place of “YYYY-MM-DD_HH-MM-SS”. If streaming data, the timestamp of the first record streamed is used in the remote file name. If data streaming is not used, the current datalogger clock time is used.  Other methods to include a timestamp in the remote file name involve using string concatenation to insert the return value of tablename.timestamp(5, 1) into the file name. See Example Program 1 for an example of including a timestamp in the remote file name using this method. When streaming data, the remote file name is automatically appended with an incrementing file number and a “.dat” file extension unless 1000 is added to the format option. For example, if the FileOption is 8 (TOA5, Header, Timestamp, Record#)  and 1000 is added (1008),  the data logger will not automatically append the incrementing number or “.dat” extension to the uploaded file.  Also, if the RemoteFileName parameter contains the exact string “YYYY-MM-DD_HH-MM-SS” for the addition of a timestamp, as described  above, the incrementing file number and “.dat” extension will not automatically be appended.  If the automatically appended incrementing file number and “.dat” extension are desired along with having a timestamp in the filename, use a method other than “YYYY-MM-DD_HH-MM-SS”, like the concatenation method in Example Program 1.

            PutGetOption (Variable): Determines 1) whether the datalogger will send or retrieve a file, 2) whether active or passive mode is used, and 3) whether FTP, FTPS (FTP via TLS), or SFTP ( FTP via SSH) is used. NOTE:  Passive mode is not applicable with SFTP.  Active vs. Passive mode In active mode, the client initiates contact with the server and the server must connect back to the client on the port specified by the client. This response from the server may be blocked by the client’s firewall. Passive mode resolves the issue of firewalls by having the client issue a PASV command that opens two random unprivileged ports to the server. In response to the PASV command from the client, the server sends a random port number back to the client. Finally, the client initiates a connection from the server via the port specified by the server. Not all servers support passive mode. FTPS  The default server port for implicit FTPS is 990. Otherwise, explicit security is used.   Implicit security automatically begins with an SSL connection as soon as the FTP client connects to an FTP server, whereas with explicit security, the client and server negotiate the level of protection used. SFTP The default server port  for SFTP is 22. In order to utilize SFTP, an SFTP Public Key and SFTP Private Key must be set in the datalogger's advanced settings (see the Settings Editor). If these two settings are set and if the server advertises that it can authenticate with a Public/Private key pair, then authentication is attempted using this setting along with the user name and password parameters. Note a limitation with this: if more than one SFTP server is used in the program and if they require the public/private key pair authentication method, then the same public/private key pair must work for each server. Right-click the parameter to display a list with the options: FTPS(TLS) or SFTP(SSH)  requires an adjustment to the memory used by communication.  A new pool of memory of size 53684 bytes is required.  The PutGetOption governs this.  If this option is variable, that is, not known at compile time, then enough memory is allocated to accommodate either TLS or SFTP.
      Must be one of following options: 0 (FTP - Store file to server, active mode), 1 (FTP - Retrieve file from server, active mode), 2 (FTP - Store file to server, passive mode), 3 (FTP - Retrieve file from server, passive mode), 4 (FTP - Delete file on server), 5 (FTP - Rename file on server), 6 (FTP - Directory listing, active mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the FTP LIST command. -6  returns file names only (similar to NLST)), 7 (FTP - Directory listing, passive mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the FTP LIST command.-7 returns file names only (similar to NLST)), 8 (FTP - Append data to end of file, active mode (creates a file if it does not already exist)), 9 (FTP - Append data to end of file, passive mode (creates a file if it does not already exist)), 10 (FTPS - Store file to server, active mode), 11 (FTPS - Retrieve file from server, active mode), 12 (FTPS - Store file to server, passive mode), 13 (FTPS - Retrieve file from server, passive mode), 14 (FTPS - Delete file on server), 15 (FTPS - Rename file on server), 16 (FTPS - Directory listing, active mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the FTPS LIST command. -16  returns file names only (similar to NLST)), 17 (FTPS - Directory listing, passive mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the FTPS LIST command.-17 returns file names only (similar to NLST)), 18 (FTPS - Append data to end of file, active mode (creates a file if it does not already exist)), 19 (FTPS - Append data to end of file, passive mode (creates a file if it does not already exist)), 20 (SFTP - Store file to server, active mode), 21 (SFTP - Retrieve file from server, active mode), 24 (SFTP - Delete file on server), 25 (SFTP - Rename file on server), 26 (SFTP - Directory listing, active mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the SFTP LIST command. -26  returns file names only (similar to NLST)), 27 (SFTP - Directory listing, passive mode. Returns a directory listing (instead of a file) into LocalFileName. The path to the directory of the FTP server from which to return the directory listing is specified in the RemoteFileName parameter. This is similar to the SFTP LIST command.-27 returns file names only (similar to NLST)), 28 (SFTP - Append data to end of file, active mode (creates a file if it does not already exist))

            NumRecs/TimeIntoInterval (Constant): Used only when streaming data directly from a data table or data table field. NOTE: For more details, see the Data Streaming document.  If Interval is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unsent records should be written to file on the server.  If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be written to file on the server. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will be written to file on the server each time the function is called.

            Interval (Constant): Used only when streaming data directly from a data table or data table field. If greater than 0, the Interval parameter determines the interval at which previously unsent data will be written to file. If equal to zero, the NumRecs parameter will control when data is written. A negative Interval will cause the datalogger to write the most recent records within this time interval each time the function is called. The datalogger keeps track of the last record sent within the FTPClient instruction. This information is maintained even through power-downs, as long at the data table in datalogger memory is intact.
      Must be one of following options: 0 (0), >=0 (>0), >0 (0), <0 (0), 0 (<0)

            Units (Constant): Used only when streaming data directly from a data table or data table field. It is used to specify the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days.

            FileOption (Constant): Used only when streaming data directly from a data table or data table field. It specifies the format used when writing data to the server. The file created on the server will automatically be appended with an incrementing file number and a “.dat” file extension. If 1000 is added to the format (for example, 1008), the datalogger will not automatically append the incrementing number or “.dat” extension to the uploaded file. If the FileOption parameter is entered as a negative value (for example, -1008), if a file of the same name is already present, no additional header will be appended to the file. Instead, only new records are appended so that data records are contiguous. Options 0, 8, 16, and 32 correspond to Campbell Scientific's defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"FTPClient({IPAddress},{User},{Password},{LocalFileName},{RemoteFileName},{PutGetOption},{NumRecsTimeIntoInterval},{Interval},{Units},{FileOption},{TimeOut})"


def GetRecord(
    Dest: Array,
    TableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RecsBack: Variable | Constant,
    DataFormat: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getrecord.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getrecord.htm).

                If a time of minimum or maximum is returned by the GetRecord instruction, the time is reflected in seconds since 1990. A NAN is returned if the datalogger attempts to retrieve a record that does not exist. A record can also be retrieved based on time by entering a negative value in the RecsBack parameter.
    Records cannot be retrieved from the Public or TableInfo tables.

    Args:
                    Dest (Array): The destination variable array in which to store the fields of the record. The array must be dimensioned large enough to hold all of the fields in the record. However, if the Dest parameter is a single-dimensioned variable formatted as a string, all data values will be stored in the one variable. The data values will be separated by commas and the string will have a <crlf> termination. The record's time stamp will be the first data value. All time stamps and variables declared as strings will be enclosed in quotes. Time stamps will be displayed in International ISO format "yyyy-mm-dd hh:mm:ss" with a fractional seconds if present. Right-click the parameter to display a list of defined variables.

            TableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the DataTable from which to retrieve the record. Records cannot be retrieved from the Public or TableInfo tables. The TableName can reference a variable name of type String that will hold the name of the table at run-time.

            RecsBack (Variable | Constant): The number of records to back up and retrieve data (the most recent record is considered record 1). A negative number can be entered for the RecsBack parameter to specify the time, in seconds since 1990, for the record to be retrieved (refer to the SecsSince1990 example program for this usage) For additional data table access functionality, see Data Table Access.

            DataFormat (Integer): The DataFormat parameter is used to define the format of the data sent to the transmitter (GOESData) or retrieved from the datalogger (GetRecord). A numeric value is entered: For DataFormat options 1, 4, 5, 6, 7, and 8, if the data being transmitted is formatted as a string, the datalogger will send the string. For DataFormat options 0, 2, and 3, the datalogger will search for numeric values, convert them to the appropriate format, and send them to the transmitter.
      Must be one of following options: 0 (Campbell ScientificFP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. data; 3 bytes per data point.), 1 (Floating point ASCII; 7 bytes per data point.), 2 (18-bit binary integer; 3 bytes per data point, numbers to the right of the decimal are truncated.), 3 (RAWS7; 7 data points:

    1: Total rainfall in inches, format = xx.xxx
    2: Wind speed MPH, format = xxx
    3: Vector average wind direction in degrees, format = xxx
    4: Air temperature in degrees F, format = xxx
    5: RH percentage, format = xxx
    6: Fuel stick temperature in degrees F, format = xxx
    7: Battery voltage in VDC, format = xx.x), 4 (Fixed decimal ASCII xxx.x), 5 (Fixed decimal ASCII xx.xx), 6 (Fixed decimal ASCII x.xxx), 7 (Fixed decimal ASCII xxx), 8 (Fixed decimal ASCII xxxxx)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GetRecord({Dest},{TableName},{RecsBack},{DataFormat})"


def GetDataRecord(
    ResultCode: Literal[
        "0",
        "-1",
        "-7",
        "-8",
        "-9",
        "-10",
        "-16",
        "-17",
        "-18",
        "-20",
        "-21",
        "-22",
        "-27",
        "1,",
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    Tries: Variable | Constant,
    TableNo: Constant,
    DestTableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    MaxRecords: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getdatarecord.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getdatarecord.htm).

                The table definitions for the local and remote dataloggers must be identical (this includes field order, table size, and the declaration of units), unless 32768 (&H8000) is added to the TableNo parameter. For example, by adding 32768, table 1 is specified as 32769, table 2 is 32770, etc. Adding 32768 to the TableNo parameter means that the number of fields, and the data types must be the same, but the table names, number of records in the tables, units, and field names do not. In most cases, it is recommended to add 32768 to the TableNo parameter to avoid a table definitions mismatch.
    If the records retrieved from a remote are from an interval driven, 32768 (&H8000) must be added to the TableNo parameter.
    Beginning with OS 2, DataInterval for a GetDataRecord destination table is not required to be integrally divisible by the program scan interval. This results in correct timestamps in the case that the remote datalogger is storing data faster than the local program with GetDataRecord() maxrecords > 1. For example, if an aggregator datalogger is running a main scan of one minute, and a remote datalogger is storing measurements every 10 seconds, then in order get all of the most recent records from the remote datalogger, the DataInterval of the GetDataRecord() destination table would be 10 seconds and the maxrecords parameter of GetDataRecord() would be 6.
    When retrieving records from a CR200(X), DataInterval should be omitted or the Lapses parameter of DataInterval should be set to 0 so that the local datalogger is set up to store a timestamp with each record (since the CR200(X) stores a timestamp with each record).
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).
    This instruction includes a call to the data table (CallTable) defined by the DestTableName parameter.
    NOTE: CR10XPB, CR23XPB, and CR510PB dataloggers do not respond to a GetDataRecord request from another datalogger.When getting a data record from a CR200(X), there will always be a mismatch in the table signatures. Thus, 32768 must be added to the TableNo parameter.To match the data itself between a CR1000 and CR200, define all the table elements in the CR1000 as IEEE4 and add a "dummy" variable that equals to 0 in the CR200 as the first variable. This dummy variable is a placeholder for the last four bytes of the time stamp.The timestamp stored with the retrieved records is the timestamp of the remote datalogger.

    Args:
                    ResultCode (Variable | Constant | Expression | Array | Integer | ConstantInteger): The ResultCode  is the variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -7 (Table definition mismatch; signatures do not match.), -8 (No records in the remote datalogger, no new records in the remote datalogger, or record length in the remote table is smaller than that in the local table.), -9 (Record length in the remote table is larger than that in the local table. The error will also occur if one datalogger’s table is interval driven, and the other datalogger’s table is non-interval driven (i.e., event driven).), -10 (Local DataTable() not triggered for output.), -16 (Table name and/or field name not present in the remote datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the sending datalogger is not dimensioned large enough to accommodate the values to be sent or array in the receiving datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.  When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node The degree to which the result of a measurement, calculation, or specification conforms to the correct value or a standard. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network. When a leaf node is set to autodiscover it will attempt to communicate any time it is aware of a neighbor that is a router.  This will result in an incrementing result code if that neighbor router is not aware of the destination address. If the leaf node's neighbor is not a router or if the leaf node has no neighbors, communication will not be attempted and a -21 is returned.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.  NOTE: In RF400 communication, the timeout should be sufficiently long to avoid collisions (the default of 0 should accomplish this, or use at least 500 ms).

            Tries (Variable | Constant): The number of times the local datalogger should attempt to retrieve the record from the remote datalogger before timing out and executing the next instruction.

            TableNo (Constant): Specifies the table in the remote datalogger from which a record will be retrieved (GetDataRecord) or accepted (AcceptDataRecords). This is a numeric value that represents the data tables in the order they are declared in the program (for example, the first data table declared in the program is 1, the second data table declared in the program is 2, etc.).  If 32768 (&H8000) is added to the TableNo parameter, the table definitions in both the local and remote dataloggers do not need to be identical. As an example, to accomplish this for table 1, you can enter 32769, or 1+32768, or 1+&H8000. Table 2 would be 32770, etc.

            DestTableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the data table in the local datalogger where the incoming record(s) should be stored. Right click the parameter for a list of tables that have been declared in the program.

            MaxRecords (Constant): Optional parameter.  If MaxRecords is set to a value less than 0, GetDataRecord will collect up to MaxRecords of uncollected data, beginning with the oldest missing record. If MaxRecords is greater than 0, the instruction will collect up to MaxRecords of uncollected data starting with the most recent record (and then going back and filling in the gaps or "holes"). The default value is 1, which collects only the most recent record. 1 is assumed if the parameter is not used. By default, GetDataRecord retrieves only the most recent record stored in a data table. The MaxRecords parameter is used to retrieve older records that have not yet been retrieved. NOTE: If the parameter is some value other than 1, two exchanges will take place. The first is to determine the current record number and the second is to retrieve the data.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GetDataRecord({ResultCode},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{Tries},{TableNo},{DestTableName},{MaxRecords})"


def GetFile(
    Result: Literal[
        "0",
        "-1",
        "-2",
        "-9",
        "-14",
        "-16",
        "-17",
        "-18",
        "-20",
        "-21",
        "-22",
        "-25",
        "-26",
        "-27",
        "1,",
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    LocalFile: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RemoteFile: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getfile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getfile.htm).

                The GetFile instruction is used to retrieve a file stored on a remote datalogger. The name of the device or directory must also be included (for example, "USR:file"). PakBus datalogger device options are: CPU: = datalogger CPU drive; SSD: = datalogger SSD drive; CRD: = memory card; USB: = SC115 or external USB drive; CS9: = SC115; or USR: = user defined drive. The remote datalogger may be using TableFile, FileWrite, or some other means to store the file.
    NOTE: In GRANITE Datalogger Modules, the USB device is an external USB drive and the CS9 device is an SC115. In all other dataloggers, the USB device is the SC115.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a  CR200 or an AVW200).

    Args:
                    Result (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -2 (Illegal drive, cannot open the file in the remote, or destination drive full.), -9 (Wrong fragment sent to the remote.), -14 (Too many files opened in the remote.), -16 (Table name and/or field name not present in the remote datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the sending datalogger is not dimensioned large enough to accommodate the values to be sent or array in the receiving datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -25 (Cannot seek in the file.), -26 (Cannot open the local file.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. If  a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node The degree to which the result of a measurement, calculation, or specification conforms to the correct value or a standard. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network. When a leaf node is set to autodiscover it will attempt to communicate any time it is aware of a neighbor that is a router.  This will result in an incrementing result code if that neighbor router is not aware of the destination address. If the leaf node's neighbor is not a router or if the leaf node has no neighbors, communication will not be attempted and a -21 is returned.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.  NOTE: In RF400 communication, the timeout should be sufficiently long to avoid collisions (the default of 0 should accomplish this, or use at least 500 ms).

            LocalFile (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Device and Filename, enclosed in quotes, where the retrieved file should be stored ("Device:FileName"). The device choices are CPU, CRD (memory card), USR (user-defined drive), or USB (SC115).

            RemoteFile (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Device and Filename, enclosed in quotes, of the file that is retrieved from the remote datalogger ("Device:Filename").  PakBus datalogger device options are: CPU: = datalogger CPU drive; CRD: = memory card; USB: = SC115 or external USB drive; CS9: = SC115; or USR: = user defined drive.  NOTE: In GRANITE Datalogger Modules, the USB device is an external USB drive and the CS9 device is an SC115. In all other dataloggers, the USB device is the SC115. You will likely need some way to manage the files that are retrieved from the remote datalogger. Otherwise, these files may fill up the drive on which they are being stored and subsequent files will not be saved. You can do this programmatically using the FileManage instruction, or you can set up a type of ring memory using the Files Manager setting in the datalogger's status table. The Files Manager setting lets you define the maximum number of files that are kept from a specific PakBus device, with the oldest file being deleted prior to writing the new file once that maximum is reached.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GetFile({Result},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{LocalFile},{RemoteFile})"


def GetVariables(
    ResultCode: Literal[
        "0", "-1", "-16", "-17", "-18", "-20", "-21", "-22", "-27", "1,"
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    TableName: Variable,
    Fieldname: Variable,
    Variable: Variable | Array,
    Swath: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getvariables.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/getvariables.htm).

                The TableName and FieldName parameters, along with the Swath parameter, are used to determine what values are retrieved from the source datalogger. The first value to be retrieved is defined with TableName and Fieldname, and the number of values is specified by Swath. If Swath is greater than 1, Fieldname must be an array and Variable must be an array. The most recent variable(s) stored in the table are retrieved.
    GetVariables can also be used to get values from data stored into LoggerNet's data cache. The device name used in LoggerNet's network map is used to specify which datalogger the values should be retrieved from. The syntax used is DeviceName.TableName in the TableName argument of the GetVariables instruction.
    If security is enabled in the source datalogger, it must be unlocked to level 3 for this instruction to be successful. The source and destination dataloggers must have unique PakBus addresses.
    Note that multiple GetVariable instructions in a program will increase the time for the program to execute its scan. All GetVariable instructions are handled with one communication task and, thus, cannot be processed concurrently.
    If PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    ResultCode (Variable): The variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -16 (Table name and/or field name not present in the source datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the source datalogger is not dimensioned large enough to accommodate the values to be sent or array in the destination datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If  a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.  When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. If 0 is used for the ComPort in a datalogger not set up as a router and a neighbor address is specified, the datalogger will use that PakBus device as a router.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node The degree to which the result of a measurement, calculation, or specification conforms to the correct value or a standard. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network. When a leaf node is set to autodiscover it will attempt to communicate any time it is aware of a neighbor that is a router.  This will result in an incrementing result code if that neighbor router is not aware of the destination address. If the leaf node's neighbor is not a router or if the leaf node has no neighbors, communication will not be attempted and a -21 is returned.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.  NOTE: In RF400 communication, the timeout should be sufficiently long to avoid collisions (the default of 0 should accomplish this, or use at least 500 ms).

            "TableName" (Variable): The name of the DataTable which contains the values to retrieve (GetVariables) or the table to which values will be sent (SendVariables). TableName must be entered as a string (enclosed in quotes). NOTE: Values can only be sent to or retrieved from an input location in an Edlog-programmed PakBus datalogger (CR10XPB, CR510PB, or CR23XPB). The TableName to be used is "Inlocs" (or "Public") and the FieldName is the input location label.

            "Fieldname" (Variable): Used to specify the name of the variable(s) in the destination datalogger for (SendVariables) or retrieve from (GetVariables). If Swath is greater than 1, FieldName must be an array. FieldName must be entered as a string (enclosed in quotes). If the variable in the source datalogger has been assigned an Alias, the alias must be used for Fieldname unless the value requested is from the Public table. In this case, either the original name or the Alias name can be used (the exception is CR200 series dataloggers; they require that the Alias be used). If the requested Fieldname is from an output table of a CRBasic datalogger, and the output is something other than a sample, the output type suffix must be added to the variable name (for example, Temp_Avg). For more information, see CRBasic Program Structure.

            Variable (Variable | Array): GetVariable: The array in which the variable(s) retrieved from the destination datalogger should be stored. SendVariable: The variable(s) that should be sent to the destination datalogger.  The Variable parameter must be dimensioned equal to or greater than the Swath parameter.  For the GetVariables instruction, the Variable parameter must be dimensioned equal to or greater than the Swath retrieved from the source datalogger.

            Swath (Constant): The number of variables that will be retrieved from or sent to the datalogger. NOTE: Only Public variables can be retrieved from CR2xx dataloggers. SendData can be used to push data from a CR2xx to another datalogger. Only input locations can be retrieved from Edlog-programmed PakBus dataloggers (CR10XPB, CR510PB, or CR23XPB). The TableName to use is "Inlocs" (or "Public") and the FieldName is the input location label. The TableName and FieldName are case sensitive when retrieving values from these datalogger types.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GetVariables({ResultCode},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{TableName},{Fieldname},{Variable},{Swath})"


def GOESData(
    ResultCode: Literal[
        "0",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "-11",
        "-12",
        "-13",
        "-14",
        "-15",
        "-16",
        "-17",
        "-18",
        "-19",
        "-20",
        "-21",
        "-22",
    ],
    Table: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TableOption: Literal["0", "1", "x"],
    BufferControl: Literal["0", "1", "2", "3", "9"],
    DataFormat: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesdata.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesdata.htm).

                The GOESData instruction resides within the body of the main program.

    Args:
                    ResultCode (Variable | Array): The Variable in which to store the results indicating the success of the program instruction. For the GOESData and GOESSetup instructions, this array is dimensioned to 1. For the GOESStatus instruction, the size of the array required will depend upon the option chosen for the StatusCommand. Right-click the parameter to display a list of defined variables.
      Must be one of following options: 0 (Command executed successfully.), 2 (Timed out waiting for STX character from transmitter after SDC addressing.), 3 (Wrong character received after SDC addressing), 4 (Something other than ACK returned when select data buffer command was executed.), 5 (Timed out waiting for ACK.), 6 (Port not available; GOES not attached.), 7 (ACK not returned following data append or overwrite command.), -11 (Buffer control error.), -12 (Message window error.), -13 (Channel error.), -14 (Baud error.), -15 (RCount error.), -16 (Illegal data format.), -17 (Data format 0 or 1 was chosen, but table values were not FP2 or ASCII.), -18 (STInterval error.), -19 (STOffset error.), -20 (RInterval error.), -21 (Platform ID error.), -22 (Transmitter not set up.)

            Table (Variable | Constant | Expression | Array | Integer | ConstantInteger): The data table from which record(s) should be transmitted.

            TableOption (Integer): Indicates which records should be sent from the data table. A numeric value is entered. Right-click to display a list. If there are fewer records than the number specified, all available records will be sent.
      Must be one of following options: 0 (Send all records since last execution.), 1 (Send only the most recent record stored in the table.), x (Send a specified number of records (enter a value for x).)

            BufferControl (Integer): Used to specify which buffer should be used (random or self-timed) and whether data should be overwritten or appended to the existing data. Data stored in the self-timed buffer is transmitted only during a predetermined time frame. Data is erased from the transmitter's buffer after each transmission.  Data in the random buffer is transmitted immediately after a threshold has been exceeded. The transmission is randomly repeated to insure it is received. Data in the random buffer must be erased using buffer control, code 9, after random transmissions are finished. A numeric value is entered for this parameter. Right-click to display a list. The datalogger orders the data from the newest to the oldest. If oldest to newest is needed, execute the instruction in Append mode each time data is written to the data record.
      Must be one of following options: 0 (Append to self-timed buffer.), 1 (Overwrite self-timed buffer.), 2 (Append to random buffer.), 3 (Overwrite random buffer.), 9 (Clear random buffer)

            DataFormat (Integer): The DataFormat parameter is used to define the format of the data sent to the transmitter (GOESData) or retrieved from the datalogger (GetRecord). A numeric value is entered: For DataFormat options 1, 4, 5, 6, 7, and 8, if the data being transmitted is formatted as a string, the datalogger will send the string. For DataFormat options 0, 2, and 3, the datalogger will search for numeric values, convert them to the appropriate format, and send them to the transmitter. NOTE: When the datalogger sends a command, further processing tasks are performed only after a response has been received from the GOES Transmitter.The FieldNames instruction can be used to support SHEF PE codes and insert printable characters within the data set. For more information, see Using FieldNames for SHEF PE Codes. Related Topics
      Must be one of following options: 0 (Campbell ScientificFP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. data; 3 bytes per data point.), 1 (Floating point ASCII; 7 bytes per data point.), 2 (18-bit binary integer; 3 bytes per data point, numbers to the right of the decimal are truncated.), 3 (RAWS7; 7 data points:

    1: Total rainfall in inches, format = xx.xxx
    2: Wind speed MPH, format = xxx
    3: Vector average wind direction in degrees, format = xxx
    4: Air temperature in degrees F, format = xxx
    5: RH percentage, format = xxx
    6: Fuel stick temperature in degrees F, format = xxx
    7: Battery voltage in VDC, format = xx.x), 4 (Fixed decimal ASCII xxx.x), 5 (Fixed decimal ASCII xx.xx), 6 (Fixed decimal ASCII x.xxx), 7 (Fixed decimal ASCII xxx), 8 (Fixed decimal ASCII xxxxx)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GOESData({ResultCode},{Table},{TableOption},{BufferControl},{DataFormat})"


def GOESStatus(
    ResultCode: Literal[
        "0",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "-11",
        "-12",
        "-13",
        "-14",
        "-15",
        "-16",
        "-17",
        "-18",
        "-19",
        "-20",
        "-21",
        "-22",
    ],
    StatusCommand: Literal[
        "0x00",
        "0x01",
        "0x02",
        "0x03",
        "0x04",
        "0x05",
        "0x06",
        "0x10",
        "0x11",
        "0x12",
        "0x13",
        "0x14",
        "0x15",
        "0x16",
        "0x1F",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesstatus.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesstatus.htm).

    Args:
                  ResultCode (Variable | Array): The Variable in which to store the results indicating the success of the program instruction. For the GOESData and GOESSetup instructions, this array is dimensioned to 1. For the GOESStatus instruction, the size of the array required will depend upon the option chosen for the StatusCommand. Right-click the parameter to display a list of defined variables.
    Must be one of following options: 0 (Command executed successfully.), 2 (Timed out waiting for STX character from transmitter after SDC addressing.), 3 (Wrong character received after SDC addressing), 4 (Something other than ACK returned when select data buffer command was executed.), 5 (Timed out waiting for ACK.), 6 (Port not available; GOES not attached.), 7 (ACK not returned following data append or overwrite command.), -11 (Buffer control error.), -12 (Message window error.), -13 (Channel error.), -14 (Baud error.), -15 (RCount error.), -16 (Illegal data format.), -17 (Data format 0 or 1 was chosen, but table values were not FP2 or ASCII.), -18 (STInterval error.), -19 (STOffset error.), -20 (RInterval error.), -21 (Platform ID error.), -22 (Transmitter not set up.)

          StatusCommand (Variable | Constant | Expression | Array | Integer | ConstantInteger): Integer used to indicate the type of information requested from the transmitter. One of the following numeric codes are entered: Code 0 = Read TimeCode 1 = StatusCode 2 = Last Message StatusCode 3 = Transmit Random MessageCode 4 = Read Error RegisterCode 5 = Reset Error RegisterCode 6 = Return Transmitter to Online Mode The codes then return a response of: Code 0 = Read Time This option requires that the ResultCode array be dimensioned to 4. Results returned are: (1) Command Code Result(2) Hours(3) Minutes(4) Seconds (time reflected in GMT) For returned response codes, see Command Code Results.  Code 1 = Status This option requires that the ResultCode array be dimensioned to 13. Results returned are: (1) Command Code Result(2) Number of bytes in self-timed buffer(3) Days to next self-timed message(4) Hours to next self-timed message(5) Minutes to next self-timed message(6) Seconds to next self-timed message(7) Number of bytes in random buffer(8) Hours to next random message(9) Minutes to next random message(10) Seconds to next random message(11) Fail safe position (1 indicates transmitter disabled due to fail-safe)(12) Power supply (in tenths of volts, under 1A load)(13) Average GPS acquisition time (tens of seconds) For returned response codes, see Command Code Results.  Code 2 = Last Message Status This option requires that the ResultCode array be dimensioned to 14. Results returned are: (1) Command Code Result(2) Message type (self-timed or random)(3) Number of bytes in message(4) Forward RF power (tenths of Watts)(5) Reflected RF power (tenths of Watts)(6) Power supply (tenths of volts, under full load)(7) GPS acquisition time (tens of seconds)(8) Oscillator drift (signed, hundreds of Hz)(9) Latitude degrees(10) Latitude minutes(11) Latitude seconds(12) Longitude degrees(13) Longitude minutes(14) Longitude seconds For returned response codes, see Command Code Results.  Code 3 = Transmit Random Message This option requires that the ResultCode array be dimensioned to 1. The only result returned is the Command Code Result. Code 4 = Read Error Register This option requires that the ResultCode array be dimensioned to 10. Results returned are: (1) Command Code Result(2) Number of errors(3) Command(4) Error Code(5) Command(6) Error Code(7) Command(8) Error Code(9) Command(10) Error Code Error Codes Nine registers are used to store error information. Up to 255 errors are stored, along with the command that was issued when the error occurred and a code specific to the type of the error. Internal fault codes are also stored. The error is transmitted to the datalogger as a hexadecimal value; the datalogger converts this to a decimal value and stores it in the array. For returned response codes, see Command Code Results.  Code 5 = Reset Error Register This option requires that the ResultCode array be dimensioned to 1. The only result returned is the Command Code Result.  Code 6 = Return Transmitter to Online Mode This option returns the SAT HDR GOES to an online mode. It is typically used after a forced random transmission (StatusCommand 3). This option requires that the ResultCode array be dimensioned to 1. The only result returned is the Command Code Result.  NOTE: When the datalogger sends a command, further processing tasks will be performed only after a response has been received from the GOES Transmitter. Related Topics
    Must be one of following options: 0x00 (00), 0x01 (01), 0x02 (02), 0x03 (03), 0x04 (04), 0x05 (05), 0x06 (06), 0x10 (16), 0x11 (17), 0x12 (18), 0x13 (19), 0x14 (20), 0x15 (21), 0x16 (22), 0x1F (31)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"GOESStatus({ResultCode},{StatusCommand})"


def GOESSetup(
    ResultCode: Literal[
        "0",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "-11",
        "-12",
        "-13",
        "-14",
        "-15",
        "-16",
        "-17",
        "-18",
        "-19",
        "-20",
        "-21",
        "-22",
    ],
    PlatformID: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    MsgWindow: Integer,
    STChan: Integer,
    STBaud: Integer,
    RChan: Integer,
    RBaud: Integer,
    STInterval: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    STOffset: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    RInterval: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goessetup.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goessetup.htm).

              Since the purpose of this instruction is to set up the transmitter for communication, it only has to be run once within the datalogger program. Information for all parameters in this instruction is supplied by NESDIS.

    Args:
                  ResultCode (Variable | Array): The Variable in which to store the results indicating the success of the program instruction. For the GOESData and GOESSetup instructions, this array is dimensioned to 1. For the GOESStatus instruction, the size of the array required will depend upon the option chosen for the StatusCommand. Right-click the parameter to display a list of defined variables.
    Must be one of following options: 0 (Command executed successfully.), 2 (Timed out waiting for STX character from transmitter after SDC addressing.), 3 (Wrong character received after SDC addressing), 4 (Something other than ACK returned when select data buffer command was executed.), 5 (Timed out waiting for ACK.), 6 (Port not available; GOES not attached.), 7 (ACK not returned following data append or overwrite command.), -11 (Buffer control error.), -12 (Message window error.), -13 (Channel error.), -14 (Baud error.), -15 (RCount error.), -16 (Illegal data format.), -17 (Data format 0 or 1 was chosen, but table values were not FP2 or ASCII.), -18 (STInterval error.), -19 (STOffset error.), -20 (RInterval error.), -21 (Platform ID error.), -22 (Transmitter not set up.)

          PlatformID (Variable | Constant | Expression | Array | Integer | ConstantInteger): The 8-digit hexadecimal identification number assigned by NESDIS. Hexadecimal numbers are entered into CRBasic by preceding them with &H.

          MsgWindow (Integer): Used to indicate the assigned window of transmission for self-timed transmissions (i.e., how long the transmitter should stay online transmitting data). This value is in seconds; valid entries are 1 to 120 seconds.

          STChan (Integer): The channel for the self-timed transmission assigned by NESDIS. Valid channel numbers are between 0 and 266 for 100 and 300 baud (STBaud parameter) and 0 and 133 for 1200 baud. If 0 is entered for this parameter, self-timed transmissions are disabled.

          STBaud (Integer): The baud rate The rate at which data is transmitted. at which self-timed transmissions should take place (100, 300, or 1200 baud). The baud rate must match your NESDIS channel assignment. Right-click this parameter to display a drop-down list of valid options.

          RChan (Integer): The channel for the random transmission assigned by NESDIS. Valid channel numbers are between 0 and 266 for 100 and 300 baud (RBaud parameter) and 0 and 133 for 1200 baud. If 0 is entered for this parameter, random transmissions are disabled.

          RBaud (Integer): The baud rate The rate at which data is transmitted. at which random transmissions should take place (100, 300, or 1200 baud). The baud rate must match your NESDIS channel assignment. Right-click this parameter to display a drop-down list of valid options.

          STInterval (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to define the time between self-timed transmissions. The value is a constant string entered in the format of "Days_Hours_Minutes_Seconds". Typically the assigned interval is in hours, so the days, minutes and seconds parameters are left at 0 (example, "0_1_0_0" sets up an hourly interval). Maximum interval is 14 days; minimum interval is 5 minutes.

          STOffset (Variable | Constant | Expression | Array | Integer | ConstantInteger): The time after midnight for the first self-timed transmission. The value is a constant string entered in the format of "Hours_Minutes_Seconds". Typically, only the Hours_Minutes parameters are used and Seconds is left at 0, unless the window of transmission is less than 60 seconds. Maximum offset is 23:59:59. This parameter can be set to 0 for no offset.

          RInterval (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to define the average time between random transmissions. The value is a constant string entered in the format of "Hours_Minutes_Seconds". Typically the assigned interval is in hours, so the minutes and seconds parameters are left at 0 (example, "1_0_0" sets up an hourly interval). Maximum interval is 24 hours; minimum interval is 5 minutes. Related Topics

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"GOESSetup({ResultCode},{PlatformID},{MsgWindow},{STChan},{STBaud},{RChan},{RBaud},{STInterval},{STOffset},{RInterval})"


def GOESGPS(
    GOESArray1: Literal["Time", "Latitude", "Longitude", "Elevation", "Magnetic"],
    GOESArray2: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesgps.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesgps.htm).

              The GOESGPS instruction returns two arrays.

    Args:
                  GOESArray1 (Variable): An array that holds a result code indicating the success of the instruction, followed by global positioning information. The result codes are as follows: The GPS data values are as follows:
    Must be one of following options: Time (Seconds since January 1, 2000), Latitude (Fractional degrees; 100 nanodegree resolution), Longitude (Fractional degrees; 100 nanodegree resolution), Elevation (Signed 32-bit number, in centimeters), Magnetic (Fractional degrees; 1 millidegree resolution)

          GOESArray2 (Variable | Constant | Expression | Array | Integer | ConstantInteger): The second array, which must be dimensioned to 7, holds the following time values: year, month, day hour (GMT), minute seconds, microseconds. Related Topics

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"GOESGPS({GOESArray1},{GOESArray2})"


def GOESTable(
    Result: Variable,
    ComPort: Literal[
        "ComRS232",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
        "COMSDC7",
        "COMSDC8",
        "COMSDC10",
        "COMSDC11",
    ],
    Model: Literal["0", "2", "3"],
    BufferControl: Literal["Constant", "Constant", "Variable", "Variable"],
    Fields_Scan_Order: Literal["False", "True"],
    Newest_First: Literal["False", "True"],
    Format: Literal["0", "1", "2", "3", "4", "6"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goestable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goestable.htm).

                The GOESTable instruction resides within the data table declaration.
    NOTE: There can only be one GOESTable() instruction per self-timed or random table.
    The following table provides the maximum data bytes for an assigned time slot duration. Note that if transmitted output is configured (via GOESField instructions) to have a size near to or exceeding the specified limits, there will be automatic truncation of the outputs that get transmitted.

    Args:
                    Result (Variable): The Result parameter is a string variable that holds either the data to be output in its specified format or a message indicating there are no data to output to the transmitter. If the Result parameter is used to view data that is output to the transmitter, then the string variable must be sized large enough to accommodate the data to be viewed. Following is a list of example messages that may be returned when there are no data output to the transmitter: Examples of messages when there is no data output to the transmitter: “No Output”“Write error”“Timed out wating for STX character from transmitter after SDC addressing”“Wrong character received after SDC addressing”“Timed out waiting for ACK or OK”“CS I/O port not available; GOES not attached”“Buffer Control Error”“COM9602 not communicating”“Illegal data format”“Transmitter not set up”

            ComPort (Variable | Constant): The ComPort parameter specifies the communication port that will be used for outputting data. When communicating over TCP/IP, use the variable returned by the TCPOpen function as the ComPort for GOESTable. If the PakBusTCPServer setting is being used rather than TCPOpen, use the Route instruction for the ComPort parameter. NOTE: When using an SDC comport, an SC105 with a female-to-female null modem cable should be used. The SC105 baud rates for both the CS I/O and RS-232 ports should be set to 9600 baud.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8), COMSDC7 (Datalogger CS I/O port; SDC7), COMSDC8 (Datalogger CS I/O port; SDC8), COMSDC10 (Datalogger CS I/O port; SDC10), COMSDC11 (Datalogger CS I/O port; SDC11)

            Model (Constant): The Model parameter indicates the model of satellite data transmitter to be used. Or, entering 0  for the model parameter specifies a “No Connection” protocol that may be used for a TCP/IP connection or to test output formats with no transmitter connected.
      Must be one of following options: 0 (No Connection
    Protocol), 2 (COM9602
    (Irridium)), 3 (TX325/TX326)

            BufferControl (Variable | Constant): BufferControl is a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. parameter (0 or non-zero) that specifies which buffer in the transmitter to write to. The parameter may be a constant or a variable expression. If the parameter is a constant, then 0 specifies a self-timed buffer and 1 or non-zero specifies write to the random buffer. If outputting to the self-timed buffer, output is controlled by whether there is a new record or not. To conditionally output to the random buffer, specify the Buffer Control parameter as a variable expression. When the expression evaluates as True (non-zero), output is written to the random buffer. False (0) means do not output. NOTE: The Self-Timed Interval must be at least 5 minutes greater than the Random Interval. Setting the Self-Timed Interval smaller than the Random Interval is atypical, but if done will result in a timing conflict between the two tasks.
      Must be one of following options: Constant (0), Constant (1 (non-zero)), Variable (True (non-zero)), Variable (False (0))

            Fields_Scan_Order (Variable | Constant): This a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. parameter that determines how the output table is ordered.
      Must be one of following options: False (Output each record (scan) along the row of the output table), True (Output each field along the row of the output table)

            Newest_First (Variable | Constant): This a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. parameter that determines whether the newest or oldest data are output first.
      Must be one of following options: False (Output oldest data
    first), True (Output newest data first)

            Format (Variable | Constant): The Format parameter is used to define the format of the data sent to the transmitter. A numeric value is entered: Related Topics
      Must be one of following options: 0 (Campbell Scientific FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. data; 3 bytes per data point), 1 (Campbell Scientific FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. data; 7 bytes per data point (ASCII)), 2 (ASCII table space), 3 (ASCII comma), 4 (Pseudo-binary (PB)), 6 (Line SHEF (Standard Hydrological Exchange Format))

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GOESTable({Result},{ComPort},{Model},{BufferControl},{Fields_Scan_Order},{Newest_First},{Format})"


def GOESField(
    NumVals: Literal["0", "0"],
    Decimation: Variable | Constant,
    Precision: Variable | Constant,
    Width: Variable | Constant,
    SHEF: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesfield.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/goesfield.htm).

              The GOESField instruction must precede each field in the data table that is to be output to the transmitter. If there is no GOESField() declaration prefacing an output instruction, then there will be no output of data from that field to the transmitter. A compile error will occur if a GOESField instruction is declared in a data table that does not use the GOESTable instruction.

    Args:
                  NumVals (Variable | Constant): The number of historical values (time series) of the field to output. For example, if the values of the field through time were (oldest to newest): 10.1,10.2,10.3,10.4,10.5,10.6,10.7 Then NumVals = 4 with Decimation =1 would give: 10.4, 10.5,10.6,10.7 NOTE: The Newest_First parameter of GOESTable determines whether newest or oldest data are output first. Beginning with OS 4, if NumVals is 0, new output is appended to the output table in the order set by the Fields_Scan_Order parameter of the GOESTable instruction. For example:
    Must be one of following options: 0 (False), 0 (True)

          Decimation (Variable | Constant): 1 = output every value, 2 = output every other value, 3, output every third value…

          Precision (Variable | Constant): For GOESTable formats 2 and 3, precision is the number of digits to the right of the decimal. For GOESTable formats 4 and 5, precision is the power of 10 that the value will by multiplied by before taking its integer value. Precision is ignored for GOESTable formats 0 and 1 (Campbell Scientific Floating Point ASCII).

          Width (Variable | Constant): Width specifies the number of characters in the field. The maximum number of characters is 13. If the actual number of characters in the field is larger than specified by the Width parameter, then precision will be adjusted downward in an attempt to fit the number of characters. The Width parmeter is ignored for GoesTable format 1 (Campbell Scientific Floating Point ASCII).

          SHEF (Variable): The SHEF parameter is a string variable used to specify a SHEF PE code. Empty quotes (for example "") means no SHEF code is specified. Related Topics

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"GOESField({NumVals},{Decimation},{Precision},{Width},{SHEF})"


def GPS(
    GPSArray: Variable,
    ComPort: Constant,
    TimeOffset: Constant,
    MaxTimeDiff: Constant,
    NMEAStrings: Variable | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/gps.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/gps.htm).

                This instruction is used along with a GPS device to set the datalogger's clock. This instruction will also provide information such as location (latitude/longitude) and speed, and store NMEA sentences from the GPS device.
    The resolution of accuracy for the clock set is 10 microseconds. The clock set relies on information from the GPRMC sentence. If this sentence is not returned a clock set will not occur.
    If the datalogger is programmed to use the PPS signal for synchronization, the only ComPort that can be used is COMC1 (the hardware does not support a PPS signal on other ports). The datalogger sets its clock approximately 200 microseconds behind the GPS clock (as indicated by the PPS signal). This means that the first measurement in the main scan will start about 300 microseconds behind GPS time. Synchronization of measurements between dataloggers of the same speed will be typically +/- 10 microseconds.
    Some GPS devices do not have a PPS output or output only a 3 V signal on the PPS line input. GPS devices with 3 V signals or no PPS signal can be used to sync the datalogger clock by negating the COM port parameter. This causes time to be sync’d using only the data contained in the NMEA sentences. Keep in mind, however, that this type of time syncing does not have the accuracy and precision that can be obtained when using the PPS line, since there can be some delay in the reception and parsing of the NMEA sentences.
    By default, the instruction expects the GPS unit to be set up at 38400 baud, outputting the GPRMC and GPGGA sentences once per second. The datalogger expects the start of the second to coincide with the rising edge of the PPS signal. If there is no PPS signal or if the required sentences come out at less than once per second the datalogger will not update its clock. The datalogger will wait on 10 good responses from the GPS  before using the data stream.
    GPS units with lower baud rates can be used with the GPS instruction but the baud rate has to be set for the relevant COM port it is to be connected to either in the datalogger settings or by including a SetStatus command after the BeginProg instruction in the program.
    Baud rates below 2400 bps will not work as the GPS unit will not be able to transmit the two GPS sentences once per second reliably. Similar problems can be encountered even at higher baud rates if too many optional GPS strings are selected to be output.

    Args:
                    GPSArray (Variable): The variable in which to store the information returned by the GPS. Fifteen values are returned. If this array is not dimensioned to 15, values will be stored to fill the array and no error will be returned. If no values are available, NAN will be returned. The values in this array are updated only when the GPS instruction is executed. NOTE: Beginning with operating system 3, the GPSArray may be declared as type Double to support higher-precision latitude and longitude. The following values are returned by the GPS: Array(1): Latitude, degrees Array(2): Latitude, minutesArray(3): Longitude, degreesArray(4): Longitude, minutesArray(5): Speed over ground, knotsArray(6): Course over ground, degreesArray(7): Magnetic variation (positive = East, negative = West)Array(8): Fix Quality (0 = invalid, 1 = GPS, 2 = differential GPS, 6 = estimated)Array(9): Number of SatellitesArray(10): Altitude, metersArray(11): Time into the current second (in microseconds) when the PPS low to high transition occurred. Once the clock is set a fixed value of 990000 will be returned. Array(12): Time since the datalogger last saw a valid GPRMC sentence, timed at the instant the GPS instruction runs. Typically this value will be about one second. If this value is seen to be consistently above one second and/or increasing this indicates the GPS unit has lost sight of enough satellites to give a good output or the GPS unit is disconnected or powered off.Array(13): GPSReady. Indicates whether the datalogger has seen a number of good GPRMC strings, all received within a reasonable time of the PPS signal. A value of ten indicates 10 good responses have been received. Only when the counter is at ten will the datalogger use the GPS time to set the datalogger clock. If a GPRMC string comes out in the wrong time frame or if it is invalid in any way, the GPS Ready value is reset to zero.Array(14): Maximum time adjustment since the datalogger program started, milliseconds (10 msec resolution). Can be set to 0 manually or under program control.Array(15): Number of times clock has been changed since the datalogger program started. This can be set to 0 manually or under program control. Data from other NMEA sentences can be stored in a numeric format. For each sentence data is stored in the array as follows: The number of values in the sentence.A simple checksum of the characters in the sentence's name, not counting the '$'. This is the sum of the 8 bit ASCII codes.The comma separated values in the sentence. If the field is non-numeric, a similar numeric checksum for the variable string as in (2) is stored. For a single character field this will be its ASCII value. If the field is vacant; i.e., back to back commas, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Steps 1..3 are repeated for as many different sentences that are seen by the datalogger. The GPSArray must be dimensioned large enough to store all the variables for all the sentences you need to store. The order in which the data is stored for the different NMEA sentences follows the rules for the ordering of the NMEA strings. These values are stored in the GPS array when the GPS instruction runs, without risk of corruption caused by new data coming in when the instruction runs.

            ComPort (Constant): The ComPort parameter is the control port pair to which the GPS device is attached. Rx is used to read in the NMEA sentences and Tx is used to monitor the PPS from the GPS. COMC1 is the only Comport that supports a PPS signal. Negate the ComPort parameter to program the datalogger to use NMEA sentences for time-syncing rather than the PPS line input (see Remarks above).  Valid options are: COMC1       C1/C2 (only comport that supports PPS signal)-COMC1 to -COMC7 (negated comport for NMEA sentences time-syncing)-COMRS232 (negated comport for NMEA sentence time-syncing) This instruction defaults to a baud rate of 38,400 bps. If the GPS device requires a different baud rate, use the SetStatus instruction in the program to override the default.

            TimeOffset (Constant): The local time offset, in seconds, from UTC. The TimeOffset parameter is ignored if the "UTC Offset" setting in the datalogger is a value other than -1 (disabled). In other words, the UTCOffset setting in the datalogger overrides this  instruction parameter.  The UTCOffset  setting can be found in the Settings table. For more information, see Settings Available Using SetSetting NOTE: For the GPS() instruction, in order to use GPS coordinates without setting the datalogger clock, set the TimeOffset parameter to -1.

            MaxTimeDiff (Constant): The maximum difference in time (in milliseconds) between the datalogger clock and the GPS clock that will be tolerated before the clock is changed. If a negative value is entered, the clock will not be changed.

            NMEAStrings (Variable | Array): The string array that holds the NMEA sentences. If it exists, the GPRMC sentence will reside in NMEAStrings(1), and the GPGGA sentence will reside in NMEAStrings(2). Any other sentences will reside in subsequent indexes into the array (on a first-in basis). Once an index in the array is used to store a particular sentence, that sentence will always be stored in that location when updates to the sentence are received. The NMEA strings are updated every time a new sentence comes in as a background task, so the strings can be seen to change even if the GPS instruction is called infrequently. These strings are mainly provided for diagnostic purposes as the string can be overwritten by the background task midway through the program code accessing the string. Access to data in the standard or user configured additional messages should be using the GPSArray (see below). Beyond the GPRMC and GPGGA sentences, you can determine the order the sentences appear in the NMEA strings by initializing the required NMEAstring to the strings “name” at the start of the program; for example NMEAStrings(3)=”$GPVTG”, otherwise the data is written in the order seen after the program starts to run.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"GPS({GPSArray},{ComPort},{TimeOffset},{MaxTimeDiff},{NMEAStrings})"


def Hex(
    Expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hex.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hex.htm).

                The Hex function returns a variable length string with no leading zeros. The result should be formatted as type String of at least 9 characters. If a fixed length string is required, use the Sprintf function for conversion and formatting.
    The input for Hex (Expression parameter) can be a constant, variable, or expression. Expression cannot be of type String. Keep in mind that the input is converted to Long during processing. For example Hex(9.469614E-13) will result in "0" and not "2B8545E1"; 9.469614E-13 will first be converted to 0 (the closet Long representation) and then to hexadecimal. To covert a floating point number to hexadecimal first move the bytes into a Long and then into Hex (refer to earlier Example program).

    Args:
                    Expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): The expression on which to perform the Decimal to Hex or Hex to Decimal conversion.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Hex({Expression})"


def HexToDec(
    Expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hextodec.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hextodec.htm).

                The HexToDec function can be used to return the decimal representation of Expression into a variable.
    Conversion from a hexadecimal string to a decimal value can also be accomplished by prefacing any hexadecimal string with &H.

    Args:
                    Expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): The expression on which to perform the Decimal to Hex or Hex to Decimal conversion.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"HexToDec({Expression})"


def Histogram(
    BinSelect: Variable,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
    Bins: Constant,
    Form: Literal["A", "A", "B", "B", "C", "C"],
    WtVal: Variable | Constant,
    LoLim: Constant,
    UpLim: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/histogram.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/histogram.htm).

                The result of the Histogram instruction is a representation of a frequency distribution by using bins that have unique ranges. The value that is output to each bin is proportional to the frequency that the BinSelect's value is within that bin's range.
    The individual Bin ranges are calculated by taking the difference between the upper and lower limits (UpLim and LoLim) and dividing by the number of Bins. The first bin's range starts at the lower limit. For example, if LoLim=100, UpLim=200, and Bins=4, the bins are defined as:
    A bin's value is incremented whenever the BinSelect variable's value falls within the range associated with that bin.
    A weighted histogram can be created by using a variable for the WtVal argument. The WtVal variable's value can be tied to a sensor's output or it can be set by the program according to existing conditions. When the BinSelect value falls within a bin's range, the total for that bin is incremented by the current value of the WtVal variable. If a weighted histogram is not desired, WtVal should be set to a constant value. Set WtVal to 1 to increment the bin by 1 for each occurrence.
    The process string for the Histogram instructions is as follows:
    Process Name (HST), Number of Bins, Weighting Value, Low Limit, High Limit
    The Histogram is reset when the data is output to a table. It can also be reset under program control by setting the DisableVar to 12345.

    Args:
                    BinSelect (Variable): The variable that is tested to determine which bin is selected. Right-click the parameter to display a list of defined variables.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990. NOTE: If FP2 is selected, the largest number that can be accumulated in each bin before a numeric overrange occurs is 7999.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. If 12345 is entered for the DisableVar, the histogram is reset after output (regardless of the form used). If -12345 is entered, the histogram is reset immediately.

            Bins (Constant): The number of bins or subranges to include in the histogram. The width of each subrange is equal to the histogram range (UpLim - LoLim) divided by the number of bins.

            Form (Constant): The Form argument consists of three elements: ABC. Open form includes values > UpLim in the upper bin and values < LoLim + NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.s in the lower bin. Closed form excludes values outside of the limits (including NANs). Right-click within the parameter to display a list. When a histogram is reset, a new histogram is created and stored in the data table at the data table's output interval. The number of new data points that are used for calculating subsequent histograms is determined by the ratio of the data table output rate to the scan interval: (data table output rate)/(scan interval). Choose whether or not the histogram should be reset (all bins are set to zero) after each output. If the histogram is not reset, the values in each bin will continue to accumulate as long as the program runs. When element C is set to 0 (open form), NAN values accumulate in the first bin. If this is undesirable, these values can be filtered using programming logic (for example, "If variable = NAN then DisableVar = 1").
      Must be one of following options: A (Reset histogram values to 0 after each output.), A (Do not reset histogram.), B (Divide bins by total count.), B (Output total in each bin.), C (Open form. Include values outside LoLim and UpLim in end bins.), C (Closed form. Exclude values outside range.)

            WtVal (Variable | Constant): The variable name of the weighted value. Enter a constant for a frequency distribution of the BinSelect value. Right-click the parameter to display a list of defined variables.

            LoLim (Constant): The lower limit of the range covered by the BinSelect value.

            UpLim (Constant): The upper limit of the range covered by the BinSelect value.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Histogram({BinSelect},{DataType},{DisableVar},{Bins},{Form},{WtVal},{LoLim},{UpLim})"


def Histogram4D(
    BinSelect: Variable,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
    Bins1: Constant,
    Bins2: Constant,
    Bins3: Constant,
    Bins4: Constant,
    Form: Literal["A = 0", "A = 1", "B = 0", "B = 1", "C = 0", "C = 1"],
    WtVal: Variable | Constant,
    LoLim1: Constant,
    LoLim2: Constant,
    LoLim3: Constant,
    LoLim4: Constant,
    UpLim1: Constant,
    UpLim2: Constant,
    UpLim3: Constant,
    UpLim4: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/histogram4d.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/histogram4d.htm).

              The Histogram4D instruction is similar to the Histogram instruction, except that the Histogram4D instruction allows up to four BinSelect inputs (four dimensions). The BinSelect values are specified as a variable array. Each of the BinSelect values has its own range and number of weighted values.

    Args:
                  BinSelect (Variable): The variable that is tested to determine which bin is selected. This variable must be dimensioned to the same size as the number of dimensions used in the Histogram4D instruction - a number between 1 and 4.

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990. NOTE: If FP2 is selected, the largest number that can be accumulated in each bin before a numeric overrange occurs is 7999.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

          DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

          Bins (Constant): Defines the number of bins or subranges to include in the histogram bin select range. The total number of bins (subranges) will be equal to the product of Bin1, Bin2, Bin3, Bin4. The width of each subrange is equal to the BinSelect range (UpLim - LoLim) divided by the number of bins. If all four dimensions are used then the output will be linearized. Since the OS only keeps three dimensions internally, the output must be linearized to successfully pass the table definitions to datalogger support software. Bins1: The row-wise number of bins to include in the histogram. Bins2: The column-wise number of bins to include in the histogram.Bins3: The 3rd dimension number of bins to include in the histogram.Bins4: The 4th dimension number of bins to include in the histogram.

          Form (Constant): The Form argument consists of three elements: ABC. Open form includes values > UpLim in the upper bin and values < LoLim + NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.s in the lower bin. Closed form excludes values outside of the limits (including NANs). Right-click within the parameter to display a list. When a histogram is reset, a new histogram is created and stored in the data table at the data table's output interval. The number of new data points that are used for calculating subsequent histograms is determined by the ratio of the data table output rate to the scan interval: (data table output rate)/(scan interval). Choose whether or not the histogram should be reset (all bins are set to zero) after each output. If the histogram is not reset, the values in each bin will continue to accumulate as long as the program runs. When element C is set to 0 (open form), NAN values accumulate in the first bin. If this is undesirable, these values can be filtered using programming logic (for example, "If variable = NAN then DisableVar = 1").
    Must be one of following options: A (Reset histogram values to 0 after each output.), A (Do not reset histogram.), B (Divide bins by total count.), B (Output total in each bin.), C (Open form. Include values outside LoLim and UpLim in end bins.), C (Closed form. Exclude values outside range.)

          WtVal (Variable | Constant): The variable name of the weighted value. Enter a constant for a frequency distribution of the BinSelect value. Right-click the parameter to display a list of defined variables.

          LoLim1234 (Constant): The lower limit of the range covered by the BinSelect value

          UpLim1234 (Constant): The upper limit of the range covered by the BinSelect value. Output:  For a 4Dim histogram with # of Bins in each dimension as follows: The total number of bins is the product of the number of bins in each dimension (B1 x B2 x B3 x B4).  The output would be arranged sequentially in the order: [Bin(1,1,1,1), Bin(1,1,1,2), … Bin(1,1,1,B4), Bin(1,1,2,1), Bin(1,1,2,2), ... Bin(1,1,2,B4), Bin(1,1,3,1), Bin(1,1,3,2) ... Bin(1,1,3,B4) ... Bin(1,1,B3,1), Bin(1,1,B3,2), ... Bin(1,1,B3,B4), Bin(1,2,1,1), Bin(1,2,1,2), ...  Bin(1,2,1,B4), Bin(1,2,2,1), ... Bin(1,2,2,B4), Bin(1,2,3,1), Bin(1,2,3,2), ... Bin(1,2,B3,1), Bin(1,2,B3,2) ... Bin(1,2,B3,B4), Bin(1,3,1,1), Bin(1,3,1,2), ... Bin(1,B2,B3,B4), Bin(2,1,1,1), ... Bin(B1,B2,B3,B4).  So if B1 = B2 = B3 = B4 = 2 (2 Bins in each dimension) then the output order would be: Bin(1,1,1,1), Bin(1,1,1,2), Bin(1,1,2,1), Bin(1,1,2,2), Bin(1,2,1,1), Bin(1,2,1,2), Bin(1,2,2,1), Bin(1,2,2,2), Bin(2,1,1,1), Bin(2,1,1,2), Bin(2,1,2,1), Bin(2,1,2,2), Bin(2,2,1,1), Bin(2,2,1,2), Bin(2,2,2,1), Bin(2,2,2,2)
    Must be one of following options:  (# of Bins in Second Dimension (Bins2)),  (# of Bins in Third Dimension (Bins3)),  (# of Bins in Fourth Dimension (Bins4))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Histogram4D({BinSelect},{DataType},{DisableVar},{Bins1},{Bins2},{Bins3},{Bins4},{Form},{WtVal},{LoLim1},{LoLim2},{LoLim3},{LoLim4},{UpLim1},{UpLim2},{UpLim3},{UpLim4})"


def HydraProbe(
    HydraDestination: Variable,
    SourceVolts: Variable,
    ProbeType: Constant,
    SoitType: Constant,
    HydraMult: Variable | Constant | Expression | Array,
    HydraOffset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hydraprobe.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/hydraprobe.htm).

        The sensor is first measured using a single ended voltage measurement (VoltSE). The measurements returned by the sensor must be stored in an array dimensioned to 4. This instruction returns the following 11 data values: soil type (1 = sand, 2 = silt, 3 = clay, 4 = loam), real dielectric constant, imagined dielectric constant, temperature (degrees C), real dielectric constant with temperature correction, imagined dielectric constant with temperature correction, water content (fraction by volume), salinity (grams of NaCl per liter), soil conductivity (S/m), soil conductivity with temperature correction (S/m), soil water conductivity with temperature correction (S/m).

    Args:
            HydraDestination (Variable): The variable array (dimensioned to 11) that will hold the values returned from the Hydra Probe sensor. The sensor returns the following measurements: soil type (1 = sand, 2 = silt, 3 = clay, 4 = loam), real dielectric constant, imagined dielectric constant, temperature, real dielectric constant with temperature correction, imagined dielectric constant with temperature correction, water content (fraction by volume), salinity (grams of NaCl per liter), soil conductivity (S/m), soil conductivity with temperature correction (S/m), soil water conductivity with temperature correction (S/m).

    SourceVolts (Variable): A variable array that will hold the voltages returned by the sensor (V1, V2, V3, and V4).

    ProbeType (Constant): Identifies which version of the Hydra Probe is being measured. 0 = Standard Probe (5V output for V4); 1 = Probe Type A (2.5 V output for V4). Right-click the parameter to display a drop-down list box.

    SoitType (Constant): Indicates the type of soil being measured: 1 = sand, 2 = silt, 3 = clay, and 4 = loam. Right-click the parameter to display a drop-down list box.

    HydraMult (Variable | Constant | Expression | Array): Factors by which to scale the results of the Temperature measurement. A multiplier of 1 and offset of 0 will leave the temperature measurement at degrees C. A multiplier of 1.8 and an offset of 32 will convert it to degrees F.

    HydraOffset (Variable | Constant | Expression | Array): Factors by which to scale the results of the Temperature measurement. A multiplier of 1 and offset of 0 will leave the temperature measurement at degrees C. A multiplier of 1.8 and an offset of 32 will convert it to degrees F.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"HydraProbe({HydraDestination},{SourceVolts},{ProbeType},{SoitType},{HydraMult},{HydraOffset})"


def HTTPGet(
    URI: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Response: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Header: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpget.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpget.htm).

                The HTTPGet function returns a Long Data type used when declaring a variable as an integer. value that represents the socket reference used by the datalogger for communication. When the instruction is successful, the value is greater than 100.
    If the header in the response from the server specifies “Connection: close”, the connection is closed; otherwise, it is left open. If the connection is left open, this same connection is used when the instance of HTTPGet that opened the connection is executed again.
    A PakBus address of 3213 in the Files Manager setting of the datalogger can be used to enumerate/manage files written by HTTPGet.

    Args:
                    URI (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that contains the uniform resource identifier (typically a URL) of the HTTP server to be accessed. A username and password can be passed into a URL using http://username:password@http.server.address.

            Response (Variable | Constant | Expression | Array | Integer | ConstantInteger): Indicates where the results of the request will be written. The parameter can be a variable or the name of a valid file on the datalogger.

            Header (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that indicates the additional header information to include in the request. As a result of the request, the server may return header information that is stored in the string. The Header parameter can be an empty string if no additional header information is required. In the case that more than one header is required, headers can be separated by & CHR(13) & CHR(10) &. For example: HTTPPost (https://api.placeholder.com/v1/chat/completions,Query_str,Response,"Content-Type: application/json" & CHR(13) & CHR(10) & "Authorization: Bearer xx-XXXXXX") Text (description)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds). More information on the Get method, including URIs and valid header fields can be found on the W3C web site.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"HTTPGet({URI},{Response},{Header},{TimeOut})"


def HTTPPost(
    URI: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Contents: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Response: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Header: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumRecsTimeIntoInterval: Constant,
    Interval: Literal["0", ">=0", ">0", "<0", "0"],
    Units: Constant,
    FileOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
    ],
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httppost.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httppost.htm).

                This function returns the TCP socket that was created to communicate with the HTTP server. This function returns 0 if it fails or -2 if execution did not occur when the instruction was called (for instance, when using the optional parameters to stream data from a table and the number of records or time into interval conditions are not met). If this value is zero when the function is called, the datalogger will create a new connection to the web server.
    NOTE:  When multiple IP interfaces (for example, Ethernet port, CS I/O port, Wi-Fi, PPP) are active, the IPRoute() instruction is used to direct outgoing IP traffic.
    You may also consider HTTPPut. The difference between HTTPPost and HTTPPut is that HTTPPost prefaces the content with "POST /" and HTTPPut prefaces the content with "Put /".
    EmailRelay() or FTPClient() may also be used for data streaming if a server is not configured for HTTP.
    HTTPost supports HTTP and HTTPS. When this function is in the program, TLS is enabled in the datalogger automatically, unless the URI is a constant and the first 5 characters are HTTP:.
    If the header in the response from the server specifies “Connection: close”, the connection is closed; otherwise, it is left open. If the connection is left open, this same connection is used when the instance of HTTPPost that opened the connection is executed again.
    SemaphoreGet/SemaphoreRelease - Semaphore number 4 can be used by the CRBasic program to determine if a file is currently opened for rename via FTP or for sending/serving up via HTTP. SemaphoreGet(4) should only be used if the desire is to manage CRBasic processes around these type of events.
    An example application is a datalogger generating a data file or image that is also served up via HTTP. SemaphoreGet(4) / SemaphoreRelease(4) can be used around the data file generation so that the datalogger does not change the contents of the file in the middle of it being downloaded over HTTP.
    The last several parameters are optional. They can be used to send data from a data table directly to a server, without the datalogger first having to write the data to a file.

    Args:
                    URI (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that contains the uniform resource identifier (typically a URL) of the HTTP server to be accessed. A username and password can be passed into a URL using http://username:password@http.server.address.

            Contents (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression that contains the contents to be sent with the request. If streaming data directly from a data table or data table field, this parameter should be a constant specifying the table name (for example, “TableOne”) or table field name (for example, “TableOne.BattV_Min”) that will be used as the data source.

            Response (Variable | Constant | Expression | Array | Integer | ConstantInteger): Indicates where the results of the request will be written. The parameter can be a variable or the name of a valid file on the datalogger.

            Header (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that indicates the additional header information to include in the request. As a result of the request, the server may return header information that is stored in the string. The Header parameter can be an empty string if no additional header information is required. In the case that more than one header is required, headers can be separated by & CHR(13) & CHR(10) &. For example: HTTPPost (https://api.placeholder.com/v1/chat/completions,Query_str,Response,"Content-Type: application/json" & CHR(13) & CHR(10) & "Authorization: Bearer xx-XXXXXX") Text (description)

            NumRecs/TimeIntoInterval (Constant): Used only when streaming data directly from a data table or data table field. NOTE: For more details, see the Data Streaming document.  If Interval is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unsent records should be written to file on the server.  If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be written to file on the server. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will be written to file on the server each time the function is called.

            Interval (Constant): Used only when streaming data directly from a data table or data table field. If greater than 0, the Interval parameter determines the interval at which previously unsent data will be written to file. If equal to zero, the NumRecs parameter will control when data is written. A negative Interval will cause the datalogger to write the most recent records within this time interval each time the function is called.
      Must be one of following options: 0 (0), >=0 (>0), >0 (0), <0 (0), 0 (<0)

            Units (Constant): Used only when streaming data directly from a data table or data table field. It is used to specify the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days.

            FileOption (Constant): Used only when streaming data directly from a data table or data table field. It specifies the format used when writing data to the server. The file created on the server will automatically be appended with an incrementing file number and a “.dat” file extension. If 1000 is added to the format (for example, 1008), the datalogger will not automatically append the incrementing number or “.dat” extension to the uploaded file. Options 0, 8, 16, and 32 correspond to Campbell Scientific's defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"HTTPPost({URI},{Contents},{Response},{Header},{NumRecsTimeIntoInterval},{Interval},{Units},{FileOption},{TimeOut})"


def HTTPPut(
    URI: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Contents: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Response: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Header: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumRecsTimeIntoInterval: Constant,
    Interval: Literal["0", ">=0", ">0", "<0", "0"],
    Units: Constant,
    FileOption: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
    ],
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpput.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpput.htm).

                This function returns the TCP socket that was created to communicate with the HTTP server. This function returns 0 if it fails or -2 if execution did not occur when the instruction was called (for instance, when using the optional parameters to stream data from a table and the number of records or time into interval conditions are not met). If this value is zero when the function is called, the datalogger will create a new connection to the web server.
    NOTE:  When multiple IP interfaces (for example, Ethernet port, CS I/O port, Wi-Fi, PPP) are active, the IPRoute() instruction is used to direct outgoing IP traffic.
    You may also consider EmailyRelay or FTPClient if your server is not configured for HTTP.
    HTTPPut supports HTTP Hypertext Transfer Protocol. A TCP/IP application protocol. and HTTPS. When this function is in the program, TLS Transport Layer Security. An Internet communication security protocol. is enabled in the datalogger automatically, unless the URI Uniform Resource Identifier is a constant and the first 5 characters are HTTP:.
    SemaphoreGet/SemaphoreRelease - Semaphore number 4 can be used by the CRBasic program to determine if a file is currently opened for rename via FTP or for sending/serving up via HTTP. SemaphoreGet(4) should only be used if the desire is to manage CRBasic processes around these type of events.
    An example application is a datalogger generating a data file or image that is also served up via HTTP. SemaphoreGet(4) / SemaphoreRelease(4) can be used around the data file generation so that the datalogger does not change the contents of the file in the middle of it being downloaded over HTTP.
    The last several parameters are optional. They can be used to send data from a data table directly to a server, without the datalogger first having to write the data to a file.

    Args:
                    URI (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that contains the uniform resource identifier (typically a URL) of the HTTP server to be accessed. A username and password can be passed into a URL using http://username:password@http.server.address.

            Contents (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression that contains the contents to be sent with the request. If streaming data directly from a data table or data table field, this parameter should be a constant specifying the table name (for example, “TableOne”) or table field name (for example, “TableOne.BattV_Min”) that will be used as the data source.

            Response (Variable | Constant | Expression | Array | Integer | ConstantInteger): Indicates where the results of the request will be written. The parameter can be a variable or the name of a valid file on the datalogger.

            Header (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string that indicates the additional header information to include in the request. As a result of the request, the server may return header information that is stored in the string. The Header parameter can be an empty string if no additional header information is required. In the case that more than one header is required, headers can be separated by & CHR(13) & CHR(10) &. For example: HTTPPost (https://api.placeholder.com/v1/chat/completions,Query_str,Response,"Content-Type: application/json" & CHR(13) & CHR(10) & "Authorization: Bearer xx-XXXXXX") Text (description)

            NumRecs/TimeIntoInterval (Constant): Used only when streaming data directly from a data table or data table field. NOTE: For more details, see the Data Streaming document.  If Interval is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unsent records should be written to file on the server.  If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be written to file on the server. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will be written to file on the server each time the function is called.  NumRecs/TimeIntoInterval

            Interval (Constant): Used only when streaming data directly from a data table or data table field. If greater than 0, the Interval parameter determines the interval at which previously unsent data will be written to file. If equal to zero, the NumRecs parameter will control when data is written. A negative Interval will cause the datalogger to write the most recent records within this time interval each time the function is called.
      Must be one of following options: 0 (0), >=0 (>0), >0 (0), <0 (0), 0 (<0)

            Units (Constant): Used only when streaming data directly from a data table or data table field. It is used to specify the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days.

            FileOption (Constant): Used only when streaming data directly from a data table or data table field. It specifies the format used when writing data to the server. The file created on the server will automatically be appended with an incrementing file number and a “.dat” file extension. If 1000 is added to the format (for example, 1008), the datalogger will not automatically append the incrementing number or “.dat” extension to the uploaded file. Options 0, 8, 16, and 32 correspond to Campbell Scientific's defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON)

            TimeOut (Constant): Specifies a time period, in 0.01 seconds, that the datalogger will wait for input after a connection is made, before considering the attempt failed and incrementing Result. The default TimeOut in the absence of this parameter is 7500 (i.e., 75 seconds).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"HTTPPut({URI},{Contents},{Response},{Header},{NumRecsTimeIntoInterval},{Interval},{Units},{FileOption},{TimeOut})"


def HTTPOut(
    WebPageName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    WebPageCmd: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpout.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/httpout.htm).

    Args:
            "WebPageName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): "WebPageName" (No description provided)

    WebPageCmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): WebPageCmd (No description provided)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"HTTPOut({WebPageName},{WebPageCmd})"


def TimeIntoInterval(
    TintoInt: Variable | Constant, Interval: Variable | Constant, Units: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeintointervaliftime.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeintointervaliftime.htm).

                When encountered by the datalogger program, the TimeIntoInterval statement is evaluated True (-1) or False (0) based on the datalogger's real-time clock at the start of a scan. Time is kept internally by the datalogger as the elapsed time since January 1, 1990, at 00:00:00 hours (thus, a weekly interval; i.e., an offset into 168 hours, begins Monday at 0000 hours). When the Interval divides evenly into this elapsed time, the TimeIntoInterval is set True. These instructions should always be placed within a Scan/NextScan or within a subroutine or function that is called from within a Scan/NextScan in order to function properly.
    The TimeIntoInterval instruction can be used to set the value of a variable to -1 or 0 (first syntax example), or it can be used as an expression for a Condition (second syntax example). Note that this function will return true only once at the start of the period when the time condition is met; for example, with a 1 second scan rate, a 0 into a 5 minute interval is set to true once at the top of every 5 minutes (not 60 times at the beginning of the 5 minute period). An exception to this is when the interval is greater than 60 minutes with subsecond scans. In this case, resolution is 1 second so all subsecond scans during the second in which TimeIntoInterval/IfTime is true will return true.
    NOTE: TimeIntoInterval must be placed within a scan to function.

    Args:
                    TintoInt (Variable | Constant): Allows an offset to the specified Interval. The Units for time are the same as for the Interval. This parameter must be an integer. Use of non-integers may result in the interval not evaluating as True when expected. In the DataInterval instruction, this parameter must be a constant (a variable is not allowed). If a variable is used in this parameter, it is recommended to define it as a Long. TintoInt parameter example usage: if the Interval is set at 60 minutes, and TintoInt is set to 5, then data storage will occur at 5 minutes into the hour, every hour, based on the datalogger's real-time clock. If the TintoInt is set to 0, data storage will occur at the top of the hour.

            Interval (Variable | Constant): How frequently the TimeIntoInterval (or IfTime) statement will be evaluated True, based on the datalogger's real-time clock. This parameter must be an integer. If a variable is used in this parameter, it is recommended to define it as a Long. Use of non-integers may result in the interval not evaluating as True when expected.

            Units (Constant): The Units parameter specifies the units on which the TintoInt and Interval arguments will be based. The options are msec (milliseconds), sec (seconds), min (minutes), hr (hours), day (days), or mon (month). When days are used, TintoInt starts on a Monday (since January 1, 1990 fell on a Monday). For example, TimeIntoInterval(0,7,days) would perform a function every Monday. TimeIntoInterval(1,7,days) would perform a function every Tuesday, and so on. When month (mon) is used for the Units parameter, the Interval parameter is specified as an integer ranging from 0 (January) to 11 (December), and the TIntoInt parameter is specified as seconds into the month. The month Interval is synchronized to the beginning of the year (January at 00:00 hours). When the dataloggers real-time clock reaches 00:00 on the last day of the specified month, the month increments by 1, at which point the month interval condition is True. For example, consider the case where the month interval is specified as 9 (October). When the dataloggers real-time clock reaches 00:00 on October 1st, month changes to 10. 10 mod 9 = 1, so the True condition is met. The TintoInt parameter with “mon” chosen as the units denotes either seconds before the next month, or seconds into the next month, depending on whether a negative or positive value is entered. For instance, TimeIntoInterval(-60, 9, Mon) is true for one second, one minute before October 1st. Conversely, TimeIntoInterval(60, 9, Mon) is true for one second, one minute after October 1st begins. Note that TintoInt values must align with your scan interval. If your scan interval is one minute, TintoInt should be set to 60 seconds or a multiple thereof to trigger a true condition. NOTE:    When using month as the Interval unit,  any month other than January results in the True condition occurring twice a year; once at the start of January  and once at the end of the specified month interval.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TimeIntoInterval({TintoInt},{Interval},{Units})"


def IfTime(
    TintoInt: Variable | Constant, Interval: Variable | Constant, Units: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeintointervaliftime.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeintointervaliftime.htm).

                When encountered by the datalogger program, the TimeIntoInterval statement is evaluated True (-1) or False (0) based on the datalogger's real-time clock at the start of a scan. Time is kept internally by the datalogger as the elapsed time since January 1, 1990, at 00:00:00 hours (thus, a weekly interval; i.e., an offset into 168 hours, begins Monday at 0000 hours). When the Interval divides evenly into this elapsed time, the TimeIntoInterval is set True. These instructions should always be placed within a Scan/NextScan or within a subroutine or function that is called from within a Scan/NextScan in order to function properly.
    The TimeIntoInterval instruction can be used to set the value of a variable to -1 or 0 (first syntax example), or it can be used as an expression for a Condition (second syntax example). Note that this function will return true only once at the start of the period when the time condition is met; for example, with a 1 second scan rate, a 0 into a 5 minute interval is set to true once at the top of every 5 minutes (not 60 times at the beginning of the 5 minute period). An exception to this is when the interval is greater than 60 minutes with subsecond scans. In this case, resolution is 1 second so all subsecond scans during the second in which TimeIntoInterval/IfTime is true will return true.
    NOTE: TimeIntoInterval must be placed within a scan to function.

    Args:
                    TintoInt (Variable | Constant): Allows an offset to the specified Interval. The Units for time are the same as for the Interval. This parameter must be an integer. Use of non-integers may result in the interval not evaluating as True when expected. In the DataInterval instruction, this parameter must be a constant (a variable is not allowed). If a variable is used in this parameter, it is recommended to define it as a Long. TintoInt parameter example usage: if the Interval is set at 60 minutes, and TintoInt is set to 5, then data storage will occur at 5 minutes into the hour, every hour, based on the datalogger's real-time clock. If the TintoInt is set to 0, data storage will occur at the top of the hour.

            Interval (Variable | Constant): How frequently the TimeIntoInterval (or IfTime) statement will be evaluated True, based on the datalogger's real-time clock. This parameter must be an integer. If a variable is used in this parameter, it is recommended to define it as a Long. Use of non-integers may result in the interval not evaluating as True when expected.

            Units (Constant): The Units parameter specifies the units on which the TintoInt and Interval arguments will be based. The options are msec (milliseconds), sec (seconds), min (minutes), hr (hours), day (days), or mon (month). When days are used, TintoInt starts on a Monday (since January 1, 1990 fell on a Monday). For example, TimeIntoInterval(0,7,days) would perform a function every Monday. TimeIntoInterval(1,7,days) would perform a function every Tuesday, and so on. When month (mon) is used for the Units parameter, the Interval parameter is specified as an integer ranging from 0 (January) to 11 (December), and the TIntoInt parameter is specified as seconds into the month. The month Interval is synchronized to the beginning of the year (January at 00:00 hours). When the dataloggers real-time clock reaches 00:00 on the last day of the specified month, the month increments by 1, at which point the month interval condition is True. For example, consider the case where the month interval is specified as 9 (October). When the dataloggers real-time clock reaches 00:00 on October 1st, month changes to 10. 10 mod 9 = 1, so the True condition is met. The TintoInt parameter with “mon” chosen as the units denotes either seconds before the next month, or seconds into the next month, depending on whether a negative or positive value is entered. For instance, TimeIntoInterval(-60, 9, Mon) is true for one second, one minute before October 1st. Conversely, TimeIntoInterval(60, 9, Mon) is true for one second, one minute after October 1st begins. Note that TintoInt values must align with your scan interval. If your scan interval is one minute, TintoInt should be set to 60 seconds or a multiple thereof to trigger a true condition. NOTE:    When using month as the Interval unit,  any month other than January results in the True condition occurring twice a year; once at the start of January  and once at the end of the specified month interval.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"IfTime({TintoInt},{Interval},{Units})"


def Int(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/intfix.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/intfix.htm).

                The Number argument can be any valid numeric expression. Both INT and FIX remove the fractional part of number and return the resulting integer value.
    If the numeric expression results in a Null value, INT and FIX return a NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN..
    FIX(number) is equivalent to:

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Int({number})"


def InStr(
    Start: Integer,
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FilterString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SearchOption: Literal["0", "1", "2", "3", "4", "6", "8", "9", "10"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/instr.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/instr.htm).

                This function returns the integer position of the first occurrence of the FilterString parameter. If the FilterString is not found, the function returns 0.

    Args:
                    Start  (Integer): Specifies where in the SearchString to begin. A 1 indicates the first character in the string.

            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

            FilterString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to look for in the SearchString.  For a FilterString using non-printable ASCII characters, use the CHR function and the appropriate ASCII code.

            SearchOption (Constant): A code used to help define the method of searching. Add 100 to any of the non-numeric options above to parse a string that includes quotes, with the quotes being omitted in the result. String variables can be declared as only one or two dimensions; for example, String(x) or String(x,y). To begin reading or modifying a string at a particular location into the string, enter the location as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element. WARNING: String functions are case sensitive. Uppercase or lowercase can be used to convert to all one case prior to processing the string if desired.
      Must be one of following options: 0 (NUMERIC - Numerics in the SearchString (FilterString is ignored).), 1 (NON-NUMERIC - Non-numerics (FilterString is ignored).), 2 (SEARCHSTRING - Each FilterStrings in SearchString.), 3 (SEARCHCHARS - Each occurrence of any character that is in FilterString.), 4 (HEADERFILTER - Strings succeeding FilterString.), 6 (HEADERFILTERCHARS - Strings succeeding any character in the FilterString char
    list.), 8 (NUMERICHEX - Hexadecimal numerics in the SearchString (FilterString is
    ignored).), 9 (ReverseCS – first occurrence of the filter string, searching from the end of the
    string. Case sensitive.), 10 (ReverseIS - first occurrence of the filter string, searching from the end of the string. Case insensitive.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"InStr({Start},{SearchString},{FilterString},{SearchOption})"


def InstructionTimes(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/instructiontimes.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/instructiontimes.htm).

                The InstructionTimes instruction loads the Dest array with processing times for each instruction in the program. The time is reflected in microseconds. InstructionTimes must appear before the BeginProg statement in the program.
    Each element in the array corresponds to a line number in the program. To accommodate all of the instructions in the program, the array must be dimensioned to the total number of lines in the program, including blank lines and comments. The Dest array must also be dimensioned as a long integer (for example, Public Array(20) AS LONG).
    NOTE: The processing time for an instruction may vary. For instance, it will take longer to execute instructions when the datalogger is communicating with another device. Also, the time it takes for the datalogger to execute each scan of the program depends on whether the program is compiled in PipelineMode or SequentialMode.
    InstructionTimes can be inserted into a program that is returning a variable out of bounds error to indicate which variable is in error. A variable out of bounds error, along with the line number of the instruction that is causing the problem, will show up in the Compile Results of the datalogger.

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): Dest (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"InstructionTimes({Dest})"


def IPInfo(
    Interface: Literal["0", "1", "2", "3", "5"], Option: Literal["0", "1"]
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ipinfo.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ipinfo.htm).

                The IP address can be requested in Ipv4 or Ipv6 format. If the network interface is not present, this function returns a blank string. If the interface is present but an IP address has not been assigned, it will return “0.0.0.0”. For an IPv6 address, this function returns the global address if present; otherwise, it returns the local address.
    The IPInfo instruction can also be used to return the remote IP address associated with an IP socket resource handle. The function will return the IPv4 or IPv6 address of the remote host used for the connection. The Option parameter is ignored in this case.

    Args:
                    Interface (Variable | Constant): Selects the device to be read by the function. Right-click the parameter for a drop-down list of options:
      Must be one of following options: 0 (Ethernet), 1 (PPP), 2 (CS I/O Interface(1)), 3 (CS I/O Interface(2)), 5 (USB)

            Option (Variable | Constant): Indicates what version of IP address to return from the datalogger. Right-click the parameter for a drop-down list of options: This parameter is ignored if the instruction is used to return the IP address associated with an IP socket resource handle.
      Must be one of following options: 0 (IPv4), 1 (IPv6)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"IPInfo({Interface},{Option})"


def IPRoute(IPAddr: Variable, IPInterface: Constant, ExclusiveOption: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iproute.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iproute.htm).

                When multiple IP Internet Protocol. A TCP/IP internet protocol. interfaces (e.g., Ethernet port, CS I/O port, Wi-Fi, PPP) are active, the IPRoute instruction is used to direct outgoing IP traffic such as email, FTP, or HTTP through a specified port.
    Where the x’s represent the IP octets of the DNS server IP address.
    If the IPRoute instruction is placed within a Scan/NextScan, the instruction will not be executed at compile time, but rather when the instruction is encountered in the scan. If IPRoute appears between BeginProg and Scan, the instruction will be executed only at compile time.

    Args:
                    IPAddr (Variable): The IP address for the socket you are trying to open. This is a string variable, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255), or an IPv6 address, or a fully-qualified domain name (for example, "computer-name.domain.com"). Numeric IPv4 addresses should be entered in decimal notation, with no leading zeros (i.e., 192.168.1.123, not 192.168.001.123). If you use a domain name, the address of a DNS Domain name server. A TCP/IP application protocol. server must be specified in datalogger settings. For all instructions except UDPOpen and IPRoute, the IPAddr can also be set to a null string (""), in which case the datalogger will listen for an incoming TCP/IP connection on the specified port. The entry for the IPAddr must be enclosed in quotes. Beginning with OS 3, specifying empty quotes ("") for the IPAddr sets the specified IPInterface as the default network (gateway).

            IPInterface (Constant): Specifies the active interface to use for the outgoing IP Internet Protocol. A TCP/IP internet protocol. communication. Right click for a drop-down list of options. 0 = Internal Ethernet1 = PPP2 = CS I/O Interface(1) (by default NL201)3 = CS I/O Interface(2) (by default NL241)5 = USB

            ExclusiveOption (Constant): Optional parameter added with OS 2. Determines if the datalogger will attempt a connection through another IPinterface, if the attempt to route through the specified IPinterface fails. The ExclusiveOption is useful if more than one active interface is available (e.g., PPP and Ethernet) but the specified interface should be used exclusively for this outgoing communication. 0 or absent =            Allow routing through another active interface1                           = Do not allow routing through another active interface

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"IPRoute({IPAddr},{IPInterface},{ExclusiveOption})"


def IPTrace(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iptrace.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/iptrace.htm).

                The IPTrace returns the number of characters written to the Dest variable. Dest should be formatted as a String variable dimensioned large enough to hold an error message (for example, Dim Dest As String * 100).
    The IP Trace Code in the datalogger’s Settings must be enabled for this function to return a value or store messages to the destination variable.

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): Dest (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"IPTrace({Dest})"


def Len(StringVar: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/len.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/len.htm).

    Args:
        StringVar (Variable): The variable name of the string that will be evaluated using the Len function. The size of the StringVar must be set large enough to accommodate the size of the actual string (including the null-termination character), or the maximum value Len will return will be the size of the string (even if the actual string is larger). Note that strings are null-terminated; the null termination character counts as one of the characters in the string. If a Size is not specified when the StringVar is defined, the default string size is 24 (23 usable bytes and 1 null terminator).

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Len({StringVar})"


def LevelCrossing(
    Source: Variable | Array,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
    NumLevels: Constant,
    SecondDim: Constant,
    CrossingArray: Array,
    SecondArray: Array,
    Hysteresis: Constant,
    Option: Literal["A", "A", "B", "B", "C", "C"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/levelcrossing.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/levelcrossing.htm).

                The first dimension of the histogram created by this instruction is the levels crossed. The second dimension, if used, is the value of a second input at the time the crossings are detected.
    The crossing levels (CrossingArray) for the first source element and the upper boundary levels (SecondArray) for the second source element are contained in variable arrays. This permits the crossing and boundary level values to be loaded into the arrays by the program. If a second array is used (SecondDim > 1, with values loaded into SecondArray), a two dimensional histogram is created. The second source element is compared to the boundary values in the SecondArray only when a Level Crossing by the first source element has occurred. The levels should be loaded into the arrays sequentially from the lowest values to the highest.

    Args:
                    Source (Variable | Array): The name of the first Variable that is the input for the instruction. If a two dimensional Level Crossing Histogram is desired, then the source must be at least a two dimensional array. The array element specified in the Source argument will be compared to the crossing levels (set in CrossingArray). The next element of the source array will be compared to the boundary levels set by the SecondArray.  The source value(s) may be the result of a measurement or calculation. When a DataTable having a Level Crossing instruction is called, the Source's first element is checked to see if its value has changed from the previous value. Only when the value of the first Source element crosses one or more of the levels set by the Crossing Array, is the count of one or more (depending upon how many levels are crossed) of the histogram bins incremented. The second Source element is compared to the values in the SecondArray only when a level crossing by the first source element has occurred. Right-click the parameter to display a list of defined variables.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

            NumLevels (Constant): The NumLevels argument determines the number of levels on which to count crossings. This is the number of bins in which to store the number of crossings for the associated level. The number of crossing levels that the first dimension has is set by the NumLevels argument. The Crossing Array must have as many array elements as the numeric value of the NumLevels argument.

            SecondDim (Constant): The number of boundary level values too which the second Source element will be compared. The second dimension is separated into a set by the SecondDim argument. The SecondArray must have as many array elements as the numeric value of the SecondDim argument. If a one dimensional Level Crossing histogram is desired, this argument should be set to a value of 1, and the second array should be left empty.  If a two dimensional LevelCrossing histogram is desired, then the SecondDim argument must be greater than one. The actual Boundary levels should be loaded into the SecondArray argument.

            CrossingArray (Array): The name of the array that contains the Crossing levels to compare the first element of the Source array against. The first dimension of the histogram is broken up into discrete Crossing Levels according to the values in the Crossing Array. The number of Crossing Levels is set by the NumLevels argument. Therefore, the Crossing Array must be dimensioned to at least the value of the NumLevels argument. The levels should be loaded into the arrays sequentially from the lowest values to the highest. Right-click the parameter to display a list of defined variables.

            SecondArray (Array): The name of the array that contains the upper bin limits to compare the second element of the Source array against. The first range is everything below the first element in the SecondArray. The second range is all values greater than or equal to the first element and less than the second element of the SecondArray; and so on. The number of ranges that the second dimension has is determined by the SecondDim argument, so this array must be dimensioned to at least the value of the SecondDim argument. The boundary levels should be loaded into the arrays sequentially from the lowest values to the highest. Because it does not make sense to change the levels while the program is running, the program should be written to load the values into the array once before entering the scan. Right-click the parameter to display a list of defined variables.

            Hysteresis (Constant): The Hysteresis determines the minimum change in the input that must occur before a crossing is counted. If this value is too small, noise could be counted as crossings. For example, suppose 5 is a crossing level. If the input is not really changing but is varying from 4.999 to 5.001, a Hysteresis of 0 would allow all these crossings to be counted. Setting the Hysteresis to 0.1 would prevent this noise from causing counts.

            Option (Constant): The Option argument can program the level crossing histogram to output the actual number of times that the signal crossed the level associated with an individual bin, or it can be set to output the fraction of crossings associated to that bin with respect to the total number of crossings (number of crossings associated with an individual bin divided by the total number of crossings associated with all of the bins). The option argument is also used to program the histogram to count on either the rising or falling edge, and whether or not to reset the histogram after each output. The Option Code consists of three elements: ABC. Right-click the parameter to display a list. NOTE: When a histogram is reset, a new histogram is created and stored in the data table at the data table's output interval. The number of new data points that are used for calculating subsequent histograms is determined by the ratio of the data table output rate to the scan interval: (data table output rate)/(scan interval). Choose whether or not the histogram should be reset (all bins are set to zero) after each output. If the histogram is not reset, the values in each bin will continue to accumulate as long as the program runs.
      Must be one of following options: A (Count on falling edge.), A (Count on rising edge.), B (Reset histogram counts to 0 after each output.), B (Do not reset histogram counts.), C (Divide count in each bin by total number of counts in all bins.), C (Output total counts in each bin.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"LevelCrossing({Source},{DataType},{DisableVar},{NumLevels},{SecondDim},{CrossingArray},{SecondArray},{Hysteresis},{Option})"


def LI7200(
    Destination: Literal["0", "1", "2", "3", "4", "5", "6", "7"],
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    LI7200Cmd: Literal["0", "1", "2", "3", "4", "5", "6", "7"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/li7200.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/li7200.htm).

              The LI7200 instruction is used to communicate with the LI-7200 via SDM.

    Args:
                  Destination (Array): The input variable name in which to store the data from each LI-7200 associated with this instruction. The length of the input variable array will depend on the number of repetitions and on the selected command.
    Must be one of following options: 0 (2), 1 (5), 2 (10), 3 (12), 4 (10), 5 (5), 6 (1), 7 (5)

          Reps (Constant): Determines the number of gas analyzers with which to communicate using this instruction. The gas analyzers must have sequential SDM addresses if the Reps parameter is greater than 1.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          LI7200Cmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): Requests the data to be retrieved from the sensor. The command is sent first to the device specified by the SDMAddress parameter. If the Reps parameter is greater than 1, subsequent LI-7200s will be issued the command with each repetition. The results for the command will be returned in the array specified by the Dest parameter. A numeric code is entered to request the data:
    Must be one of following options: 0 (CO2 dry (μmol/mol), H2O dry (mmol/mol)), 1 (CO2 (mmol/m^3), H2O (mmol/m), Ptotal (kPa), Tin (C), Tout (C)), 2 (CO2 dry (μmol/mol), H2O dry (mmol/mol), CO2 (mmol/m^3), H2O (mmol/m^3), AGC (%), Ptotal (kPa), Tin (C), Tout (C), Tavg_Tin_Tout (C), Aux channel #1), 3 (CO2 dry (μmol/mol), H2O dry (mmol/mol), CO2 (mmol/m^3), H2O (mmol/m^3), AGC (%), PTotal (kPa), Tin (C), Tout (C), Aux channel #1, Aux channel #2, Aux channel #3, Aux channel #4), 4 (CO2 (mmol/m^3), H2O (mmol/m^3), CO2 absorptance, H2O absorptance, AGC (%), Ptotal (kPa), Tin (C), Tout (C), Block Temperature (C), diagnostic), 5 (CO2 dry (μmol/mol), H2O dry (mmol/mol), AGC (%), Tavg_Tin_Tout (C), Ptotal (kPa)), 6 (Diagnostic), 7 (Get CO2 dry (μmol/mol), H2O dry (mmol/mol), AGC (%), Ptotal (kPa), and Tavg_Tin_Tout (C) after an SDMTrigger instruction)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"LI7200({Destination},{Reps},{SDMAddress},{LI7200Cmd})"


def LI7700(
    Destination: Literal["0", "1", "2", "3", "4", "5", "6", "7"],
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    LI7700Cmd: Literal["0", "1", "2", "3", "4", "5", "6", "7"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/li7700.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/li7700.htm).

              The LI7700 instruction is used to communicate with the LI-7700 via SDM.

    Args:
                  Destination (Array): The input variable name in which to store the data from each LI-7700 associated with this instruction. The length of the input variable array will depend on the number of repetitions and on the selected command.
    Must be one of following options: 0 (3), 1 (5), 2 (9), 3 (13), 4 (17), 5 (3), 6 (7), 7 (9)

          Reps (Constant): Determines the number of gas analyzers with which to communicate using this instruction. The gas analyzers must have sequential SDM addresses if the Reps parameter is greater than 1.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          LI7700Cmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): Requests the data to be retrieved from the sensor. The command is sent first to the device specified by the SDMAddress parameter. If the Reps parameter is greater than 1, subsequent LI-7700s will be issued the command with each repetition. The results for the command will be returned in the array specified by the Dest parameter. A numeric code is entered to request the data:
    Must be one of following options: 0 (CH4D (mmol/m^3), pressure (kPa), Temp (C)), 1 (CH4D (mmol/m^3), pressure (kPa), Temp (C), diagnostic, RSSI), 2 (CH4D (mmol/m^3), pressure (kPa), Temp (C), diagnostic, RSSI, AUX1, AUX2, AUX3, AUX4), 3 (CH4D (mmol/m^3), CH4 (umol/mol), pressure (kPa), Temp (C), diagnostic value, RSSI, AUX1, AUX2, AUX3, AUX4, AuxTc1, AuxTc2, AuxTc3), 4 (CH4D (mmol/m^3), CH4 (umol/mol), pressure (kPa), Temp (C), diagnostic, RSSI, AUX1, AUX2, AUX3, AUX4, AuxTc1, AuxTc2, AuxTc3, AUX5, AUX6, AUX7, AUX8), 5 (RSSI, diagnostic, drop rate), 6 (RSSI, diagnostic, heater, drop rate, OpticsRH (%), LCTActual, LCSetPT), 7 (RSSI, heater, RefRSSI, drop rate, LCTActual, LCTSetPT, BCTActual, BCTSetPT, OpticsRH (%))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"LI7700({Destination},{Reps},{SDMAddress},{LI7700Cmd})"


def Log(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/logorln.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/logorln.htm).

                The Number argument can be any valid numeric expression that results in a value greater than 0. The natural logarithm is the logarithm to the base e. The constant e is approximately 2.718282. You can calculate base-n logarithms for any number x by dividing the natural logarithm of x by the natural logarithm of n as follows:
    LOGN( x ) = LOG( x ) / LOG( n )
    A NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is returned if Number is a NAN or equal to/less than 0.

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Log({number})"


def LN(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/logorln.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/logorln.htm).

                The Number argument can be any valid numeric expression that results in a value greater than 0. The natural logarithm is the logarithm to the base e. The constant e is approximately 2.718282. You can calculate base-n logarithms for any number x by dividing the natural logarithm of x by the natural logarithm of n as follows:
    LOGN( x ) = LOG( x ) / LOG( n )
    A NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is returned if Number is a NAN or equal to/less than 0.

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"LN({number})"


def Log10(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/log10.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/log10.htm).

    The Number argument can be any valid numeric expression that has a value greater than 0. You can calculate base-n logarithms for any number x by dividing the logarithm base 10 of x by the logarithm base 10 of n as follows:

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Log10({number})"


def LowerCase(
    SourceString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/lowercase.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/lowercase.htm).

    Args:
        SourceString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to be acted upon with this instruction. NOTE: String functions are case sensitive. Uppercase or lowercase can be used to convert to all one case prior to processing the string if desired.

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"LowerCase({SourceString})"


def Maximum(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
        "FP2",
        "IEEE4"
    ],
    DisableVar: Variable | Constant | Expression,
    Time: Literal["0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maximum.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maximum.htm).

                The time that the maximum value occurred can also be output. The datalogger will store the maximum value, followed by the time the maximum value occurred. If the Reps parameter is greater than one, all the maximum values are stored first, followed by all the times the maximum values occurred.
    The Maximum is reset when the data is output to a table. It can also be reset under program control by setting the DisableVar to 12345.
    If the DisableVar is true for the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Also, If a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer is expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. is -7999, so NAN for FP2 data will appear in a data table as -7999. If the data type is Long, NAN will appear in the data table as -2147483648.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. For the Mmaximum instruction, the Reps parameter is the number of variables for which a maximum value should be stored to the DataTable. When this parameter is greater than 1, the Source must be an array.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep.

            Time (Constant): Option to store the time of the Maximum or Minimum.
      Must be one of following options: 0 (Do not store time), 1 (Store time)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Maximum({Reps},{Source},{DataType},{DisableVar},{Time})"


def MaxSpa(Dest: Variable | Array, Swath: Constant, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maxspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maxspa.htm).

        The MaxSpa function finds the maximum value and its location in the given Source array and places the results in the variable array named in Dest. Source and/or Dest can be a Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. or Long Data type used when declaring a variable as an integer. data type, but not a String A data type used when declaring a variable consisting of alphanumeric characters..

    Args:
            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the MaxSpa instruction, the Dest variable must be dimensioned to 2. Dest(1) will contain the value and Dest(2) will contain the location.

    Swath (Constant): The number of values of the array over which to perform the specified operation.

    Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"MaxSpa({Dest},{Swath},{Source})"


def Median(
    Reps: Constant,
    Source: Variable,
    MaxN: Constant,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/median.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/median.htm).

                Median is an output instruction that is included within a data table declaration. Each time the data table is called and the output condition is False, the current Source value is stored to an array in memory. This array is dimensioned with MaxN number of elements; therefore, no more than MaxN values are retained in memory. If the output condition is not set true prior to MaxN being reached, the oldest value stored in the array is discarded. When the output condition is True, the instruction returns the Median of those values and memory for the instruction is cleared. If the number of values for which the median is calculated is an even number, the two median values are averaged.
    If the DisableVar is true for the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Also, If a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. is -7999, so NAN for FP2 data will appear in a data table as -7999. If the data type is Long Data type used when declaring a variable as an integer., NAN will appear in the data table as -2147483648.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. For the Median instruction, the Reps are the number of variables for which to calculate a median (a separate Median is calculated for each variable). If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error is returned when the program is compiled.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

            MaxN (Constant): The maximum number of values the datalogger should maintain in memory for the instruction, from which the median will be calculated. This memory is set up as ring memory, meaning old values will be overwritten with new values if the number of values stored before output is greater than MaxN. Thus, the last MaxN values will be used to calculate the output.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Median({Reps},{Source},{MaxN},{DataType},{DisableVar})"


def MenuItem(MenuItemName: Variable | Constant, MenuVariable: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menuitem.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menuitem.htm).

                The MenuItemName parameter is the name that will be displayed on the custom menu for a value. The name is limited to 512 characters, including characters for the associated measurement value. However, its practical size is much less because of the small size of the keyboard display. MenuItemName should be enclosed in quotation marks. The Variable parameter is the variable name of the value to be displayed. Values displayed using MenuItem can be edited, either by typing in a value directly or by creating a pick list of values using MenuPick. (MenuPickis optional, but if used, it must immediately follow the MenuItem for which the list is being generated.)
    MenuItem can be used to create a custom menu for changing values in a constant table. Values can be entered by typing them in directly or from a pick list created by using MenuPick. Refer to MenuRecompile for additional information.
    NOTE: Use DisplayValue to display data table values or variables that should not be edited.

    Args:
                    MenuItemName (Variable | Constant): The name that will be displayed on the custom menu for a measurement or datatable value. The name is limited to 512 characters, including characters for the associated measurement value. However, its practical size is much less because of the small size of the keyboard display.  MenuItemName should be enclosed in quotation marks.

            MenuVariable (Variable): The variable name used in the program for the measurement value that should be displayed.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MenuItem({MenuItemName},{MenuVariable})"


def MenuPick(MenuPickItem: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menupick.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menupick.htm).

                If a pick list of options is desired for a MenuItem, the MenuPick instruction must immediately follow the MenuItem for which the list is being generated. Each item in the list is separated by a comma. The pick list is limited to a total of 512 characters. The Items in the pick list must be constants.
    MenuPick can also be used to create a custom menu item with a pick list for changing values in a constant table. To change the value of a constant in a constant table, the constant must be in the constant table and the constant name must be the first parameter in MenuPick (see example program 2). Refer to MenuRecompile for additional information.

    Args:
                    MenuPick Item (Constant): Enter the items to be used for the pick list for a MenuItem. Each item is separated by a comma. The pick list is limited to a total of 512 characters.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MenuPick({MenuPickItem})"


def MenuRecompile(
    CompileString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    CompileVar: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menurecompile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/menurecompile.htm).

                The MenuRecompile instruction must appear within a custom menu declaration (DisplayMenu/EndMenu). It is used along with the MenuItem and MenuPick instructions to create a custom menu item with a pick list for changing values in a constant table (ConstTable/EndConstTable). Typically a user must enter a value manually for a constant table value. The pick list provides a more convenient and less error-prone way to enter new values.
    When used in this capacity, MenuItem's MenuVariable parameter should be the name of the constant defined in the constant table for which a pick list will be created. MenuPick's first Item should be the name of the constant, as well. MenuRecompile, followed by MenuPick, is then used to save the changes to the constant table and recompile.

    Args:
                    CompileString (Variable | Constant | Expression | Array | Integer | ConstantInteger): A line of text that will be used for the recompile menu item in the custom menu. Up to 11 characters will be displayed for the menu item in the custom menu, and up to 21 characters will be displayed as a header for recompile yes or no pick list.

            CompileVar (Variable | Constant | Expression | Array | Integer | ConstantInteger): A Boolean variable that is evaluated to determine whether or not the program should be compiled. This variable is set when Yes or No is selected from the recompile menu, or it can be set by some other means in the program.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MenuRecompile({CompileString},{CompileVar})"


def Mid(
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Start: Integer,
    Length: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mid.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mid.htm).

        The Start and Length parameters are used to determine which part of the SearchString is returned. Regardless of the value of the Length parameter, the returned string is no longer than the original string.

    Args:
            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

    Start  (Integer): Specifies where in the SearchString to begin. A 1 indicates the first character in the string. If Start is beyond the current length of the string (first null), a null string is returned.

    Length  (Integer): Specifies the maximum number of characters returned from the original string.  String variables can be declared as only one or two dimensions; for example, String(x) or String(x,y). To begin reading or modifying a string at a particular location into the string, enter the location as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element.   NOTE: String functions are case sensitive. Uppercase or lowercase can be used to convert to all one case prior to processing the string if desired.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"Mid({SearchString},{Start},{Length})"


def Minimum(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
        "FP2",
    ],
    DisableVar: Variable | Constant | Expression,
    Time: Literal["0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minimum.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minimum.htm).

                The time that the minimum value occurred can also be output. The datalogger will store the minimum value, followed by the time the minimum value occurred. If the Reps parameter is greater than one, all the minimum values are stored first, followed by all the times the minimum values occurred.
    The Minimum is reset when the data is output to a table. It can also be reset under program control by setting the DisableVar to 12345.
    If the DisableVar is true for the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is stored. Also, If a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 is -7999, so NAN for FP2 data will appear in a data table as -7999. If the data type is Long, NAN will appear in the data table as -2147483648.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. For the Minimum instruction, the Reps parameter is the number of variables for which a minimum value should be stored to the DataTable. When this parameter is greater than 1, the Source must be an array.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep.

            Time (Constant): Option to store the time of the Maximum or Minimum.
      Must be one of following options: 0 (Do not store time), 1 (Store time)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Minimum({Reps},{Source},{DataType},{DisableVar},{Time})"


def MinSpa(Dest: Variable | Array, Swath: Constant, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minspa.htm).

                The MinSpa function finds the minimum value and its location in the given Source array and places the results in the variable array named in Dest. Source and/or Dest can be a Float or Long data type, but not a String.
    If a NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is returned by the datalogger it is not included in the spatial minimum.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the MinSpa function, the Dest variable must be dimensioned to 2. Dest(1) will contain the value and Dest(2) will contain the location.

            Swath (Constant): The number of values of the array over which to perform the specified operation.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MinSpa({Dest},{Swath},{Source})"


def ModemCallback(
    Result: Literal[
        "0",
        "1,",
        "-1",
        "-16",
        "-17",
        "-18",
        "-20",
        "-21",
        "-22",
        "-27",
        "-30",
        "-31",
        "-32",
        "-33",
        "-34",
        "-35",
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    BaudRate: Constant,
    Security: Integer,
    DialString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ConnectString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Timeout: Constant,
    Retry: Constant,
    AbortExp: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modemcallback.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modemcallback.htm).

                The computer must be running LoggerNet configured to accept a callback from the datalogger. When LoggerNet receives a callback attempt from the datalogger, it will collect any new table data that has been stored since the last data collection (the data collection could be a scheduled call, a manual call initiated from LoggerNet's Connect window, or from another callback).
    ModemCallback can also be used to initiate a dialed call to another datalogger. The datalogger initiating the call will attempt to set a variable named Callback in the datalogger's Public table. This variable can then be used as a flag to trigger some other action.
    After the modems successfully connect, the datalogger will issue a broadcast Hello Request to determine the address of the neighbor to which it has connected. If a neighbor is found, the datalogger will send a SendVariable() callback message (i.e., it will set a Public variable named CallBack to -1). If no neighbor is discovered, it will continue to send the Hello Request until a neighbor is discovered or the timeout period expires.
    Note that once executed, this instruction runs in the background. The datalogger will not wait for successful communication before moving on to the next instruction.

    Args:
                    Result (Variable): The Result parameter is the variable in which a response code for the instruction will be stored. This response indicates the status of the dialing attempt (codes -30 through -35) and ultimately, whether or not the attempt was successful. A positive value indicates that there was no response to the request from the remote, and thus, the attempt was unsuccessful. A negative value indicates some other type of error occurred. A zero indicates a successful transaction. Because the support software will set the Abort variable to True to hang up the call, a -33 indicates that the callback attempt was successful or was aborted by the program or user in some other way. It will remain -33 until the Abort variable is set False by the program or some other means. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.), -1 (Response received but permission denied.), -16 (Table name and/or field name not present in the source datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the source datalogger is not dimensioned large enough to accommodate the values to be sent or array in the destination datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), -30 (Dialing), -31 (Dialed successfully, waiting for connection), -32 (Connected, sending message to LoggerNet), -33 (Attempt aborted by abort expression), -34 (ComPort is busy with some other function), -35 (Modem not echoing AT commands, sending +++ and toggling power to modem)

            ComPort (Constant): The ComPort parameter specifies the communication port and mode that will be used for this instruction. A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            DialString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The telephone number and any other codes used to dial the modem. A semi-colon is used to separate multiple commands. Two semi-colons in a row will insert a 1 second delay before continuing to the next characters in the string. If only a phone number is used for the DialString parameter the datalogger will automatically issue an ATDT prior to issuing the number. If an AT command is added to the DialString parameter (e.g., ATV1ATDT) the automatic ATDT is not issued.

            ConnectString (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to specify the response code expected back from the modem when a connection is made. The ConnectString will succeed even when a partial response string is entered (for instance, a ConnectString of "Connect" will be successful if the response code is "Connect", "Connect 9600", or "Connect 1200"). When using the COM220 modem, enter a null string (""). The COM220 can return one of eight responses, depending upon the baud rate at which the connection is made (1 – Connect, 5 – Connect1200, 10 – Connect2400, 13 – Connect9600, 18 – Connect4800, 20 – Connect7200, 21 – Connect12000, 25 – Connect14400). When a null string is entered, the datalogger will compare the modem's response with these eight known responses in an attempt to establish communication.

            Timeout (Constant): Used to specify the maximum time, in seconds, for dialing and connecting to the LoggerNet server (or remote datalogger). Valid entries for Timeout are 10 through 120 seconds. If the Timeout is exceeded and no connection has been made the datalogger will enter its Retry mode. When the Timeout period expires, the modem is turned off until the next retry. After 10 unsuccessful retries, the instruction will abort the attempt to connect.

            Retry (Constant): The amount of time, in seconds, that the datalogger should wait before attempting another callback. The retry will take place at a random interval that falls between RetryInterval and 2*RetryInterval.

            AbortExp (Variable): Used to abort the callback attempt and stop any further attempts. If AbortExp is a variable the datalogger will immediately set its AbortExp parameter to True when a callback attempt succeeds. The instruction will not execute when AbortExp is True, and it will abort in the middle of dialing if the expression turns True.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ModemCallback({Result},{ComPort},{BaudRate},{Security},{DialString},{ConnectString},{Timeout},{Retry},{AbortExp})"


def Moment(
    Reps: Variable,
    Source: Variable,
    Order: Literal["2", "3", "4", "5"],
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/moment.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/moment.htm).

              This instruction is intended for use on a sample data set rather than a random variable in mathematical statistics theory. Each moment represents a measurement of a particular feature of a random variable that the sample data set represents. Users should be aware that this instruction can be very process intensive for certain applications and considerations on variable data types should be made.

    Args:
                  Reps (Variable): The number of variables for which to calculate a moment (a separate Moment will be calculated for each variable). If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable out of Bounds error will be returned when the program is compiled.

          Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

          Order (Variable | Constant | Expression | Array | Integer | ConstantInteger): The order of polynomial to be used when calculating the moment. The following options are valid:
    Must be one of following options: 2 (Average over i (x(i) - Mean)^2), 3 (Average over i (x(i) - Mean)^3), 4 (Average over i (x(i) - Mean)^4), 5 (Average over i (x(i) - Mean)^5)

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

          DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Moment({Reps},{Source},{Order},{DataType},{DisableVar})"


def MonitorComms(Destination: Variable, ComNum: Constant, Output: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/monitorcomms.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/monitorcomms.htm).

        The datalogger has a "comms watch" terminal communication mode (mode W) that lets you watch communication traffic on a specified port. This is useful for debugging communication with other devices, such as an SDI12 or serial sensor. The W mode in the datalogger streams ASCII or binary information to a terminal window. The MonitorComms instruction writes this same information to the string variable defined by the Dest parameter.

    Args:
            Destination (Variable): A string variable in which to hold the communication information coming from the specified port.

    ComNum (Constant): Specifies the port on which to monitor communication traffic. Right-click the parameter within the CRBasic Editor to see a list of valid port options.

    Output (Constant): Determines whether the resulting string is returned in ASCII or Binary format. Enter 1 for ASCII or 0 for Binary.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"MonitorComms({Destination},{ComNum},{Output})"


def Move(
    Dest: Variable | Array, DestReps: Constant, Source: Variable, SourceReps: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/move1.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/move1.htm).

    Args:
            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

    Reps (Constant): The number of repetitions for the measurement or instruction. For the Move instruction, the DestReps parameter is the number of variables in which the variables being moved are stored.

    Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the Move instruction, the Source parameter is used to define the first variable from which variables will be moved. If a constant is entered here, that value is placed in each variable defined by the Dest and DestRep parameters.

    Reps (Constant): The number of repetitions for the measurement or instruction. For the Move instruction, the SourceReps parameter is the number of variables that should be moved into the Dest array. This parameter should be set equal to the DestReps parameter, or, as a special case, set to 1. If this parameter is set to 1, the same value is placed in each variable of the Dest array.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"Move({Dest},{DestReps},{Source},{SourceReps})"


def MoveBytes(
    Destination: Variable | Array,
    DestOffset: Variable | Constant,
    Source: Variable | Array,
    SourceOffset: Variable | Constant,
    NumBytes: Variable | Constant,
    Transfer: Literal["0", "1", "2", "3", "4"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/movebytes.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/movebytes.htm).

                The CR1000X uses the big-endian Endianness refers to byte order.  With the little-endian format, bytes are ordered with the least significant byte (the "little end") first.  With the big-endian format, bytes are ordered with the most significant byte ("big end") first. The CR300, GRANITE 9, and GRANITE 10 dataloggers use the little-endian format. The CR800, CR1000, CR3000, CR6, CR1000X, and GRANITE 6 use the big-endian format. Byte order when sending string variables as serial data is identical in big-endian and little-endian CSI dataloggers. Only numeric values sent as multiple bytes require attention to big-endian and little-endian issues. system for storing multi-byte data. When sending serial data to another device it may be necessary to move the serial data to a different memory location if the receiving device uses a little-endian system. The MoveBytes instruction can be used to accomplish this.
    NOTE: Offsets in this instruction are zero-based (rather than one-based). Byte order when sending string variables as serial data is identical in big-endian and little-endian Campbell Scientific dataloggers. Only numeric values sent as multiple bytes require attention to big-endian and little-endian issues.

    Args:
                    Destination (Variable | Array): The variable in which the moved bytes will be stored.

            DestOffset (Variable | Constant): The offset into the memory location of the Destination variable, where the binary data will be stored.

            Source (Variable | Array): The binary data that should be copied into Destination. Note that Source remains unchanged after the move occurs.

            SourceOffset (Variable | Constant): The offset into the memory location of the Source variable, from where the binary data should be read.

            NumBytes (Variable | Constant): The number of bytes that should be placed in the Destination variable.

            Transfer (Variable | Constant | Expression | Array | Integer | ConstantInteger): Transfer is an optional parameter that simplifies moving bytes between devices with different endianess Endianness refers to byte order.  With the little-endian format, bytes are ordered with the least significant byte (the "little end") first.  With the big-endian format, bytes are ordered with the most significant byte ("big end") first. The CR300, GRANITE 9, and GRANITE 10 dataloggers use the little-endian format. The CR800, CR1000, CR3000, CR6, CR1000X, and GRANITE 6 use the big-endian format. Byte order when sending string variables as serial data is identical in big-endian and little-endian CSI dataloggers. Only numeric values sent as multiple bytes require attention to big-endian and little-endian issues.. This option is commonly used when creating cross-datalogger platform code for the parsing, or formation, of communication packets. The transfer feature allows specification of the required endianness of the Destination packet and allos the datalogger to automatically perform byte swapping. Note that byte swapping only occurs if the Source endianness is different than the specified Destination endianess. Valid options are:
      Must be one of following options: 0 (No byte swapping (just move the bytes)), 1 (Destination is little-endian (LE), 2 byte block swapping), 2 (Destination is little-endian (LE), 4 byte block swapping), 3 (Destination is big-endian (BE), 2 byte block swapping), 4 (Destination is big-endian (BE), 4 byte block swapping)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MoveBytes({Destination},{DestOffset},{Source},{SourceOffset},{NumBytes},{Transfer})"


def MovePrecise(PrecisionVariable: Variable, X: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/moveprecise.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/moveprecise.htm).

        In this function, the variable X is moved into the PrecisionVariable as a high precision value. Every reference to the PrecisionVariable will cause a 32 bit extension of its mantissa to be saved and used internally. A normal single precision float has 24 bits of mantissa; therefore, this new precision is 56 bits.

    Args:
            PrecisionVariable (Variable): The variable that will be affected by the precision move or add.

    X (Variable): The value that will be moved to or added to the PrecisionVariable. It may or may not be a high precision variable, depending upon whether it has been declared as such in a previous AddPrecise or MovePrecise instruction. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"MovePrecise({PrecisionVariable},{X})"


def ModbusServer(
    ComPort: Literal[
        "0",
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
        "502",
    ],
    BaudRate: Constant,
    ModbusAddr: Variable | Integer,
    ModbusVariable: Variable,
    BooleanVariable: Variable | Constant,
    ModbusOption: Literal["0", "1", "2", "3", "10", "11", "12", "13"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modbusserver.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modbusserver.htm).

                This instruction sets up a Modbus server device. As a Modbus server, the datalogger will respond to data request from a Modbus client over serial and TCP/IP. Supported Modbus functions are 01, 02, 03, 04, 05, 15, and 16. See the Modbus Client() help for details on these functions.
    NOTE: The datalogger uses 8 data bits and no parity for Modbus communication. This can be changed by preceding the Modbus instruction with a SerialOpen instruction that sets the desired data bit and parity values.
    The instruction only needs to be executed once, and therefore may appear outside the main program scan. It is commonly inserted directly after the BeginProg statement. One or more instance of ModbusServer() may be used in a single program. Multiple instances are most commonly used to configure multiple interfaces.
    To route Modbus over a PakBus Network, in the router’s program, include a DataGram() instruction for every Modbus Server in the network. All server PakBus addresses must match their ModbusServer() addresses. If the Modbus Client is querying using TCP Modbus, then the DataGram() destination ID is 504 and source ID is 503. If the client is using RTU Modbus, then the DataGram() destination ID is 502 and the source ID is 501. At each of the remote servers, the ModbusServer() instructions comport is -2 for TCP Modbus and 0 for RTU Modbus, which signals the Modbus Server that they are looking for Modbus via PakBus datagrams carrying the Modbus request.

    Args:
                    ComPort (Constant): The COM port that will be used by the instruction. Right-click to display a list. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. Option 0, Modbus/PakBus, configures the datalogger to respond to Modbus RTU delivered via PakBus Datagrams with a destination Application ID of 502. A specific COM port is not specified as the Modbus request can be delivered over any active PakBus interface. This option is most commonly used in conjunction with an NL100 or with another logger configured with the DataGram() instruction. Additionally, this option is used when a user needs to route Modbus communications across a complex network or wants to use a single communications link for both Modbus and BMP5 communications via PakBus. Setting the ComPort parameter to 502 or greater will specify the Modbus TCP/IP service port. The datalogger listens for Modbus TCP/IP communication on one IP port at a time; i.e., the logger will not listen on ports 502 and 503 at the same time. Avoid using port 6785 as that is the default PakBus TCP service port number. A variable can be used in the ComPort parameter for use with functions that return a communication port.(for example, TCPOpen). If the ComPort parameter is set to 502, the datalogger will listen for a TCP connection on port number 502 and service TCP Modbus commands over TCP/IP instead of one one of the physical ComPorts.
      Must be one of following options: 0 (Modbus packets routed via PakBus (using Datagram protocol; application ID =
    502)), ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8), 502 (Modbus TCP/IP, for data requests via Modbus TCP/IP protocol)

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list. This setting does not apply to Modbus TCP/IP or Modbus/Pakbus (ComPort = 0). A negative baud rate configures the port for automatic baud rate recognition (auto-baud). If set to auto-baud, the first communication attempt will be at the specified baud rate and failed communications will cause the datalogger to try different baud rates until successful or until the instruction times out. The datalogger uses 8 data bits and no parity for Modbus communication. This can be changed by preceding the Modbus instruction with a SerialOpen instruction that sets the desired data bit and parity values.

            ModbusAddr (Variable | Integer): The Modbus address of the server.  Valid range is 1-255 (excluding 189, which is the PakBus sync byte). Address 0 is a broadcast address. Multiple addresses can be assigned to a single interface by using multiple ModbusClient() instructions The ModbusAddr can be used to specify an offset for the starting register. Enter Starting Register * 1000 + the address. (i.e., the most significant digits specify the offset and the last three digits specify the Modbus address). For instance, for a starting register of 1500 and an address of 3, enter 1500003. NOTE: If ModbusAddr is set to a negative value, the datalogger will discard any bytes that are echoed back to it. Multiple addresses can be assigned to a single interface by using multiple ModbusServer() instructions

            ModbusVariable (Variable): Used to specify the variable array that is used as the source of data to send, or the variable array that is used as the destination for data received. This variable can be formatted for Coil, Floating Point, or Integer Modbus registers and can be formatted as either Floating Point or Integer. If Variable is declared as Long or Boolean, then this parameter is set as a Modbus integer; otherwise, floating point Modbus will be used. Longs are assumed to be signed integers (numbers will be in the range -32768..+32767). The datalogger does not differentiate between holding and input registers. The only difference is the address offset. The specified array will be used for requests of input (address offset of 30000) or holding (address offset of 40000) registers. If this parameter is declared as Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. and a Coil function code of 1, 2, 5, or 15 is used, it will be mapped to a Modbus coil in the other device.If this parameter is declared as Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. and a Register function code of 3, 4, or 16 is used, it will be mapped to a Modbus Holding or Input register as floating point.If this parameter is declared as Long Data type used when declaring a variable as an integer. and a Register function code of 3, 4, or 16 is used, it will be mapped to Modbus Holding or Input registers as an integer. Longs are assumed to be signed integers (numbers will be in the range -32768..+32767). If option 1 is used for ModbusOption, Variable should be declared as a long. If option 05, 06, 15, or 16 is used for Function, this parameter can be a constant. Floating point variables take two Modbus registers. The Modbus input registers are offset by 30000; Modbus holding registers are offset by 40000. Therefore, the first register corresponding to any array location X is holding register 40000+2X-1. For example, to retrieve array value number 3, you would ask for two registers starting with 40005. If the ModbusServer is queried by the client using an odd number of registers, then the ModbusServer datalogger assumes the request is for a 16 bit integer.

            BooleanVariable (Variable | Constant): A variable or variable array that is used to hold the result if the client sends one of the discrete on/off commands to the server (i.e., 01 Read Coil/Port Status, 02 Read Input Status, 05 Force Single Coil/Port, 15 Force Multiple Coils/Ports). This parameter must be dimensioned as a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. or a compiler error is returned.  If a 0 is entered for this parameter, then the discrete commands are mapped to control ports 1 through 8 instead. This will cause a compile warning, "A set coil function could conflict with a control port already in use." This is a warning, not an error, and the program can run successfully.

            ModbusOption (Variable): An optional parameter that is used to specify the data type of the Modbus variables. Notes: When communicating with other Modbus devices, the communications port, baud rate, data bits, stop bits, and parity are set in the Modbus driver for PC-based software or on the PLC.A datalogger acting as a Modbus server returns a Modbus exception code 01 (Illegal Function) if a query is invalid, and an exception code of 02 (Illegal data address) if data values beyond the size of an array are requested. If a client requests variables that are not defined, the VarOutofBound field is incremented in the datalogger's Status table.The datalogger usually goes into sleep mode after 40 seconds of inactivity on the communications port. After going to sleep with some interface methods it sometimes takes a packet of incoming data to wake it up and then a retry packet to get the message through.Some Modbus devices (for example, some RTUs made by Bailey Controls that use less common CPUs) require reverse word order (MSW/LSW versus LSW/MSW) in the floating point format. Some software packages have a setting to work with this original Modbus format. For example, the “Modicon 32-bit floating point order (0123 vs. 3201)” advanced option must be enabled for the Modbus object in National Instruments’ Lookout. See the MoveBytes example for a program that converts an inverse floating point number to a floating point number.
      Must be one of following options: 0 (Default; 32-bit float or Long, the standard ordering of the 2 byte registers are reversed (CDAB).), 1 (If the Modbus variable array is defined as a Long, variables are treated as 16-bit signed integers.), 2 (If the Modbus variable array is defined as a 32-bit float or a Long, with no reversal of the byte order (ABCD).), 3 (If the Modbus variable array is defined as a Long, variables are treated as
    16-bit unsigned integers.), 10 (Modbus ASCII, 4 bytes, CDAB.), 11 (Modbus ASCII, 2 bytes, signed.), 12 (Modbus ASCII, 4 bytes, ABCD.), 13 (Modbus ASCII, 2 bytes, unsigned.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ModbusServer({ComPort},{BaudRate},{ModbusAddr},{ModbusVariable},{BooleanVariable},{ModbusOption})"


def ModbusClient(
    ResultCode: Variable,
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ]
    | Variable,
    BaudRate: Constant,
    ModbusAddr: Variable | Integer,
    Function: Literal["01", "02", "03", "04", "05", "06", "15", "16"],
    ModbusVariable: Variable,
    Start: Variable | Constant,
    Length: Variable | Constant,
    Tries: Constant | Integer,
    TimeOut: Constant,
    ModbusOption: Literal["0", "1", "2", "3", "10", "11", "12", "13"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modbusclient.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/modbusclient.htm).

                The datalogger supports Modbus functions 01-06, 15, and 16 (see following Function parameter). This instruction must be executed each time you request or fix data in the Modbus server.
    NOTE: If a Modbus device requires even parity, SerialOpen must be used in the program to set the parity to even (default is no parity).
    If multiple ModbusClient instructions are used in a program, and these instructions use the same ComPort, use the SemaphoreGet/SemaphoreRelease instructions to prevent the instructions from attempting to use the communications hardware at the same time.

    Args:
                    ResultCode (Variable): The ResultCode variable holds the results of the communication attempt. ResultCode is set to 0 if communication is successful; it increments by 1 after a communication failure (a failure is an expiration of the timeout period and any Tries). If the Modbus server returns a Modbus exception code, it will be preceded by a minus sign and stored in ResultCode. Error codes returned by the server:
      Must be one of following options: -01 (Illegal function: the function code received in the query is not an allowable action for the device. The device may not support the function or it may not be in a state to process the request.), -02 (Illegal data address: the data address received in the query is not an allowable address for the device. The combination of the reference number and transfer length may be invalid.), -03 (Illegal data value: the value contained in the query data field is not an allowable value for the device.), -04 (Server device failure: an
    unrecoverable error occurred while the device was attempting to perform the requested action.), -05 (Acknowledge: the device has accepted the request and is processing it, but a long duration of time will be required to do so. This is a specialized function used in conjunction with programming commands.), -06 (Server device busy: the device is engaged in processing a long-duration program command.), -08 (Memory parity error: the device attempted to read a record file but detected a parity error in the memory. Used in conjunction with function codes 20 and 21.), -09 (Gateway path unavailable: indicates that the gateway was unable to
    allocate an internal communication path from the input port to the output port
    for processing the request.), -10 (ModbusClient error: received an unexpected function code response from server.), -11 (The specified ComPort (or TCP socket) is not opened. There is no connection to
    the Modbus server.), -16 (ModbusClient error: out of comms memory.), -20 (ModbusClient error: variable not dimensioned large enough to store results from server.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. A variable can be used in the ComPort parameter for use with functions that return a communication port (for example, TCPOpen). If the parameter is not a COM port, then it is assumed to be a socket and the instruction will use TCP/IP Transmission Control Protocol / Internet Protocol. Modbus protocol to communicate with a TCP/IP ModbusServer device.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list. The datalogger uses 8 data bits and no parity for Modbus communication. This can be changed by preceding the Modbus instruction with a SerialOpen instruction that sets the desired data bit and parity values.

            ModbusAddr (Variable | Integer): The Modbus address of the server.  Valid range is 1-255 (excluding 189, which is the PakBus sync byte). Address 0 is a broadcast address. Multiple addresses can be assigned to a single interface by using multiple ModbusClient() instructions The ModbusAddr can be used to specify an offset for the starting register. Enter Starting Register * 1000 + the address. (i.e., the most significant digits specify the offset and the last three digits specify the Modbus address). For instance, for a starting register of 1500 and an address of 3, enter 1500003. NOTE: If ModbusAddr is set to a negative value, the datalogger will discard any bytes that are echoed back to it. For the ModbusClient instruction, the ModbusAddr parameter is used to specify the address of the ModbusServer with which you are trying to communicate. Valid ranges are 1 - 127 or 1 - 247 for Modbus/PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc..

            Function (Variable | Constant): Used to define what data is being sent to or received from the ModbusServer.
      Must be one of following options: 01 (Read Coil/Port Status), 02 (Read Input Status), 03 (Read Holding Registers), 04 (Read Input Registers), 05 (Force Single Coil/Por), 06 (Write Single Register), 15 (Force Multiple Coils/Ports), 16 (Write Multiple Registers)

            ModbusVariable (Variable): Used to specify the variable array that is used as the source of data to send, or the variable array that is used as the destination for data received. This variable can be formatted for Coil, Floating Point, or Integer Modbus registers and can be formatted as either Floating Point or Integer. If Variable is declared as Long or Boolean, then this parameter is set as a Modbus integer; otherwise, floating point Modbus will be used. Longs are assumed to be signed integers (numbers will be in the range -32768..+32767). The datalogger does not differentiate between holding and input registers. The only difference is the address offset. The specified array will be used for requests of input (address offset of 30000) or holding (address offset of 40000) registers. If this parameter is declared as Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports. and a Coil function code of 1, 2, 5, or 15 is used, it will be mapped to a Modbus coil in the other device.If this parameter is declared as Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. and a Register function code of 3, 4, or 16 is used, it will be mapped to a Modbus Holding or Input register as floating point.If this parameter is declared as Long Data type used when declaring a variable as an integer. and a Register function code of 3, 4, or 16 is used, it will be mapped to Modbus Holding or Input registers as an integer. Longs are assumed to be signed integers (numbers will be in the range -32768..+32767). If option 1 is used for ModbusOption, Variable should be declared as a long. If option 05, 06, 15, or 16 is used for Function, this parameter can be a constant. Floating point variables take two Modbus registers. The Modbus input registers are offset by 30000; Modbus holding registers are offset by 40000. Therefore, the first register corresponding to any array location X is holding register 40000+2X-1. For example, to retrieve array value number 3, you would ask for two registers starting with 40005. If the ModbusServer is queried by the client using an odd number of registers, then the ModbusServer datalogger assumes the request is for a 16 bit integer.

            Start (Variable | Constant): Specifies the 16 bit address of the first register that will be requested or acted upon. The Start parameter should be entered as a number 1 to 65535. The data address, or offset, in the Modbus frame sent to the server will be equal to "Start-1". For example, to access the extended holding register commonly referred to as 40001, use a Function code of 3 and a Start parameter of 1. Note, setting the Start parameter directly to a value of 40001 will not start access at the first holding register, it will start access 40000 registers into the holding register table; this is a common mistake when using ModbusClient.

            Length (Variable | Constant): Specifies the number of CRBasic variables to act upon with this instruction. When reading coils or when using a 16-bit related ModbusOption parameter of 1, 3, 11, or 13, the Length parameter will match the number of 16 bit register values requested or acted upon. When using a 32-bit related ModbusOption parameter of 0,2,10, or 12, the datalogger will automatically double the Length value specified so that it requests 32-bits of data for each CRBasic variable.

            Tries (Constant | Integer): The number of times the ModbusClient datalogger should attempt to communicate with the ModbusServer datalogger before moving on to the next instruction.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the attempt a failure. If this parameter is negated, the timeout and any retries will take place in the background, and the datalogger will move on to the next instruction without waiting for this instruction to complete.

            ModbusOption (Variable): An optional parameter that is used to specify the data type of the Modbus variables. If a Modbus register address of greater than 40000 is needed, the ModbusAddr parameter for this instruction can take the form of rrrrrraaa, where aaa is the server device address and the number rrrrrr is the register number offset required for the particular server value. For example, if the server register address is 401203 and the device address is 7, the parameter would be entered as 401000007 and the register number used would be 203 for the parameter ModbusStart. To route Modbus packets over a PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. network, in the router’s program, include a DataGram() instruction for every ModBus server in the network (excluding the router). All server PakBus addresses must match their ModbusServer() addresses. If the Modbus Client is querying using TCP Modbus, then the DataGram() destination ID is 504 and source ID is 503. If the client is using RTU Modbus, then the DataGram() destination ID is 502 and the source ID is 501. At each of the remote servers, the ModbusServer() instruction’s comport is -2 for TCP Modbus and 0 for RTU Modbus, which signals the Modbus servers that they are looking for Modbus via PakBus DataGrams carrying the Modbus request. If the DataGram destination ID is 506, then at the RTU end, Modbus TCP is converted to Modbus RTU before sending it out the comport. Conversely, when returning a response, it is converted back to Modbus TCP before sending it out on the PakBus network.
      Must be one of following options: 0 (Default; 32-bit float or Long, the standard ordering of the 2 byte registers are reversed (CDAB).), 1 (If the Modbus variable array is defined as a Long, variables are treated as 16-bit signed integers.), 2 (If the Modbus variable array is defined as a 32-bit float or a Long, with no reversal of the byte order (ABCD).), 3 (If the Modbus variable array is defined as a Long, variables are treated as
    16-bit unsigned integers.), 10 (Modbus ASCII, 4 bytes, CDAB.), 11 (Modbus ASCII, 2 bytes, signed.), 12 (Modbus ASCII, 4 bytes, ABCD.), 13 (Modbus ASCII, 2 bytes, unsigned.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ModbusClient({ResultCode},{ComPort},{BaudRate},{ModbusAddr},{Function},{ModbusVariable},{Start},{Length},{Tries},{TimeOut},{ModbusOption})"


def MuxSelect(
    ClkPort: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    ResPort: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    ClockPW: Constant,
    MuxChan: Constant,
    Mode: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/muxselect.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/muxselect.htm).

                This instruction "wakes up" the multiplexer and clocks it to the specified starting channel. It can be used in conjunction with the SubScan and PulsePort instructions to step through the multiplexer's measurement channels to make measurements.
    When measurements are completed, the ResetPort should be set low using PortSet to turn off the multiplexer (see example).

    Args:
                    ClkPort (Constant): The port used to clock the multiplexer (for example, advance its channel). One clock port may be used to clock several devices. An alphanumeric code is entered for this argument.
      Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

            ResPort (Constant): The control port that will be used to wake up and reset the multiplexer. If multiple multiplexers are used in the program, each multiplexer must have its own unique ResetPort. An alphanumeric code is entered for this argument. Right-click to display a list.
      Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

            ClockPW (Constant): Used to control the period of the clock used to advance the multiplexer. The value is entered in milliseconds.

            MuxChan (Constant): Specifies the first measurement channel on the multiplexer. It can be a constant or a variable. If programmed as a variable, the datalogger program will be forced into SequentialMode at compile time.

            Mode (Constant): Specifies what type of clocking will be used. Enter 0 for AM16/32A clocking and 1 for AM16/32B clocking.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MuxSelect({ClkPort},{ResPort},{ClockPW},{MuxChan},{Mode})"


def NewFile(
    NewFileVar: Variable,
    FileName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NewFileName: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/newfile.htm).

        If the file being monitored has a newer timestamp than the last time the instruction was run, the NewFileVar is set to 0. This instruction was developed specifically for applications where a PC is used to trigger file creation in the datalogger (though it may have other applications as well). The PC monitors the NewFile variable to determine when a file has finished being written so it can then be retrieved.

    Args:
            NewFileVar (Variable):  The NewFileVar is a variable formatted as Boolean, Long, or Float that will hold the result of the instruction. If a new file has been stored, the variable will be set to 0. If a new file has not been stored, NewFileVar will be set to a non-zero value. If the variable is a Boolean, it is set to -1. If the variable is a Long or Float, each time the instruction is executed and a new file is not detected, it will be incremented by 1, unless the value is 0. (This allows the NewFile value to be set externally by some other means to 1, and then the value is monitored to determine if a file has been written. See the example describing an application for triggering a camera.) Find File Option When the NewFileVar is type Long and set to the value of -2, the file timestamps are ignored. The data logger will search for a filename on the drive that matches the name set in the FileName parameter.  When a file is found, the name of the file that was detected is returned in the NewFileName parameter. The value of the NewFileVar will return -2 (remain unchanged).

    "FileName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the file on the datalogger to be monitored. FileName must be enclosed in quotes. It is entered in the format of "Device:FileName" where device = CPU, CRD (memory card), USR (user-defined drive), or USB (SC115) The wildcard characters ? and * can be used in the FileName.

    NewFileName (Variable): Optional parameter available in Operating System 2 and later that returns the name of the new file. NewFileName is a variable of type String. If a new file is found, its name will be returned into the NewFileName variable. If no new file is found, a NULL string is written to the variable.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"NewFile({NewFileVar},{FileName},{NewFileName})"


def Optional(
    FunctionName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/optional.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/optional.htm).

    Args:
        FunctionName (Variable | Constant | Expression | Array | Integer | ConstantInteger): FunctionName (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Optional({FunctionName})"


def PanelTemp(Dest: Variable | Array, fN1: Literal["15000", "60", "50"]) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/paneltemp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/paneltemp.htm).

              The measurement from the PanelTemp instruction can be used as the reference temperature for thermocouple measurements.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PanelTemp({Dest},{fN1})"


def PeakValley(
    DestPV: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    DestChange: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Reps: Constant,
    Source: Variable,
    Hysteresis: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/peakvalley.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/peakvalley.htm).

        When a new peak or valley is detected, the new value and the change from the previous value are stored in variables. The minimum amount that the value of the Source array or variable must change for a new maximum or minimum to be detected is set by the Hysteresis argument.

    Args:
            DestPV (Variable | Constant | Expression | Array | Integer | ConstantInteger): Variable or array in which to store the new peak(s) or valley(s). When a new peak or valley is detected, the value of the peak or valley is loaded into the Dest argument. PeakValley will continue to load the last peak or valley value into the argument until the next peak or valley is detected. If reps is greater than 1, destination must be an array dimensioned to at least the number of reps. Type -- Variable or Array

    DestChange (Variable | Constant | Expression | Array | Integer | ConstantInteger): Variable or array in which to store the change from the previous peak or valley. When a new peak or valley is detected, the change from the previous peak or valley is loaded in the DestChange argument. When a new peak or valley has not yet been reached, 0 will be stored. When Reps are greater than 1, DestChange must be an array that is dimensioned to Reps+1. The last array element [e.g., DestChange(Reps+1)] is used to flag when a new peak or valley is detected in any of the source inputs. The flag element is stored after the changes and is set to -1 (true) when a new peak or valley is detected and set to 0 (false) when none are detected. Type -- Variable or Array

    Reps (Constant): The number of repetitions for the measurement or instruction.

    Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

    Hysteresis (Variable | Constant | Expression | Array | Integer | ConstantInteger): The minimum amount that the input source value has to differ from the last peak or valley to be considered a new peak or valley. This would usually be entered as a constant, but the rate of change can also be derived from a variable or expression. Type – Constant, Variable, or Expression

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"PeakValley({DestPV},{DestChange},{Reps},{Source},{Hysteresis})"


def PeriodAvg(
    Dest: Variable | Array,
    Reps: Constant,
    Gain: Literal["0", "1", "2", "3"],
    Chan: Constant,
    Threshold: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Option: Literal["0", "1"],
    Cycles: Constant,
    Timeout: Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/periodavg2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/periodavg2.htm).

              The PeriodAvg instruction returns the measurement of a signal in either microseconds (period) or Hertz (frequency). Processing instructions can then be used to convert the output to engineering units.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. When the Source is not an array, or only a single variable in the array should be averaged, Reps should be 1.

          Gain (Constant): Used to set the voltage gain for the input signal prior to going into the zero crossing comparator. Maximum frequency decreases with increasing gain. Enter the code for the desired option.
    Must be one of following options: 0 (1), 1 (2.5), 2 (12.5), 3 (64)

          Chan (Constant): The  channel number on which to make the first measurement. When Reps are greater than 1, subsequent measurements will be automatically made onsequential channels. Right-click the parameter to display a list.

          Threshold (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines the threshold, in millivolts, (input referred) at which the comparator will trigger to count transitions. This allows the user to measure signals not centered around the default threshold of zero Volts. This parameter should be set to the average DC voltage of the signal relative to datalogger ground.

          Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies whether to output the frequency or the period of the signal.
    Must be one of following options: 0 (Period of the signal is returned), 1 (Frequency of the signal is returned)

          Cycles (Constant): The Cycles parameter specifies the number of cycles to average each scan. The specified number of cycles are timed with a resolution of 135 ns, making the resolution of the period measurement 135 ns divided by the number of Cycles measured.

          Timeout (Constant): The maximum time duration, in milliseconds, that the logger will wait for the number of Cycles to be measured for the average calculation. An overrange value will be stored if the Timeout period is exceeded. The maximum Timeout is 1000 ms.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PeriodAvg({Dest},{Reps},{Gain},{Chan},{Threshold},{Option},{Cycles},{Timeout},{Mult},{Offset})"


def PingIP(
    PingIPAddr: Variable,
    PingIPTimeOut: Constant,
    PingOption: Literal["0", "1", "2", "3"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pingip.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pingip.htm).

              The PingIP function returns the response time (in milliseconds) if a response is received from the ping within the timeout period; otherwise, it returns 0.

    Args:
                  PingIPAddr (Variable): The IP address of the device to be pinged. This is a string variable, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255) or a fully-qualified domain name (for example, "computer-name.domain.com"). The entry for the IPAddr must be enclosed in quotes.

          PingIPTimeOut (Constant): The time, in milliseconds, that the datalogger should wait for a response back from the pinged device. If a response is not received within the timeout period, 0 will be returned.

          PingOption          (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that specifies the IP version of the address to return if the address is a domain name that needs to be resolved to a numeric IP address. The optional parameter may be configured as follows:
    Must be one of following options: 0 (Ping IPv4 first, if fail try IPv6), 1 (Ping only IPv4), 2 (Ping only IPv6 (local and global)), 3 (Ping IPv6 first, if fail try IPv4)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PingIP({PingIPAddr},{PingIPTimeOut},{PingOption})"


def PPPOpen(
    Option: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pppopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pppopen.htm).

                If PPP is configured on a datalogger, then at program start up, the datalogger automatically tries to open a PPP session. Hence, PPPOpen is not necessary to start a PPP session. In most cases PPPOpen and PPPClose are used with cellular modems that are configured to work over PPP. PPPOpen and PPPClose allow the user to enable and disable the PPP connection after turning on or before powering off a modem. Without PPPClose, the datalogger will constantly try to poll the serial port that is configured for modem communication in order to re-establish the PPP connection. Hence, significant power savings can be achieved by using PPPClose, which allows the communication port to go to sleep when no communication is occurring. PPPOpen is then used to reopen the port for a connection. PPPOpen and PPPClose can also be used to reduce unnecessary acknowledgement (ACK)-based traffic on cellular networks where PPP server/client communication all happen over the cellular network (not just between the cell modem and the datalogger).
    By default, PPPOpen has no parameters and waits up to 30 seconds for the IPv4 address assigned to the peripheral PPP device to be returned. However, beginning with Operating System 2, an optional parameter may be used to specify the IP version of the address that should be returned by the function. The optional parameter may be configured as follows:
    When multiple addresses are returned, each address is separated by a space. IPv6 addresses are returned in the order they are reported.
    NOTE: If a variable is used to store the IP address(es) returned by the function, the variable should be declared as type String A data type used when declaring a variable consisting of alphanumeric characters.. The variable is not initialized when the instruction is first called; rather, the IP address is written to the variable if a connection is made within 30 seconds of PPPOpen being called. The timeout period for all options is 30 seconds. For option 2, if no IPv4 address is found within 30 seconds, then the datalogger will search one time for IPv6 addresses before timing out.  If the PPPOpen function times out with options 0 or 2, an IPv4 address of 0.0.0.0 will be returned.  If the Option parameter is configured to return IPv6 addresses (Option 1 or 2) and the function times out, then :: (double colons) are returned.
    The datalogger is configured for PPP by editing values in its Settings table using the Device Configurator. The settings include the datalogger port to use for PPP, the IP address for the connection, log-in user name and password, the modem dial string to use, and the modem response string.
    PPP connections return the following states, which can be viewed by watching IP trace information in the datalogger:

    Args:
                    Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Option (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PPPOpen({Option})"


def PortBridge(
    Enable: Variable,
    Bridge: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portbridge.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portbridge.htm).

              The Portbridge instruction can be used to configure a datalogger as an IP serial terminal server. The PortBridge instruction may also be used to bridge two or more serial ports or two or more IP ports.

    Args:
                  Enable (Variable): A variable of type Boolean that when TRUE enables the bridge.

          Bridge (Variable): A 2-by-3 variable array of type Long that holds the comport, received bytes, and sent bytes for each of the two ports in the bridge. Zeros are used as place holders for received and sent bytes until bytes are actually received or sent. If an error occurs sending bytes,  sent bytes will increment negatively for each failure to send. If a comport is a TCP connection handle,  0 is used as a place holder for the comport until a successful TCP connection is made. For example, Public Bridge1(2,3) As Long = {COMC1,0,0,0,0,0}. In this example, COMC1 is the first comport and a TCP connection handle is the second comport. When a successful TCP connection is made, the 0 for the second comport will be replaced with a socket/connection number. Valid Comports include: ComPort can also be a virtual ComPort, such as the result of a TCPOpen instruction. Beginning with CR1000X  OS 05, an SDM-SIO1A or SDM-SIO4A may be used as a ComPort. See the SerialOpen (Open Communication Port) help for valid SDM-SIOxA port numbers.
    Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PortBridge({Enable},{Bridge})"


def PortGet(
    Dest: Variable | Array,
    Port: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "SW12_1", "SW12_2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portget.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portget.htm).

              This instruction will read the status of the specified port and place the result in the Dest variable. This instruction is controlled by the task sequencer, which sets up the measurement order. This results in the PortGet instruction always occurring directly after the measurement instruction preceding it in the program, regardless of whether the PortGet instruction is in a conditional block. If it is desired to read the status of a port conditionally, the ReadIO instruction should be used.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the PortGet instruction, Dest variable, a 1 is stored if the port is high; 0 is stored if the port is low.

          Port (Constant): The terminal to use in the instruction. An alphanumeric code is entered. Right-click to display a list.
    Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8), SW12_1 (SW12-1), SW12_2 (SW12-2)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PortGet({Dest},{Port})"


def PortSet(
    Port: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    State: Literal["0", "≠0"],
    Option: Literal["Omitted", "0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portset.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portset.htm).

                By default, 5 V is applied to the port when the State is set high. Use the PortPairConfig instruction to set the output to 3.3 V.This instruction is controlled by the task sequencer, which sets up the measurement order. This results in the PortSet instruction always occurring directly after the measurement instruction preceding it in the program, regardless of whether or not the PortSet instruction is in a conditional block. To write to a port conditionally, use the WriteIO instruction.
    The Delay() instruction can be used to set a delay between two PortSet instructions. When the PortSet() is running in a slow sequence, the Delay() Option must be 0 and the delay can be no larger than the scan interval of the main scan.

    Args:
                    Port (Constant): The number of the port to use in this instruction. Right-click to display a list.
      Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

            State (Variable | Constant | Expression): Determines whether to set the port high or low. Right-click to display a list.
      Must be one of following options: 0 (Low), ≠0 (High)

            Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether the instruction will run in the measurement task sequence or the processing task sequence; also affects whether the program will compile and run in SequentialMode or PipelineMode: *other programming may force the program into SequentialMode
      Must be one of following options: Omitted (Instruction is run within the measurement task sequence; program will compile in SequentialMode), 0 (Instruction is run within the measurement task sequence; program will attempt to compile in PipelineMode*), 1 (Instruction is run within the processing task sequence; program will attempt to compile in PipelineMode*)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PortSet({Port},{State},{Option})"


def PortsConfig(Mask: Literal["Port"], Function: Integer) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portsconfig.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portsconfig.htm).

                By default, ports are configured as input. The PortsConfig instruction may be needed if a port is configured as output by a WriteIO or PortSet instruction and then subsequently needs to function as an input.
    Typically, this instruction is executed only once in a program, by placing it between the BeginProg and Scan instructions.

    Args:
                    Mask (Integer): Used to select which ports will be affected by this instruction. It is a binary representation of the ports as follows: If a port position is set to 1, the datalogger configures that port. Binary numbers are entered by preceding the number with "&B". Leading zeros can be omitted. As an example, if &B110 is entered for this parameter, ports at bit no 3 and 2 will be configured, based on the Function parameter.
      Must be one of following options: Port (C8)

            Function (Integer): Used to configure the port. A binary value is entered to set each port location. 0 configures the port for input; 1 configures the port for output. Using the  mask &B110, if the Function parameter is set to &B110, ports at bit no 3 and 2 will be configured for output (port at bit no 1 uses the code for input, but it is not affected because of the mask).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PortsConfig({Mask},{Function})"


def PortPairConfig(
    Port: Literal["C1", "C3", "C5", "C7"], Option: Literal["1", "2"], PullOpt: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portpairconfig.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/portpairconfig.htm).

              By default, digital ports are set up for 5V. They can be set to 3.3V using this instruction. Ports are configured in terminal pairs – if C1 is set to 3.3V using this instruction, C2 is also set to 3.3V.

    Args:
                  Port (Constant): Specifies the port to be configured using this instruction. Right click to display a drop-down list box of valid options.
    Must be one of following options: C1 (Datalogger control terminals 1 & 2), C3 (Datalogger control terminals 3 & 4), C5 (Datalogger control terminals 5 & 6), C7 (Datalogger control terminals 7 & 8)

          Option (Variable): Sets the voltage for the port. This parameter has the following options:
    Must be one of following options: 1 (5V (default)), 2 (3.3V)

          PullOpt (Constant): Optional parameter that specifies the type of pull-up resistor to be used. If this parameter is left blank, the instruction defaults to 0 = pull down.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PortPairConfig({Port},{Option},{PullOpt})"


def PRT(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/prt.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/prt.htm).

                This instruction uses the result of a previous RTD bridge measurement to calculate the temperature in degrees Celsius. The input (Source) must be the ratio RS/RO, where RS is the RTD resistance and RO is the resistance of the RTD at 0 degrees Celsius.
    The temperature is calculated according to the DIN 43760 specification adjusted (1980) to the International Electrotechnical Commission standard, referenced to the IPTS-68 (international temperature scale as defined in 1968). The range of linearization is -200 to 850 degrees Celsius. The error in the linearization is less than 0.001 degrees between -100 and +300 degrees Celsius, and is less than 0.003 degrees between -180 and +830 degrees Celsius. The error (T calculated - T standard) is +0.006 degrees at -200 degrees Celsius and -0.006 degrees at +850 degrees Celsius.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PRT({Dest},{Reps},{Source},{Mult},{Offset})"


def PRTCalc(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Type: Literal["0", "1", "2", "3", "4", "5", "6"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/prtcalc.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/prtcalc.htm).

                This instruction uses the result of a previous RTD bridge measurement to calculate the temperature in degrees Celsius. The input (Source) must be the ratio RS/RO, where RS is the RTD resistance and RO is the resistance of the RTD at 0 degrees Celsius.
    A number of different sensor types are supported. The correct sensor type should be chosen to match the standard to which the sensor is said to conform and/or the alpha value for the sensor which is a fundamental measure of the change of resistance for a given temperature change.
    For industrial grade RTDs the relationship between temperature and resistance are characterized by a formula called the Callendar-Van Dusen (CVD) equation. The parameters for different sensor types are given in the standards or by the manufacturers for non-standard types. Temperature is now referenced to the ITS-90 temperature scale. PRTCalc follows the principles given in the US ASTM E1137-04 standard for conversion back from resistance to temperature. For the temperature range of 0 to +850 degrees Celsius a direct solution to the CVD equation is used resulting in errors <+/-0.0005 Celsius (caused by rounding errors in the datalogger math). For the range of -200 to 0 Celsius a 4th order polynomial is used to convert from resistance to temperature resulting in errors of <+/-0.003 Celsius.
    Note these errors are only the errors in approximating the relationships between temperature and resistance given in the relevant standards. The CVD equations and the tables published from them are in reality an approximation to the true linearity of an RTD, but are deemed adequate for industrial use. Errors in that approximation can be several hundredths of a degrees Celsius at different points in the temperature range and will vary from sensor to sensor. In addition individual sensors have errors relative to the standard, which can be up to +/-0.3 Celsius at 0 Celsius with increasing errors away from 0 Celsius, depending on the grade of sensor. To achieve the highest accuracy it is usually best to calibrate individual sensors over the range of use and apply corrections to the RS/RO value input to the instruction (by using the calibrated value of RO) and the multiplier and offset parameters of PRTCalc.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. The Reps parameter is the number of times the calculation should be made. Repetitions are made on consecutive elements in the Source array. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the PRTCalc instruction, the Source parameter is the variable or array that contains the resistance (RS/RO) of the PRT.

            Type (Constant): Specifies the platinum resistance sensor type.
      Must be one of following options: 0 (FachnormenausschuB Elektrotchnek im Deutschen
    NormenausschuB, DIN 43760, alpha = 0.003850), 1 (IEC 60751:2008 (formally known as IEC 751), alpha = 0.00385.  Now
    internationally adopted and written into national standards, for example ASTM E1137-04,
    JIS 1604:1997, EN 60751 and others. This should be used with any probes claiming
    compliance with those or older standards where the probe has alpha = 0.00385,
    for example DIN43760, BS1904.), 2 (US Industrial Standard, alpha = 0.00392), 3 (US Industrial Standard, alpha = 0.00391), 4 (Old Japanese Standard JIS C 1604:1981, alpha = 0.003916), 5 (Honeywell Industrial Sensors, alpha = 0.00375), 6 (ITS-90 SPRT, alpha = 0.003926)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PRTCalc({Dest},{Reps},{Source},{Type},{Mult},{Offset})"


def PulseCount(
    Dest: Variable | Array,
    Reps: Constant,
    PChan: Literal["P1", "P2", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    PConfig: Literal["0", "1", "2", "3", "4", "5"],
    POption: Literal["0", "1", ">1"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulsecountpulsecountreset.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulsecountpulsecountreset.htm).

                NOTE: A PulseCount measurement and a SDI12Recorder measurement cannot be made on the same control port pair.
    With the PulseCount instruction, a control port can be configured as high frequency input (up to 1 MHz) or switch closure (maximum frequency 150 Hz). See the datalogger user manual for more information.
    The PulseCount instruction must be executed once before the pulse port is ready for input. This may be of particular concern for programs with long scan intervals. For example, the PulseCount instruction will not yield a valid output until the turn of the second hour if the PulseCount instruction is used within a program with a scan interval of 1 hour.
    Each pulse counter port (P1/P2 or control port) has an independent 24-bit counter. Maximum counts per scan are 224 or 16,777,216. Each scan of the datalogger causes the counter to output the number of pulses accumulated since the last scan. If the scans stop, as in a program with more than one scan loop in the Main Program, or in a program that calls an external subroutine, the counter continues to accumulate counts until the Scan with the PulseCount instruction is reentered. PulseCountReset is used to reset both the pulse counter and the running average values in the pulse count instruction, though in most instances there is no need to manually reset the counter. The only use would be if two separate scans were using the same channel for a PulseCount, then the counter would need to be reset before entering each scan.
    For cases involving Scans that have subroutine calls that include a Scan/NextScan sequence, the PulseCountReset must be placed in a conditional statement prior to the PulseCount instruction, and the Subroutine call must be placed after the PulseCount instruction. If possible, calls to DataTables that store the results from the PulseCount instruction should be placed prior to the Subroutine call.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            PChan (Constant): The number of the pulse channel for the measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. Right-click to display a list.
      Must be one of following options: P1 (Pulse Channel 1), P2 (Pulse Channel 2), C1 (Control terminal 1), C2 (Control terminal 2), C3 (Control terminal 3), C4 (Control teminal 4), C5 (Control terminal 5), C6 (Control terminal 6), C7 (Control terminal 7), C8 (Control terminal 8)

            PConfig (Variable | Constant): A code specifying how the pulse channel should be configured. Right-click the parameter to display a list. NOTE: Code 0 may be used to disable the measurement during cleaning or calibration, if the PConfig parameter is a variable.
      Must be one of following options: 0 (Disabled), 1 (Switch Closure with pull up), 2 (Switch Closure with pull down (Control ports only)), 3 (High frequency with pull up), 4 (High frequency with pull down (Control ports only)), 5 (Low Level AC (Pulse channels only))

            POption (Constant): A code that determines if the raw result (multiplier =1, offset = 0) is returned in counts or frequency. Right-click to display a list. If an overrange occurs and running averaging is in use, the overrange value is an element of the average until it has fallen off the end of the list. If a running average were set for 1000 milliseconds then an overrange will be the value from the PulseCount instruction until 1 second has passed. Use the PulseCountReset instruction to avoid this.
      Must be one of following options: 0 (Counts), 1 (Frequency in Hz; counts/scan interval in seconds), >1 (Running average of frequency (Hz).The value entered is the time period of the
    running average in milliseconds and must be a multiple of the scan interval)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PulseCount({Dest},{Reps},{PChan},{PConfig},{POption},{Mult},{Offset})"


def PulseCountReset(
    Dest: Variable | Array,
    Reps: Constant,
    PChan: Literal["P1", "P2", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    PConfig: Literal["0", "1", "2", "3", "4", "5"],
    POption: Literal["0", "1", ">1"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulsecountpulsecountreset.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulsecountpulsecountreset.htm).

                NOTE: A PulseCount measurement and a SDI12Recorder measurement cannot be made on the same control port pair.
    With the PulseCount instruction, a control port can be configured as high frequency input (up to 1 MHz) or switch closure (maximum frequency 150 Hz). See the datalogger user manual for more information.
    The PulseCount instruction must be executed once before the pulse port is ready for input. This may be of particular concern for programs with long scan intervals. For example, the PulseCount instruction will not yield a valid output until the turn of the second hour if the PulseCount instruction is used within a program with a scan interval of 1 hour.
    Each pulse counter port (P1/P2 or control port) has an independent 24-bit counter. Maximum counts per scan are 224 or 16,777,216. Each scan of the datalogger causes the counter to output the number of pulses accumulated since the last scan. If the scans stop, as in a program with more than one scan loop in the Main Program, or in a program that calls an external subroutine, the counter continues to accumulate counts until the Scan with the PulseCount instruction is reentered. PulseCountReset is used to reset both the pulse counter and the running average values in the pulse count instruction, though in most instances there is no need to manually reset the counter. The only use would be if two separate scans were using the same channel for a PulseCount, then the counter would need to be reset before entering each scan.
    For cases involving Scans that have subroutine calls that include a Scan/NextScan sequence, the PulseCountReset must be placed in a conditional statement prior to the PulseCount instruction, and the Subroutine call must be placed after the PulseCount instruction. If possible, calls to DataTables that store the results from the PulseCount instruction should be placed prior to the Subroutine call.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. Measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            PChan (Constant): The number of the pulse channel for the measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. Right-click to display a list.
      Must be one of following options: P1 (Pulse Channel 1), P2 (Pulse Channel 2), C1 (Control terminal 1), C2 (Control terminal 2), C3 (Control terminal 3), C4 (Control teminal 4), C5 (Control terminal 5), C6 (Control terminal 6), C7 (Control terminal 7), C8 (Control terminal 8)

            PConfig (Variable | Constant): A code specifying how the pulse channel should be configured. Right-click the parameter to display a list. NOTE: Code 0 may be used to disable the measurement during cleaning or calibration, if the PConfig parameter is a variable.
      Must be one of following options: 0 (Disabled), 1 (Switch Closure with pull up), 2 (Switch Closure with pull down (Control ports only)), 3 (High frequency with pull up), 4 (High frequency with pull down (Control ports only)), 5 (Low Level AC (Pulse channels only))

            POption (Constant): A code that determines if the raw result (multiplier =1, offset = 0) is returned in counts or frequency. Right-click to display a list. If an overrange occurs and running averaging is in use, the overrange value is an element of the average until it has fallen off the end of the list. If a running average were set for 1000 milliseconds then an overrange will be the value from the PulseCount instruction until 1 second has passed. Use the PulseCountReset instruction to avoid this.
      Must be one of following options: 0 (Counts), 1 (Frequency in Hz; counts/scan interval in seconds), >1 (Running average of frequency (Hz).The value entered is the time period of the
    running average in milliseconds and must be a multiple of the scan interval)

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PulseCountReset({Dest},{Reps},{PChan},{PConfig},{POption},{Mult},{Offset})"


def PulsePort(
    Port: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"], Delay: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulseport.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pulseport.htm).

              This instruction toggles a port, delays the specified amount of time, toggles the port, and then delays a second time. The second delay in the instruction allows it to be used to create a 50 percent duty cycle clock for clocking multiplexers.

    Args:
                  Port (Constant): The number of the port to use in this instruction. An alphanumeric code is entered. Right-click to display a list.
    Must be one of following options: C1 (Control terminal 1), C2 (Control terminal 2), C3 (Control terminal 3), C4 (Control  terminal 4), C5 (Control terminal 5), C6 (Control terminal 6), C7 (Control  terminal 7), C8 (Control  terminal 8)

          Delay (Constant): The amount of time, in microseconds, to delay after toggling the port. The delay is used after both the first and second toggles of the port.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"PulsePort({Port},{Delay})"


# def Public(size: Variable | Constant | Expression | Array | Integer | ConstantInteger, size: Variable | Constant | Expression | Array | Integer | ConstantInteger, size: Variable | Constant | Expression | Array | Integer | ConstantInteger) -> str:
#             """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/public.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/public.htm).

#             Variables must be declared prior to their first use in the program; typically (for convenience), at the beginning of the program before other instructions. Variables declared as Public can be viewed in the datalogger's real-time tables. Variables that are Dimensioned (Dim instruction) but not defined as Public cannot be viewed real-time. All variables declared by Public, even within a subroutine or function, are treated as global variables. Dimmed variables within a function or subroutine are local variables.
# Variable names can be up to 39 characters in length. Note, however, when outputting the variable to a data table, the suffix containing the output type (for example, _avg) is appended to the end of the variable name. Therefore, to stay within the 39 character limit, most variables should be no more than 35 characters (which allows for the 4 additional characters that may be needed for output processing identifiers).
# Valid characters for use in variable names include the letters A through Z (upper and lower case), the underscore character ( _ ), the dollar sign ($), and numbers 0 through 9. Variable names must start with a letter, an underscore, or a dollar sign. Variable names are not case sensitive.
# A Public statement can be used for each variable declared, or multiple variables can be defined on one line with one Public statement. If the latter is done, the variables should be separated by a comma (for example, Public Test, Temp, RH declares three variables). A variable array is created by following the variable name with the number of elements enclosed in parentheses (for example, Public Temp(3) creates Temp(1), Temp(2), and Temp(3)). Two- and three-dimensional arrays can also be defined. A declaration of Public Temp(3,3,3) would create the variables Temp(1,1,1), Temp(1,1,2) …Temp(3,3,3). In the program, the array can be referenced using the multi-dimensional form, or using an index into the array. For more information, see Multi-dimensional Arrays.
# The Public instruction can be used with the optional As Type descriptor to define the data format for the variable (for example, Public Flag1 As BOOLEAN). When declaring multiple variables on the same line, the As Type expression only applies to the variable immediately preceding it. To declare multiple variables of a certain type, they each must have their own As Type statement. The data types are:
# The default IEEE4 Four-byte, floating-point data type. IEEE Standard 754. Same format as Float. data type; a 32-bit floating-point with a 24-bit mantissa data type. Float Four-byte floating-point data type. Default datalogger data type for Public or Dim variables. Same format as IEEE4. gives a range of ±1.4 x 10-45 to ±3.4 x 1038 with about seven digits of precision. If no data type is specified, Float is used.
# Sets the variable to a double-precision, 64-bit floating-point value, with 14 digits of precision.
# NOTE: To force double-precision arithmetic, declare all involved variables As Double and append all involved numbers with R. If any value used in a calculation is not forced to double-precision, the result of the calculation will be single-precision. Click here for additional information regarding double-precision arithmetic
# In addition to mathematical operations (addition, division, etc.), the following functions will perform the processing in double precision and return a double precision result if at least one of the parameters passed into the function is typed as a Double. These functions are: ABS, ACOS, ATN, ASIN, ATN2, Average, COS, COSH, EXP, FIX, FRAC, IIF, INT, LOG, LOG10, PWR, RND, SGN, SIN, SINH, SQRT, TAN, TANH.
# A floating point number will be cast as a single precision float unless an R is tagged at the end of the value to specify Double. Thus, 1.1 will be a single-precision value and 1.1R will be a double-precision value. For more information, see Double-Precision Arithmetic.
# Long: Sets the variable to a 32-bit long Data type used when declaring a variable as an integer. integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit).
# Sets the variable to a 4-byte Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports.. Boolean variables are typically used for flags and to represent conditions or hardware that have only 2 states (for example, On/Off, Ports). A Boolean variable uses the same 32-bit long integer format as a Long but can set to only one of two values: True, which is represented as –1, and false, which is represented with 0. Any non-zero number >= 1 will evaluate as true (a float value between .999 and 0 when converted to a Long is 0).
# Sets the variable to a string of ASCII characters, NULL terminated, with size specifying the maximum number of characters in the string (note that the null termination character counts as one of the characters in the string). The size argument is optional. The minimum string size is 4 (3 usable bytes and 1 terminating byte), and the default if size is not specified is 24 (23 usable bytes and 1 terminating byte). String size is allocated in multiples of 4 bytes. Thus, a string declared as 29 bytes will actually be 32 bytes (31 usable bytes and 1 terminating byte). A string is convenient in handling serial sensors, dial strings, text messages, etc.
# The size of a string variable should be set large enough to accommodate the largest expected string it will hold during run-time. However, care should be taken in specifying strings larger than required. The datalogger will allocate memory for the variables and data tables to the full size defined in the Public or Dim statement even if the variable holds a much shorter string. In addition to using memory, large strings have the potential of slowing communication, since the full size of the string is transmitted.
# As a special case, a string can be declared as String * 1. This allows the efficient storage of a single character. The string will take up 4 bytes in memory and when stored in a data table, but it will hold only one character.
# Strings can be dimensioned only up to 2 dimensions instead of the 3 allowed for other data types. (This is because the least significant dimension is actually used as the size of the string.) To begin reading or modifying a string at a particular location into the string, enter the location or begin reading a string at a particular character, enter the character as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element.
# Variables can be initialized when declared. For example:
# Public MyVar = 3.5 or Public MyVar = {3.5}
# Public MyArray(3) = {3, 6, 9}
# Dim MyVar = 3.5 or Public MyVar = {3.5}
# Dim MyArray(3) = {3, 6, 9}
# NOTE:  Beginning with OS 8.00, arrays can be initialized to all the same value with syntax such as Public Array(50) = 1, or Public Array(50) as Boolean = True. This will set all 50 elements of the array to 1 or True, respectively. In prior operating systems, only the first element of the array would be initialized with this syntax.
# NOTE:  Variables initialized within a subroutine or function are initialized only at compile time. They are not re-initialized with each call to the subroutine or function.
# The braces are optional if a scalar is being initialized or if only the first variable in an array is being initialized.
# When declaring a data type for the variable, the variable is declared before initialization:
# Public StringVar as String * 30 = "Test String"
# Dim StringVar as String * 30 = "Test String"
# For all arrays, including multi-dimensional arrays, the least significant elements are initialized first.
# Public Array (2,3) = {1,2,3,4}
# Dim Array (2,3) = {1,2,3,4}
# If the array is not fully initialized, the first elements will be initialized first, and the remainder will be uninitialized.
# For large arrays, initialization of variables can be placed on multiple
# lines as long as the break is after a , (comma).

#             Args:
# size (Variable | Constant | Expression | Array | Integer |
# ConstantInteger): size (No description provided)

# size (Variable | Constant | Expression | Array | Integer |
# ConstantInteger): size (No description provided)

# size (Variable | Constant | Expression | Array | Integer |
# ConstantInteger): size (No description provided)

#             Returns:
#                 str: A string of the CRBasic function call.
#             """
#             return f"Public({size},{size},{size})"


def PWM(
    Source: Variable | Constant, Port: Constant, Period: Constant, Units: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pwm.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pwm.htm).

        The PWM instruction programs the datalogger hardware based on the duty cycle (Source) and period. Its operation is independent of the datalogger scan interval. The duty cycle will remain set until the PWM instruction changes it.

    Args:
            Source (Variable | Constant): Used to specify the duty cycle for the instruction. It is a constant or variable specified as a value of 0.0 <= value <= 1.0, where 0.0 is always off (port low) and 1.0 is always on (port high).

    Port (Constant): The digital channel to be used for this instruction. Valid options are C1, C2, C3, C4, C5, C6, C7, and C8. Right-click the parameter to display a list of valid options.

    Period (Constant): A constant or variable that is used to specify the period for the signal. Maximum period is 36.4 seconds. Resolution for different periods: 0 <= period <= 5 mS, resolution is 83.33 nS5 mS < period <= 300 mS, resolution is 5.33 uS300 ms < period, resolution is 31.25 uS

    Units (Constant): The unit for the Period parameter. Valid units are microseconds (usec), milliseconds (msec), or seconds (sec). Right-click the parameter for a list of valid options.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"PWM({Source},{Port},{Period},{Units})"


def PWR(
    X: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Y: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pwr.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pwr.htm).

    Args:
            X (Variable | Constant | Expression | Array | Integer | ConstantInteger): X (No description provided)

    Y (Variable | Constant | Expression | Array | Integer | ConstantInteger): Y (No description provided)

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"PWR({X},{Y})"


def RainFlow(
    Source: Variable,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
    MeanBins: Constant,
    AmpBins: Constant,
    LoLim: Constant,
    UpLim: Constant,
    MinAmp: Constant,
    Form: Literal[
        "C(1,2)",
        "C(1,3)",
        "C(1,4)",
        "C(1,5)",
        "C(2,1)",
        "C(2,2)",
        "C(2,3)",
        "C(2,4)",
        "C(2,5)",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rainflow.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rainflow.htm).

                This output instruction is essential to estimating cumulative damage fatigue to components undergoing stress/strain cycles. The input signal (Source) is processed into a two dimensional rainflow histogram. One dimension represents the amplitude of the closed loop cycle (i.e., the distance between the cycle's peak and valley values). The other dimension represents the mean value of the cycle (i.e., [peak value + valley value]/2).
    The value recorded in each element (bin) of the histogram can be either the actual number of closed loop cycles that had the amplitude and mean value associated with that bin, or the ratio of the number of cycles having mean and amplitude values in the specific bin's range with respect to the total number of cycles that were counted (i.e., number of cycles in bin divided by total number of cycles counted).
    The range sizes for the amplitude columns are calculated by taking the difference between the upper (UpLim) and lower (LoLim) limits of the Mean values and dividing by the number of amp ranges (AmpBins).
    The histogram can have either open or closed form. In the open form, a cycle that has an amplitude larger than the maximum bin is counted in the maximum bin; a cycle that has a mean value less than the lower limit or greater than the upper limit is counted in the minimum or maximum mean bin. In the closed form, a cycle that is beyond the amplitude or mean limits is not counted.
    The algorithm for this instruction is based on the work done by Stephen Downing and Darrell Socie, which is documented in Volume 4 Issue 1 of the International Journal of Fatigue (Jan 1982).

    Args:
                    Source (Variable): The name of the Variable that is tested to determine which bin is selected. Right-click the parameter to display a list of defined variables.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

            MeanBins (Constant): The number of rows or fields to parse the stress/strain cycle's mean value into. Enter 1 to disregard the mean value and sort only by the amplitude of the stress/strain cycle. The range of each row of bins is equal to the UpLimit minus the LoLimit divided by the MeanBin's value. The lowest mean row’s minimum boundary is the LoLim and the highest mean row’s maximum boundary is the UpLim.

            AmpBins (Constant): The number of columns or fields to parse the amplitude of the stress/strain cycle into. The range of each Amp column is equal to the HiLim minus the LoLim divided by the AmpBin's value. The lowest Amp column’s minimum boundary is zero and the highest Amp column’s maximum boundary is the HiLim minus the LoLim.

            LoLim (Constant): LoLim is the lower limit of the input signal and the MeanBins.

            UpLim (Constant): UpLim is the upper limit of the input signal and the MeanBins.

            MinAmp (Constant): The minimum amplitude that a stress/strain cycle must have to be counted. The MinAmp's value should be less than the band size of the amplitude columns ( [HiLim - LoLim]/[AmpBins] ) or else cycles having the amplitude specified for the first column of bins will not be counted. If the MinAmp's value is set too small, processing time will be consumed counting cycles which are in reality just noise.

            Form (Constant): The Form consists of three elements: ABC. Right-click the parameter to display a list. Note: When a histogram is reset, a new histogram is created and stored in the data table at the data table's output interval. The number of new data points that are used for calculating subsequent histograms is determined by the ratio of the data table output rate to the scan interval: (data table output rate)/(scan interval). Choose whether or not the histogram should be reset (all bins are set to zero) after each output. If the histogram is not reset, the values in each bin will continue to accumulate as long as the program runs. Output If the number of mean ranges equals M, and the number of amplitude ranges equals A, then the output is arranged sequentially in the order [C(1,1), C(1,2), … C(1,A), C(2,1), C(2,2), C(2,3), … C(M,1), C(M,2) …. C(M,A) ]. Shown in a two dimensional array, the output would look like: Example    In the previous example, the count would go to output bin:
      Must be one of following options: C(1,2) (when), C(1,3) (when), C(1,4) (when), C(1,5) (when), C(2,1) (when), C(2,2) (when), C(2,3) (when), C(2,4) (when), C(2,5) (when)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"RainFlow({Source},{DataType},{DisableVar},{MeanBins},{AmpBins},{LoLim},{UpLim},{MinAmp},{Form})"


def RainFlowSample(
    Source: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    DataType: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rainflowsample2.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rainflowsample2.htm).

    Args:
            Source (Variable | Constant | Expression | Array | Integer | ConstantInteger): Two-dimensional arrays in which to store the rainflow histogram for each channel measured on the device. The first dimension is the number of Mean bins and the second dimension is the number of amplitude bins. For the CDM-VW300 only two variable arrays are required (RF1 and RF2); for the VWIRE 305 or CDM-VW305 eight variable arrays are required (RF1 – RF8).

    DataType (Constant): Defines the data type in which to store the instruction's results. For this instruction, the DataType must be set to IEEE4. For Rainflow histogram output, refer to the RainFlow instruction.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"RainFlowSample({Source},{DataType})"


def Randomize(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/randomize.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/randomize.htm).

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Randomize({number})"


def ReadIO(Dest: Variable | Array, Mask: Integer) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/readio.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/readio.htm).

                ReadIO is used to read the status of selected digital control ports. The status of these ports is reflected as a binary number where a high port (+5 V or +3.3V) equals 1 and a low port (0 V) equals 0. For example, if ports C1 and SE2 are high and the rest low, the binary representation is 00000101, or decimal 5.
    This instruction is not controlled by the task sequencer, but is controlled by processing. Therefore this instruction can be placed within a conditional statement. It should be remembered that processing can lag multiple scans behind measurements. See also PortGet (Status of Port).

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Mask (Integer): The Mask parameter is used to select which of the ports to read or write. It is a binary representation of the ports. WriteIO: If a port position in the mask is set to 1, the datalogger sets the port based on the value for that port in the Source. If a port position in the mask is set to 0 the value in the Source is ignored. Binary numbers are entered into CRBasic by preceding the number with "&B". For example, if the mask is entered as &B110 (leading zeros can be omitted in binary format just as in decimal) and the source is 5 decimal (binary 101) port 3 will be set high and port 2 will be set low. The mask indicates that only 3 and 2 should be set. While the value of the source also has a 1 for port 1, it is ignored because the mask indicates 1 should not be changed. ReadIO: If a port position is set to 1, the datalogger reads the status of the port. If a port position is set to 0 the datalogger ignores the status of the port (the Mask is "anded" with the port status; the "and" operation returns a 1 for a digit if the Mask digit and the port status are both 1, and a 0 if either or both is 0). CRBasic allows the entry of numbers in binary format by preceding the number with "&B". For example, if the Mask is entered as &B100 (leading zeros can be omitted in binary format just as in decimal) and ports 3 and 1 are high, the result of the instruction will be 4 (decimal, binary = 100); if port 3 is low, the result would be 0.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"ReadIO({Dest},{Mask})"


def RealTime(Dest: Variable | Array) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/realtime.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/realtime.htm).

                The RealTime instruction loads the destination array (Dest argument) with the current time values in the following order: (1) year, (2) month, (3) day of month, (4) hour of day, (5) minutes, (6) seconds, (7) microseconds, (8) day of week (1-7; Sunday = 1), and (9) day of year. The destination array must be dimensioned to 9. The time returned is the time of the datalogger's clock at the beginning of the scan in which the RealTime instruction occurs.
    If RealTime is run within a scan, the time reflected by the instruction will be the time of the datalogger's clock when the scan was started. If RealTime is run outside of a scan (for instance, within a Do Loop), the time reflected by the instruction will be based on the system clock, which has a 10 msec resolution.
    NOTE: TableName.Timestamp syntax can be used to return the timestamp of a data table record, expressed either as a time into an interval (for example seconds since 1970 or seconds since 1990) or as a date/time string. For more information, see TableName.TimeStamp (Table Timestamp).

    Args:
                    Dest (Variable | Array): The variable array in which to store the results of the RealTime instruction. The array must be dimensioned to 9 to include all of the current time values in the following order: (1) year, (2) month, (3) day of month, (4) hour of day, (5) minutes, (6) seconds, (7) microseconds, (8) day of week (1-7; Sunday = 1), and (9) day of year. The destination array must be dimensioned to 9. The time returned is the time of the datalogger's clock at the beginning of the scan in which the RealTime instruction occurs. Right-click the parameter to display a list of defined variables.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"RealTime({Dest})"


def RectPolar(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Source: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rectpolar.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rectpolar.htm).

        Both arguments (Dest and Source) must be arrays dimensioned to at least two elements. Source(1) should have the X coordinate value and Source(2) should have the Y coordinate value. The vector length is returned to the array element specified in Dest(1); the angle in radians is returned in the array element specified in Dest(2).

    Args:
            Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): Variable array in which to store the 2 resultant values. The length of the vector is stored in the specified destination element and the angle, in radians(± π), is stored in the next element of the array  Type -- Variable Array

    Source (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable array containing the X and Y coordinates that are to be converted to polar coordinates. The X value must be in the specified array element and the Y value in the next element of the array. Type -- Variable Array AngleDegrees can be used to return the result of this function in degrees instead of radians.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"RectPolar({Dest},{Source})"


def ResetTable(
    TableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/resettable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/resettable.htm).

    Args:
        TableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): TableName (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"ResetTable({TableName})"


def Replace(
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SubString: Variable,
    ReplaceString: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/replace.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/replace.htm).

        The new string resulting from this function is stored in the variable.

    Args:
            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

    SubString (Variable): The portion of the string in the original string that will be replaced.

    ReplaceString (Variable): The string that should be used to replace the SubString. WARNING: String functions are case sensitive. Uppercase or lowercase can be used to convert to all one case prior to processing the string if desired.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"Replace({SearchString},{SubString},{ReplaceString})"


def Right(
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumChars: Variable | Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/right.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/right.htm).

    Args:
            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

    NumChars (Variable | Constant): Specifies the number of characters from the left or right side of the string to return.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"Right({SearchString},{NumChars})"


def Left(
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumChars: Variable | Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/left.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/left.htm).

    Args:
            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

    NumChars (Variable | Constant): Specifies the number of characters from the left or right side of the string to return.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"Left({SearchString},{NumChars})"


def RMSSpa(Dest: Variable | Array, Swath: Constant, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rmsspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rmsspa.htm).

                The RMSSpa function is defined as:
    If a NAN is returned by the datalogger it is not included in the spatial RMS.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Swath (Constant): The number of values of the array over which to perform the specified operation. For the RMSSpa instruction, the Swath parameter is the number of elements to include in the calculation.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, RMSSpa, StdDev, StdDevSpa, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"RMSSpa({Dest},{Swath},{Source})"


def Route(PakBusAddr: Integer) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/route.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/route.htm).

                The Route function returns the address of the neighbor (first hop) to the specified PakBus datalogger. If no neighbor is found, a 0 is returned.
    If the PakBusAddr parameter is negated, this function will return the COM port or TCP connection handle.

    Args:
                    PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Route({PakBusAddr})"


def RoutersNeighbors(
    DestArray: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/routersneighbors.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/routersneighbors.htm).

                The DestArray must be a two-dimensional array defined as a long. The first dimension should be sized to the maximum number of routers expected and the second dimension should be sized to the maximum number of neighbors expected plus one.
    The return for each array will include:

    Args:
                    DestArray (Variable | Constant | Expression | Array | Integer | ConstantInteger): DestArray(MaxRouters (No description provided)

            MaxNeighbors+1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): MaxNeighbors+1 (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"RoutersNeighbors({DestArray})"


def Round(Number: Expression, Decimal: Variable | Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/round.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/round.htm).

                The Round function rounds the Number up if the determining digit is 5 or greater; otherwise, it rounds down. This is commonly referred to as arithmetic rounding.
    NOTE: Negative numbers effectively round down if the determining digit is greater than 5 and up if it is less than 5; for example, -8.6 rounds to -9.
    To round a value up or down to an integer, use the Ceiling function or the Floor function.

    Args:
                    Number (Expression): The value on which to perform the rounding operation. It can be any value or an expression.

            Decimal (Variable | Constant): Used to determine how many decimal places to keep. If Decimal is set to 0, the result will be an integer. If Decimal is a negative number, it specifies the power of 10 to which you want to round.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Round({Number},{Decimal})"


def Floor(
    Number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/floor.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/floor.htm).

    The Floor function rounds a Number down to an integer value.

    Args:
        Number (Variable | Constant | Expression | Array | Integer | ConstantInteger): Number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Floor({Number})"


def Ceiling(
    Number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ceiling.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ceiling.htm).

    The Ceiling function rounds a Number up to an integer value.

    Args:
        Number (Variable | Constant | Expression | Array | Integer | ConstantInteger): Number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Ceiling({Number})"


def Sample(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
        "FP2",
        "IEEE4"
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sample.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sample.htm).

    Args:
                  Reps (Constant): The number of repetitions for the measurement or instruction. If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error is returned when the program is compiled.

          Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be a constant or an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Sample({Reps},{Source},{DataType})"


def SampleMaxMin(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/samplemaxmin.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/samplemaxmin.htm).

              The SampleMaxMin instruction is placed inside a DataTable declaration, following the Maximum or Minimum instruction used as the basis for the output of this instruction. When the Repetitions parameter for the Maximum or Minimum instruction is greater than 1, SampleMaxMin samples whenever a new maximum or minimum occurs in any of the variables in the Maximum/Minimum source array.

    Args:
                  Reps (Constant): The number of repetitions for the measurement or instruction. For the SampleMaxMin instruction, the Reps are the number of variables to sample when a maximum or minimum is reached. If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error is returned when the program is compiled.

          Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the SampleMaxMin instruction, the Source is the name of the variable or variable array that is sampled when a new maximum or minimum occurs for the preceding Maximum or Minimum instruction. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

          DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SampleMaxMin({Reps},{Source},{DataType},{DisableVar})"


def SatVP(Dest: Variable | Array, Temp: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/satvp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/satvp.htm).

                The SatVP instruction will find the saturation vapor pressure if the dry bulb temperature is used or vapor pressure if the dew point temperature is used.
    The saturation vapor pressure is derived using the following polynomial (reference Lowe, Paul R.: 1977, "An approximating polynomial for computation of saturation vapor pressure," Journal of Applied Meteorology, 16, 100-103), adjusted from units of millibars to kilopascals:
    This instruction can also be used to calculate saturation vapor pressure over ice.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Temp (Variable): The variable in the program that contains the measurement, in degrees C, for temperature. For the SatVP instruction, the Temp parameter is the program variable that contains the value for the temperature sensor.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SatVP({Dest},{Temp})"


def SDI12Recorder(
    Dest: Variable | Array,
    SDIPort: Literal["C1", "C3", "C5", "C7"],
    SDIAddress: Variable | Constant,
    SDICommand: Literal[
        "?!",
        "aAb!",
        "HB!",
        "HA!",
        "C!",
        "CC!",
        "I!",
        "M!",
        "MC!",
        "M1!",
        "RC!",
        "R0!",
        "V!",
        "X!",
    ],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    FillNAN: Constant = 0,
    WaitonTimeout: Constant = 0,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12recorder.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12recorder.htm).

                The SDI12Recorder instruction sends the command specified by the SDI12Command parameter as (address)SDI12Command!. The M! and C! commands are used to set up the sensor for measurement and the D0! command is used to retrieve the measurement value. The difference in the M! and C! commands is that when the M! command is issued, the datalogger pauses its operation and waits until the sensor timeout expires or it receives the data from the sensor before continuing. When the C! command is issued, the datalogger continues with its program without pausing and queries the sensor for values on subsequent scans. If the sensor response time is set to 0, the datalogger will issue the C! or M! command, immediately followed by the D0! command. If the datalogger receives no response it will send the command a total of three times, with three retries with each attempt, or until a response is received. If no response is received, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is recorded in the first element of the Dest array. The optional parameter, FillNAN, may be used to fill the entire or part of the Dest array with NAN (see the following FillNAN parameter help).
    The optional WaitonTimeout parameter may be used to specify that the C! will wait inside the instruction for the sensor's advertised timeout and then issue the D! to record the data. This parameter adds the ability to work with multiple sensors in a single instruction call.
    Note that the M! command always waits for the timeout period.
    The Command parameter can be a variable, thus, it can be conditionally set to C! or C (or M! or M). If a C (or M) command is used, a D command is issued to pick up only the data measured by a previous C! command but no new request for data is issued. This facilitates data retrieval from a previous request if it is pending. Note that the same instance of the SDI12Recorder must be used for this to work (not two separate instructions), since information on how many values to retrieve is held locally by the instruction.
    If multiple sensors are measured on the same SDI-12 port, each sensor requires a unique SDI-12 address. In addition, when separate SDI12Recorder instructions occur in different  but concurrent scans, use SemaphoreGet and SemaphorRelease before and after  SDI12Recorder  to prevent a resource conflict that may result in NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. (see example # 3).

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  For the SDI12Recorder instruction, the Dest parameter must have enough elements to store all the data that is returned by the SDI-12 sensor or a 'variable out of range' error will result during the execution of the instruction. NAN is returned in the first element of the array if the sensor is busy with terminal commands, if the command sent is an invalid command, or if the sensor aborts with carriage return/line feed and there is no data.

            SDIPort (Constant): The port to which the SDI-12 sensor is connected. Right-click the parameter to display a list. A numeric value is entered.
      Must be one of following options: C1 (Control Port 1), C3 (Control Port 3), C5 (Control Port 5), C7 (Control Port 7)

            SDIAddress (Variable | Constant): Enter the SDI12 address that will be affected by this instruction. (For SDI12SensorSetup instruction it is the address to assign to the datalogger. For the SDI12Recorder instruction it is the address of the SDI12 sensor.) Valid range are 0 through 9, A through Z, and a through z. Alphabetical characters should be enclosed in quotes (for example, "A"). The same commands can be sent to multiple sensors by specifying multiple addresses, enclosed in quotes, in this parameter (for example, “012” send the commands to sensors addressed as 0, 1, and 2). The Dest variable should include an extra dimension to accommodate multiple sensors, or, if Dest is declared as a string, all values from each sensor are returned into a separate element of the array (for example, Dest(1) contains all values from sensor 1, Dest(2) contains all values from sensor 2, etc.). . When sending commands to multiple sensors, all of the C! commands are performed first, and then, while waiting on the C! commands to finish, non-C! commands are performed.

            SDICommand (Constant): Used to specify the command strings that will be sent to the sensor. The command must be enclosed in quotes. If a check summed command fails, a NAN will be returned and the command will be retried.
      Must be one of following options: ?! (Address query), aAb! (Change address (where a = current address and b = new address)), HB! (High-volume binary data (supported with OS 2 and greater)), HA! (High-volume ASCII data (supported with OS 2 and greater)), C! (Initiate concurrent measurements), CC! (Initiate concurrent measurements (with checksum)), I! (Send identification (destination variable must be formatted as a string)), M! (Initiate measurements), MC! (Initiate measurements (with checksum)), M1! (Additional measurement commands
    specified by the SDI-12 sensor), RC! (Continuous measurement (with checksum)), R0! (Continuous measurement
    commands), V! (Initiate verify sequence), X! (Extended commands (destination variable must be formatted as a string))

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            FillNAN (Constant): An optional parameter that indicates how NAN values due to bad sensor readings are recorded. The default behavior if this parameter is not present is that NAN is written only to the first element in the array and the remaining elements of the array contain the last known good values. The options for this parameter are: 0: Default behavior; write NAN only to the first element in the array-1: Fill the entire array with NAN>0: Fill the specified number of elements in the array with NAN, beginning with the starting element defined by Dest

            WaitonTimeout (Constant): An optional parameter that when set to 1 specifies that the C! command will wait inside the instruction for the sensor’s advertised timeout and then issue the D! command to record the data. This allows multiple sensors to be measured with a single instruction call. Related Topics

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SDI12Recorder({Dest},{SDIPort},{SDIAddress},{SDICommand},{Mult},{Offset},{FillNAN},{WaitonTimeout})"


def SDI12SensorSetup(
    Reps: Constant,
    SDIPort: Literal["C1", "C3", "C5", "C7"],
    SDIAddress: Variable | Constant,
    ResponseTime: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12setupresponse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12setupresponse.htm).

                The commands supported when the datalogger acts as an SDI12 Sensor are M, C, R, V, I, and ?. H commands (high-volume binary and ASCII data) are supported beginning with OS 2. All commands support CRC support. Click here for additional information on the commands.
    In most cases the SDI12SensorSetup/SDI12SensorResponse instructions would be placed in a Do... Loop() in a SlowSequence() scan to allow other functions to take place in the main program. (Scan/NextScan is not required in this SlowSequence for the sensor functionality to work.) When the SDI12SensorSetup instruction executes it stops execution of the sequence it is in and waits for a Break sequence from the recorder. If a valid address and command are received, then the preamble response is sent to the recorder and SDI12SensorSetup exits so instructions following it can execute. Execution continues as normal until the SDI12SensorResponse instruction executes. It is up to the user to make sure that the time between Setup and Response is not greater than the time reported back to the recorder as the response time. If this time is exceeded the sensor will not operate properly. Response time must be at least 1 second (the datalogger does not support 0 response time.)
    NOTE: SDI12SensorSetup/SDI12SensorResponse can be placed within a Scan/NextScan in a SlowSequence. However, (1) you will have up to scan rate amount of delay before the datalogger can be polled after boot up, and (2) you will get skipped scans unless you are polling at the same rate as the scan rate. Therefore, using a Do...Loop is recommended.
    NOTE: A datalogger can be assigned only one SDI12 address per SDI12 port (i.e., a single port cannot support multiple addresses).

    Args:
                    Reps (Constant): The number of measurements to tell the SDI12 recorder to retrieve from the SDI12Sensor.

            SDIPort (Constant): The port to which the SDI-12 sensor is connected. Right-click the parameter to display a list. A numeric value is entered.
      Must be one of following options: C1 (Control Port 1), C3 (Control Port 3), C5 (Control Port 5), C7 (Control Port 7)

            SDIAddress (Variable | Constant): Enter the SDI12 address that will be affected by this instruction. (For SDI12SensorSetup instruction it is the address to assign to the datalogger. For the SDI12Recorder instruction it is the address of the SDI12 sensor.) Valid range are 0 through 9, A through Z, and a through z. Alphabetical characters should be enclosed in quotes (for example, "A"). The same commands can be sent to multiple sensors by specifying multiple addresses, enclosed in quotes, in this parameter (for example, “012” send the commands to sensors addressed as 0, 1, and 2). The Dest variable should include an extra dimension to accommodate multiple sensors, or, if Dest is declared as a string, all values from each sensor are returned into a separate element of the array (for example, Dest(1) contains all values from sensor 1, Dest(2) contains all values from sensor 2, etc.). . When sending commands to multiple sensors, all of the C! commands are performed first, and then, while waiting on the C! commands to finish, non-C! commands are performed.

            ResponseTime (Constant): The time, in seconds, that the SDI-12 recorder should wait before requesting data. This setting must be at least 1 second (the datalogger does not support 0 response time.) Related Topics

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SDI12SensorSetup({Reps},{SDIPort},{SDIAddress},{ResponseTime})"


def SDI12SensorResponse(
    Reps: Constant,
    SDIPort: Literal["C1", "C3", "C5", "C7"],
    SDIAddress: Variable | Constant,
    ResponseTime: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12setupresponse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdi12setupresponse.htm).

                The commands supported when the datalogger acts as an SDI12 Sensor are M, C, R, V, I, and ?. H commands (high-volume binary and ASCII data) are supported beginning with OS 2. All commands support CRC support. Click here for additional information on the commands.
    In most cases the SDI12SensorSetup/SDI12SensorResponse instructions would be placed in a Do... Loop() in a SlowSequence() scan to allow other functions to take place in the main program. (Scan/NextScan is not required in this SlowSequence for the sensor functionality to work.) When the SDI12SensorSetup instruction executes it stops execution of the sequence it is in and waits for a Break sequence from the recorder. If a valid address and command are received, then the preamble response is sent to the recorder and SDI12SensorSetup exits so instructions following it can execute. Execution continues as normal until the SDI12SensorResponse instruction executes. It is up to the user to make sure that the time between Setup and Response is not greater than the time reported back to the recorder as the response time. If this time is exceeded the sensor will not operate properly. Response time must be at least 1 second (the datalogger does not support 0 response time.)
    NOTE: SDI12SensorSetup/SDI12SensorResponse can be placed within a Scan/NextScan in a SlowSequence. However, (1) you will have up to scan rate amount of delay before the datalogger can be polled after boot up, and (2) you will get skipped scans unless you are polling at the same rate as the scan rate. Therefore, using a Do...Loop is recommended.
    NOTE: A datalogger can be assigned only one SDI12 address per SDI12 port (i.e., a single port cannot support multiple addresses).

    Args:
                    Reps (Constant): The number of measurements to tell the SDI12 recorder to retrieve from the SDI12Sensor.

            SDIPort (Constant): The port to which the SDI-12 sensor is connected. Right-click the parameter to display a list. A numeric value is entered.
      Must be one of following options: C1 (Control Port 1), C3 (Control Port 3), C5 (Control Port 5), C7 (Control Port 7)

            SDIAddress (Variable | Constant): Enter the SDI12 address that will be affected by this instruction. (For SDI12SensorSetup instruction it is the address to assign to the datalogger. For the SDI12Recorder instruction it is the address of the SDI12 sensor.) Valid range are 0 through 9, A through Z, and a through z. Alphabetical characters should be enclosed in quotes (for example, "A"). The same commands can be sent to multiple sensors by specifying multiple addresses, enclosed in quotes, in this parameter (for example, “012” send the commands to sensors addressed as 0, 1, and 2). The Dest variable should include an extra dimension to accommodate multiple sensors, or, if Dest is declared as a string, all values from each sensor are returned into a separate element of the array (for example, Dest(1) contains all values from sensor 1, Dest(2) contains all values from sensor 2, etc.). . When sending commands to multiple sensors, all of the C! commands are performed first, and then, while waiting on the C! commands to finish, non-C! commands are performed.

            ResponseTime (Constant): The time, in seconds, that the SDI-12 recorder should wait before requesting data. This setting must be at least 1 second (the datalogger does not support 0 response time.) Related Topics

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SDI12SensorResponse({Reps},{SDIPort},{SDIAddress},{ResponseTime})"


def SDMAO4(
    Source: Variable,
    Reps: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmao4.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmao4.htm).

    Args:
            Source (Variable): The variable or variable array that holds the voltage(s), in millivolts, that will be sent to the SDM-AO4(s). If multiple SDM-AO4s are to be triggered with one instruction, this parameter must be dimensioned to the total number of channels for all the devices being set (e.g., if all four channels are being set on two SDM-AO4 devices, Source must be dimensioned to eight).

    Reps (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines the number of SDM-AO4 output channels that will be set. If this parameter is greater than four (i.e., voltage is being set for more than one SDM-AO4 device), voltage is set on the next consecutively addressed SDM-AO4 device. In this case, the SDM-AO4s must have sequential SDM addresses.

    SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SDMAO4({Source},{Reps},{SDMAddress})"


def SDMAO4A(
    Source: Variable,
    SDMAO4ADest: Literal["240", "241", "242", "243"],
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SDMAO4AStartChan: Constant,
    Reps: Constant,
    SDMAO4AOption: Literal["0", "1", "2", "3", "4"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmao4a.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmao4a.htm).

                The SDM-AO4A includes four independent, continuous, analog outputs (CAO), which are used for proportional control or driving strip charts. Measured or processed values in the datalogger are scaled to millivolts and transferred to the SDMAO4A as digital values. The SDM-AO4A then performs a digital to analog conversion and outputs an analog voltage signal.
    The SDMAO4A will respond to the older SDMAO4 instruction, but you will not be able to take advantage of any of the SDMAO4A's additional features. If the older instruction is used, the device will use the default option code 1.

    Args:
                    Source (Variable): The variable or variable array that holds the voltage(s), in millivolts, that will be sent to the SDM-AO4A(s). If multiple SDM-AO4As are to be triggered with one instruction, this parameter must be dimensioned to the total number of channels for all the devices being set (e.g., if all four channels are being set on two SDM-AO4 devices, Source must be dimensioned to eight).

            SDMAO4ADest (Variable): A variable that holds a status code indicating success or failure of the instruction. A current overload error occurs when current overload protection is triggered (130 mA, +/- 15 mA). A signature error usually indicates noise on the line. Any other response code returned indicates failed communication.
      Must be one of following options: 240 (Successful), 241 (Signature error), 242 (Current overload error), 243 (Current overload and signature error)

            SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

            SDMAO4AStartChan (Constant): Used to define the first channel on the SDMAO4A that should be set. Any reps will occur on subsequent channels.

            Reps (Constant): Determines the number of SDM-AO4A output channels that will be set. If this parameter is greater than four (i.e., voltage is being set for more than one SDM-AO4 device), voltage is set on the next consecutively addressed SDM-AO4A device. In this case, the SDM-AO4As must have sequential SDM addresses.

            SDMAO4AOption (Constant): Used to set the operating mode for the SDMAO4A. In the synchronous mode, all channels are set at the same time. This mode is slower since for large changes in voltage it may take multiple charging cycles to arrive at the final voltage. The steps occur at 5 ms intervals, thus, for a 10V step it may take up to three charge cycles (or 15 ms) to settle to the 16-bit level. In sequential mode, the channels are set sequentially. The output signal can take from 600 usecs to 1 ms (worst case) to settle to 16-bit resolution with a 10V step change. The four outputs then update 1 ms apart.
      Must be one of following options: 0 (Power down), 1 (5V synchronous), 2 (5V sequential), 3 (10V synchronous), 4 (10V sequential)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SDMAO4A({Source},{SDMAO4ADest},{SDMAddress},{SDMAO4AStartChan},{Reps},{SDMAO4AOption})"


def SDMBeginPort(
    SDMPort: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmbeginport.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmbeginport.htm).

    This instruction is used to specify the first of three consecutive ports that will be used for controlling an SDM device. If this instruction is omitted from the program, SDM control occurs on C1, C2, and C3 and the device should be wired accordingly. SDMBeginPort must be placed in the program before the BeginProg instruction and before any SerialOpen that will access the port set up for SDM. Only one SDMBeginPort instruction is allowed in a program.

    Args:
        SDMPort (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to specify the C ports to use for controlling an SDM device. Enter the number of the first port in a series of three: C1     C1, C2, C3 C5     C5, C6, C7

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"SDMBeginPort({SDMPort})"


def SDMCD16AC(
    Source: Variable,
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcd16ac.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcd16ac.htm).

        A port on an SDM-CD16AC is enabled/disabled (turned on or off) by sending a value to it using the SDMCD16AC instruction. A non-zero value will enable the port; a zero value disables it. The values to be sent to the SDM-CD16AC are held in the Source array.

    Args:
            Source (Variable): An array (dimensioned as Float, Long, or Boolean) which holds the values that will be sent to the SDM-CD16AC to enable/disable its ports. An SDM-CD16AC has 16 ports; therefore, in most instances the source array should be dimensioned to 16 times the number of Repetitions (the number of SDM-CD16AC devices to be controlled). As an example, with the array CDCtrl(32), the value held in CDCtrl(1) will be sent to port 1, the value held in CDCtrl(2) will be sent to port 2, etc. The value held in CDCtrl(32) would be sent to port 16 on the second SDM-CD16AC. If the Source parameter is defined as a Long variable, but it is dimensioned less than 16 * Reps, Source will act as a binary control for the instruction whose bits 0..15 will specify control ports 1..16, respectively. In this instance, Source(1) will be used for the first rep, Source(2) will be used for the second, and so on.

    Reps (Constant): The number of SDM-CD16AC devices that will be controlled with this instruction.

    SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SDMCD16AC({Source},{Reps},{SDMAddress})"


def SDMCD16Mask(
    Source: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SDMCD16Mask: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcd16mask.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcd16mask.htm).

        A port on an SDM-CD16AC is enabled/disabled (turned on or off) by sending an integer value to it using the SDMCD16Mask instruction. Each of the 16 least significant bits of the integer corresponds to a port on the SDM-CD16AC, where port 1 is bit 0 (the least significant bit). If a bit is set, the corresponding port is enabled.

    Args:
            Source (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable or variable array dimensioned as a Long that holds the integer value that will be sent to the SDM-CD16AC. The SDM-CD16AC ports will be enabled/disabled following the bit pattern of the Source variable. For example, if the decimal value 21845 (hex &h5555 or binary &b0101010101010101) is sent to the SDM-CD16AC using the SDMCD16Mask () instruction, all the odd ports will be enabled.

    SDMCD16Mask (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to indicate which ports will change state. For example, if the mask was a decimal 15 (hex &h000F or binary &b0000000000001111) and the Source was a decimal value 21845 (hex &h5555 or binary &b0101010101010101), Ports 5 through 16 would remain unchanged, and ports 1 through 4, would be set according to the Source variable.

    SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SDMCD16Mask({Source},{SDMCD16Mask},{SDMAddress})"


def SDMCVO4(
    CVO4Source: Variable,
    CVO4Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    CVO4Mode: Literal["0", "1", "10", "11"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcvo4.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmcvo4.htm).

              This instruction controls the SDM-CVO4, which outputs a voltage or a current. Internal jumpers are used to set the mode for the device, but the jumpers can be overridden with the Mode parameter in this instruction.

    Args:
                  CVO4Source (Variable): A variable array that holds the values for the voltages (millivolts) or currents (microamps) that will be output by each channel of the device (Source(1) sets channel1, Source(2) sets channel2, etc.). When outputting a voltage, the variable must be within the range of 0 to 10,000. When outputting a current, the variable must be within the range of 0 to 20,000.

          CVO4Reps (Constant): Indicates the number of channels to set to the defined voltage or current. Additional SDM-CVO4 devices can be controlled by one SDMCVO4 instruction by assigning them consecutive addresses and setting the CVO4Reps parameter to a value equal to the total number of channels of all devices (e.g., to set all four channels on two devices, set the CVO4Reps parameter to 8). If the CVO4Reps parameter is set to 0, power to the device will be turned off.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          CVO4Mode (Variable): Determines what type of signal will be output by the device. Right-click the parameter to display a list box of valid options. The two override options affect all of the channels of all of the SDM-CVO4 devices being controlled by this instruction. These two options override the hardware settings in the device. Use of this mode takes approximately 2 milliseconds per device. When either of these options is used you lose the flexibility of setting the output for each channel individually.
    Must be one of following options: 0 (Voltage output, use jumper settings (scale only)), 1 (Current output; use jumper settings (scale only)), 10 (Voltage output; override jumper setting), 11 (Current output; override jumper setting)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SDMCVO4({CVO4Source},{CVO4Reps},{SDMAddress},{CVO4Mode})"


def SDMGeneric(
    Dest: Variable,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    CmdByte: Variable,
    NumValsOut: Variable,
    Source: Variable,
    NumValsIn: Variable,
    BytesPerValue: Variable,
    BigEndian: Constant,
    DelayByte: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmgeneric.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmgeneric.htm).

    Args:
            Dest (Variable): A variable that will hold any incoming bytes from the SDM device.

    SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

    CmdByte (Variable): A setup byte that will be sent to the SDM device.

    NumValsOut (Variable): The number of values that are to be sent to the SDM device.

    Source (Variable): A variable that holds the values to be sent to the SDM device.

    NumValsIn (Variable): The number of values that are expected to be received back from the SDM device.

    BytesPerValue (Variable): The number of bytes for each value sent to or received from the SDM device. Typically, this is 1, 2, or 4, for 1 byte, 2 byte, or 4 byte values.

    BigEndian (Constant): Indicates the order of bytes to be sent or received. Enter 0 for little endian (least significant byte first), or 1 for big endian (most significant byte first).

    DelayByte (Constant): The delay, in microseconds, that should be used between sending bytes. If a negative value is entered, this is the delay to be expected between receiving bytes from the SDM device.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SDMGeneric({Dest},{SDMAddress},{CmdByte},{NumValsOut},{Source},{NumValsIn},{BytesPerValue},{BigEndian},{DelayByte})"


def SDMINT8(
    Dest: Variable | Array,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Config8_5: Literal["0", "1", "2", "3"],
    Config4_1: Literal["0", "1", "2", "3"],
    Funct8_5: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8"],
    Funct4_1: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8"],
    OutputOpt: Literal[
        "32768", "nnnn", "-nnnn", "-9999", "0", "-0", "positive", "negative"
    ],
    CaptureTrig: Variable,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmint8.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmint8.htm).

              The INT8 is a device for the measurement of intervals, counts between events, frequencies, periods, and/or time since an event using the SDM communications protocol. Refer to the INT8 manual for more information about its capabilities.

    Args:
                  Dest (Variable | Array): The variable or array where the results of the instruction are stored. For all output options except Capture All Events, the Dest argument should be a one-dimensional array with as many arguments as there are programmed INT8 channels. If the Capture All Events output option is selected, then the Dest array must be two dimensional. The magnitude of the first dimension should be set to the number of functions (up to 8), and the magnitude of the second dimension should be set to at least the maximum number of events to be captured. The values will be loaded into the array in the sequence of all of the time ordered events captured from the lowest programmed channel to those of the highest programmed channel.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          Config8_5 (Constant): A four-digit code used to configure channels 5 through 8 on the INT8. Each input channel can be configured for either high or low level voltage inputs and for rising or falling edges. The digits represent the channels in descending order from left to right (e.g., 8 7 6 5).
    Must be one of following options: 0 (High level, rising edge), 1 (High level, falling edge), 2 (Low level, rising edge), 3 (Low level falling edge)

          Config4_1 (Constant): A four-digit code used to configure channels 1 through 4 on the INT8. Each input channel can be configured for either high or low level voltage inputs and for rising or falling edges. The digits represent the channels in descending order from left to right (e.g., 4 3 2 1).
    Must be one of following options: 0 (High level, rising edge), 1 (High level, falling edge), 2 (Low level, rising edge), 3 (Low level falling edge)

          Funct8_5 (Constant): A four digit code used to program the timing function of channels 5 through 8. Similar to the Config parameters, digits represent the channels in descending order from left to right (e.g., 8 7 6 5).
    Must be one of following options: 0 (No value returned), 1 (Period (ms) between edges on the programmed channel), 2 (Frequency (kHz) of edges on the programmed channel), 3 (Time (ms) between an edge of the previous channel and an edge of the programmed channel), 4 (Time (ms) between an edge on Channel 1 and edge on the programmed channel), 5 (Number of edges on channel 2 since last edge on channel 1 using linear interpolation), 6 (Low resolution frequency (kHz) of edges on programmed channel), 7 (Total count of edges on programmed channel since last interrogation), 8 (Number of edges on channel 2 since last edge on channel 1 without linear interpolation)

          Funct4_1 (Constant): A four digit code used to program the timing function of channels 1 through 4. Similar to the Config parameters, digits represent the channels in descending order from left to right (e.g., 4 3 2 1).
    Must be one of following options: 0 (No value returned), 1 (Period (ms) between edges on the programmed channel), 2 (Frequency (kHz) of edges on the programmed channel), 3 (Time (ms) between an edge of the previous channel and an edge of the programmed channel), 4 (Time (ms) between an edge on Channel 1 and edge on the programmed channel), 5 (Number of edges on channel 2 since last edge on channel 1 using linear interpolation), 6 (Low resolution frequency (kHz) of edges on programmed channel), 7 (Total count of edges on programmed channel since last interrogation), 8 (Number of edges on channel 2 since last edge on channel 1 without linear interpolation)

          OutputOpt (Constant): A numeric code that is used to select one of the five different output options. The selected option will be applied to all of the INT8 channels. A brief explanation is given below for each code. See the INT8 manual for detailed explanations of each option. Right click the parameter to display a drop-down list box.
    Must be one of following options: 32768 (Performs continuous averaging, which is utilized when input frequencies have a slower period than the execution interval of the datalogger. If an edge was not detected for a channel since the last time that the INT8 was polled, then the datalogger will not update the input location for that channel. The INT8 will capture events even during communications with the datalogger.), nnnn (Averages the input values over "nnnn" milliseconds. The datalogger program is delayed by this instruction while the INT8 captures and processes the edges for the specified time duration and sends the results back to the datalogger. If no edges were detected, 0 will be returned for frequency and count functions, and 99999 will be returned for the other functions), -nnnn (Instructs the INT8 to capture all events until "nnnn" edges have occurred on channel 1, until the datalogger addresses the INT8 with the CaptureTrig argument true, or until 8000 events have been captured. When the CaptureTrig argument is true, the INT8 will return up to the last nnnn events for each of the programmed INT8 channels, reset its memory, and begin capturing the next nnnn events. The INT8 waits for the first edge on channel 1 as a trigger to start making measurements. The Dest parameter must be dimensioned large enough to receive the captured events.), -9999 (Initiates a self memory test of the INT8. A numeric code is returned to indicate the results of the test.
                          CodeDescription0Bad ROM-0Bad ROM and bad RAMpositive integer Good ROM (value returned is the ROM signature) and good RAMnegative integerGood ROM (value returned is the ROM signature) and bad RAM), 0 (Bad ROM), -0 (Bad ROM and bad RAM), positive (Good ROM (value returned is the ROM signature) and good RAM), negative (Good ROM (value returned is the ROM signature) and bad RAM)

          CaptureTrig (Variable): This argument is used when the Capture All Events output option is used. When CaptureTrig is true, the INT8 will return the last nnnn events.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SDMINT8({Dest},{SDMAddress},{Config8_5},{Config4_1},{Funct8_5},{Funct4_1},{OutputOpt},{CaptureTrig},{Mult},{Offset})"


def SDMSpeed(BitPeriod: Variable | Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmspeed.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmspeed.htm).

    Args:
        BitPeriod (Variable | Constant):  Bit period defaults to 26 μsec (if the SDMSpeed instruction is not in the program). It has a minimum of 9 μsec,  a max of 2 msec, and will be set to: Actual bit_period (in μsec) =  INT (BitPeriod parameter).

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"SDMSpeed({BitPeriod})"


def SDMSW8A(
    Dest: Variable | Array,
    Reps: Constant,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FunctOp: Literal["0", "1", "2", "3"],
    SW8AStartChan: Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmsw8a.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmsw8a.htm).

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): Determines the number of channels that will be read on the SW8A. If Reps is greater than 8, measurement will continue on the next sequential SW8A. In this instance, the addresses of the SDM devices must be consecutive.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          FunctOp (Constant): Determines the result returned by the SW8A. A numeric value is entered. Right-click the parameter to display a drop-down list box.
    Must be one of following options: 0 (Returns the state of the signal at the time the instruction is executed. A 0 is stored for low and a 1 is stored for high.), 1 (Returns the duty cycle of the signal. The result is the percentage of time the signal is high during the scan interval.), 2 (Returns a count of the number of positive transitions of the signal.), 3 (Returns a value indicating the condition of the module:
                          positive integer = ROM and RAM are goodnegative value = RAM is badzero = ROM is bad)

          SW8AStartChan (Constant): The first channel that should be read on the SW8A. If the Reps parameter is greater than 1, measurements will be made on sequential channels.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return (
        f"SDMSW8A({Dest},{Reps},{SDMAddress},{FunctOp},{SW8AStartChan},{Mult},{Offset})"
    )


def SDMX50(
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Channel: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmx50.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmx50.htm).

                This instruction is often used for troubleshooting the SDMX50 multiplexer in TDR applications.
    SDMX50 allows individual multiplexer switches to be activated independently of the TDR100 Instruction. It is useful for selecting a particular probe to troubleshoot or to determine the apparent cable length.
    Because it is usually easy to hear the multiplexer(s) switch, the SDMX50 instruction is a convenient method to test the addressing and wiring of a level of multiplexers: Program the datalogger to scan every few seconds with the SDM address for the multiplexer(s) and channel 8. The Instruction always starts with channel 1 and switches through the channels to get to the programmed channel. Switching to channel 8 will cause the most prolonged noise.
    Remember each multiplexer level has a different SDM Address. Level 1 multiplexers should be set to the address 1 greater than the TDR100, Level 2 multiplexers should be set to the address 2 greater than the TDR100 and Level 3 multiplexers should be set to the address 3 greater than the TDR100. If the SDMX50 multiplexers for a given level are connected and have their addresses set correctly they should all switch at the same time.

    Args:
                    SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

            Channel (Constant): The channel to switch to on the SDMX50 multiplexer. Valid channels are 1 through 8.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SDMX50({SDMAddress},{Channel})"


def SecsSince1990(
    Source: Variable, DateOption: Literal["1", "2", "3", "4", "5", "6"]
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/secssince1990.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/secssince1990.htm).

                The variable in which the number of seconds is stored should be formatted as Long or as a String. If the source parameter is a date/time string and Variable is of type Long, the number of seconds since 1990 is returned. If the source parameter is a Long containing the number of seconds since 1990 and Variable is of type String, a date/time string is returned.
    One of the uses for this function is to retrieve a record from a data table using the GetRecord instruction based on the time the record was stored rather than based on a record number. (See the example program.)
    The SecsSince1990 function should not be nested within another function when the expected result is a string (for example, the code DateTime(1) = Left(SecsSince1990(Public.Timestamp(1,1),1),19) will not work).

    Args:
                    Source (Variable): The variable to be acted upon by the function. It can be a variable formatted as a String that contains a date and time, or a variable formatted as a Long that contains the number of seconds since January 1, 1990.

            DateOption (Constant): Specifies the format of the date/time string used as the source or the format of the date/time string to be returned by the function. Note: The resolution of this function is 1 second. Fractional seconds are not used during conversion from the date/time string to seconds since 1990. If they are included, the timestamp will be truncated. Right-click the parameter to display a list of options: Note: Fractional seconds are always reported as ".00". Where: dd = Day of Month, 01 – 31ddd = day of week (Mon, Tue, Wed, etc)ff = Fractional second; always reported as 00HH = Hour, 00 - 23MM = Month, 01- 12MMM = Abbreviated name of the month (Jan, Feb, etc.)mm = Minute, 00 - 59ss = Seconds, 00 - 59yyyy = Year, 0000 - 9999GMT = Designation that time displayed is Greenwich Mean Time
      Must be one of following options: 1 (“MM/dd/yyyy HH:mm:ss”), 2 (“ddd, dd MMM yyyy HH:mm:ss GMT”Note: Greenwhich Mean Time if “UTC Offset” setting is set. If UTC Offset is not set, time returned will be datalogger time and “GMT” will be omitted from the string.), 3 ("dd/MM/yyyy HH:mm:ss"), 4 ("yyyy-MM-dd HH:mm:ss"), 5 ("yyyy-MM-dd_HH-mm-ss"), 6 ("yyyy-MM-dd_HH-mm-ss.ff")

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SecsSince1990({Source},{DateOption})"


def SendData(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    DataTable: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TableOption: Literal["0", "-1", "X"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/senddata.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/senddata.htm).

                The SendData instruction sends the most recent record written to the data table. A record is sent only if new data has been stored to the table since the last record sent. This instruction can be used to send data to a PC running the LoggerNet server. When received, LoggerNet will store the data in a file under a name that follows its naming convention, as specified in the Setup window of the software.
    SendData is a one-way transaction; thus, no error checking is performed to ensure the record was received in the destination PakBus device. SendData can be a more efficient means of data collection in some networks (for example, time division polling via RF). However, because only the most recent record is sent and because there is no error checking, there may be records that do not get sent to (or received by) the destination PakBus address. LoggerNet can be configured to collect these holes in the data if “One Way Data Hole Collection” is enabled in the Setup window and if scheduled data collection is not paused. Note, however, that particularly in a time division polled network, where SendData transactions have priority over the collection of holes in the data, hole collection may take a significant amount of time to complete. When sending one-way data to LoggerNet, it is recommended that Pakbus Port Always Open be enabled and a delay hang-up be added to the datalogger in the network map.
    To SendData to another PakBus datalogger, the receiving datalogger's program must contain the AcceptDataRecords instruction.
    To SendData from a hidden table (TableHide instruction), append .secured to the data table name (for example, Mytable.secured).
    If the sending datalogger is a GRANITE 9 or GRANITE 10, to send data to another datalogger you must append .ToDatalogger to the data table name (for example, Mytable.todatalogger). For other dataloggers (CR6, GRANITE6, CR1000X), appending .todatalogger to the table name is recommended but not required. Do not append .todatalogger if sending data to LoggerNet.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A  leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            DataTable (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the DataTable from which the  last record should be sent. To send data from a hidden table (TableHide instruction), append .secured to the data table name (for example, Mytable.secured).

            TableOption (Variable | Constant): Used to specify which records should be sent to the destination PakBus device. This is an optional parameter. Right click the parameter to display a list of valid options: Sending multiple records (options -1 or X) increases the time it takes to execute the instruction (and thus, the total time for the datalogger to complete a scan). If skipped scans occur, increase the scan rate of the program or move the SendData to a SlowSequence scan.
      Must be one of following options: 0 (Send the last record stored since the last execution of the instruction. This is the default option if the option code parameter is omitted.), -1 (Send all new records since the last execution of the instruction.), X (Send the last X number of records (where X is an integer). If the number of available records is less than X, then all records will be sent. Note that this option can result in sending duplicate records, since it sends a discrete number of records with each execution of the instruction)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SendData({ComPort},{NeighborAddr},{PakBusAddr},{DataTable},{TableOption})"


def SendFile(
    Result: Literal[
        "0",
        "-1",
        "-2",
        "-9",
        "-14",
        "-16",
        "-17",
        "-18",
        "-20",
        "-21",
        "-22",
        "-25",
        "-26",
        "-27",
        "1,",
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    LocalFile: Literal["CPU:", "CRD:", "USR:", "USB:"],
    RemoteFile: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendfile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendfile.htm).

                The SendFile instruction can be used along with the TableFile instruction to send a file to a remote PakBus datalogger.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    Result (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -2 (Illegal drive, cannot open the file in the remote, or destination drive full.), -9 (Wrong fragment sent to the remote.), -14 (Too many files opened in the remote.), -16 (Table name and/or field name not present in the remote datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the sending datalogger is not dimensioned large enough to accommodate the values to be sent or array in the receiving datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -25 (Cannot seek in the file.), -26 (Cannot open the local file.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If  a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.         When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed to a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A  leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.  Note that in RF400 communication, the timeout should be sufficiently long to avoid collisions (the default of 0 should accomplish this, or use at least 500 ms).

            LocalFile (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Device and Filename, enclosed in quotes, where the file to be sent is stored ("Device:FileName").Valid devices are:  The USR device is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512-byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up).
      Must be one of following options: CPU: (Internal CPU), CRD: (External Memory Card), USR: (User-Defined Drive), USB: (SC115)

            RemoteFile (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Device and Filename, enclosed in quotes, where the file should be stored on the remote datalogger ("Device:FileName"). PakBus datalogger device options are: CPU: = datalogger CPU drive; CRD: = memory card; USB: = SC115 or external USB drive; CS9: = SC115; or USR: = user defined drive.  NOTE: In GRANITE Datalogger Modules, the USB device is an external USB drive and the CS9 device is an SC115. In all other dataloggers, the USB device is the SC115.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SendFile({Result},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{LocalFile},{RemoteFile})"


def SendTableDef(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    DataTable: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendtabledef.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendtabledef.htm).

              This instruction can be used to send table definitions from a datalogger to a PC running the LoggerNet server. Note that the communications protocol does not allow sending a table definition that is greater than the maximum PakBus packet size (default is 1000 bytes or 988 bytes if Encryption is used).

    Args:
                  ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.
    Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

          NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A  leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

          PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

          DataTable (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name of the DataTable from which to send the table definitions. To send the table definitions from a hidden table (TableHide instruction), append .secured to the data table name (for example, Mytable.secured).

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SendTableDef({ComPort},{NeighborAddr},{PakBusAddr},{DataTable})"


def SendGetVariables(
    ResultCode: Literal[
        "0", "-1", "-2", "-16", "-18", "-20", "-21", "-22", "-27", "1,"
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    SendVariable: Literal["Destination", "Destination", "Destination"],
    SendSwath: Constant,
    GetVariables: Literal["Destination", "Destination", "Destination", "Destination"],
    GetSwath: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendgetvariables.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendgetvariables.htm).

                When the SendGetVariables instruction is used in a datalogger, data transmission times are controlled by a host datalogger. Most often, this instruction is preceded by the TimeUntilTransmit instruction to trigger the execution of the SendGetVariables instruction. The program in the host datalogger must contain the Network instruction, which sets the times that the destination dataloggers should respond. One of the values sent by the host datalogger is its clock value; the destination datalogger synchronizes its clock with that value.
    If security is enabled in the host datalogger, it must be unlocked to level 2 for this instruction to be successful.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    ResultCode (Variable): The variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -2 (The Master datalogger cannot find this destination device in its Network
    instructions list.), -16 (Table name and/or field name not present in the source datalogger, or the field
    is read only in the destination datalogger.), -18 (Array in the source datalogger is not dimensioned large enough to accommodate the values to be sent or array in the destination datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If  a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.   When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed as a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A  leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.

            SendVariable (Variable): The variable(s) that will be sent from this datalogger to the destination datalogger(s). If sending a Public variable that has been Aliased, either the Alias or the original variable name can be used. If multiple values are being sent to multiple destination dataloggers, this parameter must be a multi-dimensional array containing the values to be sent to each destination device. For instance, if you are sending 2 values to each of 3 destination devices, the variable should be dimensioned to (3, 2). The results would be:
      Must be one of following options: Destination (Destination device 1, value 2 = (1, 2)), Destination (Destination device 2, value 2 = (2, 2)), Destination (Destination device 3, value 2 = (3, 2))

            SendSwath (Constant): Specifies the number of values that will be sent to the destination datalogger. If values are being sent to multiple destination devices, this is the number being sent to each destination device.

            GetVariables (Variable): The variable or variable array in which values retrieved from the destination datalogger will be stored. If multiple values are being retrieved from multiple dataloggers, this parameter must be dimensioned to a multi-dimensional array large enough to accommodate the values returned. For example, if 2 values are being returned by each of 4 destination devices, the variable should be dimensioned to (4, 2). For the SendGetVariables instruction, the GetVariables parameter  must be dimensioned to the size of the GetSwath parameter.
      Must be one of following options: Destination (Destination device 1, value 2 = (1, 2)), Destination (Destination device 2, value 2 = (2, 2)), Destination (Destination device 3, value 2 = (3, 2)), Destination (Destination device 4, value 2 = (4, 2))

            GetSwath (Constant): Specifies the number of values that will be received from the destination datalogger. If values are being received from multiple destination devices, this is the number from each destination device.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SendGetVariables({ResultCode},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{SendVariable},{SendSwath},{GetVariables},{GetSwath})"


def SendVariables(
    ResultCode: Literal[
        "0", "-1", "-16", "-17", "-18", "-20", "-21", "-22", "-27", "1,"
    ],
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
    Security: Integer,
    TimeOut: Constant,
    TableName: Variable,
    Fieldname: Variable,
    Variable: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Swath: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendvariables.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sendvariables.htm).

                Values can only be sent to the destination datalogger's Public or Status table. The Variable and Swath parameters are used to determine what values are sent to the destination datalogger. The first value to be sent is defined with Variable, and the number of values is specified by Swath. The most recent value(s) stored in the table are sent.
    The SendVariables instruction can be used to initiate a datalogger call-back attempt to a computer running LoggerNet. In this instance, the TableName should be set to Public and the FieldName to Callback (see the second example program). When the software receives the string "Callback" from the datalogger, it initiates a data collection from the datalogger.
    If security is enabled in the destination datalogger, it must be unlocked to level 2 for this instruction to be successful.
    If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using this instruction. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200).

    Args:
                    ResultCode (Variable): The variable in which a response code for the transmission will be stored. A zero indicates a successful transaction. A positive value indicates that there was no response to the request from the remote. A negative value indicates some other type of error occurred. The codes that can be returned are:
      Must be one of following options: 0 (Successful.), -1 (Response received but permission denied.), -16 (Table name and/or field name not present in the source datalogger, or the field
    is read only in the destination datalogger.), -17 (Data type not supported.), -18 (Array in the source datalogger is not dimensioned large enough to accommodate the values to be sent or array in the destination datalogger is not large enough to accommodate values received), -20 (Out of Comms memory.), -21 (Failed to route packet when routing is set to auto-discover and route is not yet
    known.), -22 (Communication port buffer exceeded.), -27 (DialSequence/EndDialSequence returned False so communication did not occur.), 1, (The number of timeouts waiting for a response. The value will increment with each successive failure. After a 0 or negative response, the value will start over at 1.)

            ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. If  a negative value is entered for the ComPort, the datalogger will not wait on a response from the destination device before proceeding to the next instruction. If autodiscovery is enabled (NeighborAddr=non-valid PakBus ID), this parameter is ignored.  When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort. If PakBusTCPServer setting is being used rather than TCPOpen, use the Route(-PakBusAddr ) instruction for the ComPort parameter. When sending values to a remote datalogger, SerialOpen must be used in the remote datalogger’s program to open the port for receiving the values.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify a static route to the destination datalogger (for example, the PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of a "neighbor" datalogger that the host can go through to communicate with the destination datalogger). Note that the datalogger will attempt to use this route only until it "learns" a dynamic route to the destination datalogger. If 0 is entered, the destination device is assumed to be a neighbor (i.e., the host datalogger can communicate with the destination directly). If a non-valid PakBus address is entered (a negative number or a number greater than 4094), the route to the destination device will be "autodiscovered" by other means in the PakBus network (such as beaconing or a Hello messages). If the instruction has a ResultCode parameter, an error code is returned until the route is discovered. When autodiscovery is used, the COMPort parameter is ignored. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.  Note that if the datalogger is configured as a leaf node A PakBus node at the end of a branch. When in this mode, the datalogger is not able to forward packets from one of its communication ports to another. It will not maintain a list of neighbors, but it still communicates with other PakBus dataloggers and wireless sensors. It cannot be used as a means of reaching (routing to) other dataloggers. (as opposed to a router A device configured as a router is able to forward PakBus packets from one port to another. To perform its routing duties, a datalogger configured as a router maintains its own list of neighbors and sends this list to other routers in the PakBus network. It also obtains and receives neighbor lists from other routers. Routers maintain a routing table, which is a list of known nodes and routes. A router will only accept and forward packets that are destined for known devices. Routers pass their lists of known neighbors to other routers to build the network routing system.), setting the NeighborAddr to autodiscover should be used with care. A  leaf node is aware only of its direct neighbors but has no knowledge of the rest of the PakBus network; therefore, it is not capable of "autodiscovering" a route to a destination datalogger that is not a direct neighbor. If the direct neighbors it can communicate with are not routers themselves, any communication packets sent will fail. Communication packets from the leaf node to the rest of the network also will fail if its direct router is no longer in the network.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions. If the PakBusAddr parameter is negated, communication generated by this instruction will not be encrypted using PakBus Encryption.

            Security (Integer): The security code of the remote datalogger. 0 is entered for this parameter if no security is set in the destination datalogger. If security is enabled, it must be unlocked to level 3.  NOTE: If other data logger security settings, such as TCP password and PakBus Encryption are set, these must also match between remote and local data loggers for successful data logger to data logger communications to occur.

            TimeOut (Constant): The amount of time, in 0.01 seconds, that the datalogger should wait for a response before considering the instruction to have failed. The datalogger waits for the TimeOut period to expire before proceeding to the next instruction.  If 0 is entered for this parameter, then the datalogger will use a time based on its known route to the destination device.  NOTE: In RF400 communication, the timeout should be sufficiently long to avoid collisions (the default of 0 should accomplish this, or use at least 500 ms).

            "TableName" (Variable): The name of the DataTable which contains the values to retrieve (GetVariables) or the table to which values will be sent (SendVariables). TableName must be entered as a string (enclosed in quotes). NOTE: Values can only be sent to or retrieved from an input location in an Edlog-programmed PakBus datalogger (CR10XPB, CR510PB, or CR23XPB). The TableName to be used is "Inlocs" (or "Public") and the FieldName is the input location label. For the SendVariables instruction, the TableName parameter is the data table in the destination PakBus device to which the value(s) will be sent. Values can be sent only to the Public (or Inlocs) or Status table.

            "Fieldname" (Variable): Used to specify the name of the variable(s) in the destination datalogger for (SendVariables) or retrieve from (GetVariables). If Swath is greater than 1, FieldName must be an array. FieldName must be entered as a string (enclosed in quotes). If the variable in the source datalogger has been assigned an Alias, the alias must be used for Fieldname unless the value requested is from the Public table. In this case, either the original name or the Alias name can be used (the exception is CR200 series dataloggers; they require that the Alias be used). If the requested Fieldname is from an output table of a CRBasic datalogger, and the output is something other than a sample, the output type suffix must be added to the variable name (for example, Temp_Avg). For more information, see CRBasic Program Structure. For the SendVariables instruction, the FieldName parameter is used to specify the name of the variable or variable array in the destination PakBus device to which data will be sent. If the variable in the destination datalogger has been assigned an Alias, either the original name or the Alias name can be used.

            Variable (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Variable parameter is usually a variable or variable array that holds the values to be sent to the destination PakBus device. This variable must be dimensioned equal to or greater than the Swath of values that will be sent. The variable parameter may also be used to send an expression or a string expression to a destination PakBus device. In this case, the value of the expression is enclosed in quotes. For example, if the variable parameter is set to "Hello",  Hello will be sent to the destination device.

            Swath (Constant): The number of variables that will be retrieved from or sent to the datalogger. NOTE: Values can only be sent to an input location in an Edlog-programmed PakBus datalogger (CR10XPB, CR510PB, or CR23XPB). The TableName to be used is "Inlocs" (or "Public") and the FieldName is the input location label.If RF400 radios are being used for communication and retries are enabled, a negative value should not be used on the COMPort, and at least 2 seconds should be used for the TimeOut parameter.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SendVariables({ResultCode},{ComPort},{NeighborAddr},{PakBusAddr},{Security},{TimeOut},{TableName},{Fieldname},{Variable},{Swath})"


def SerialOpen(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    BaudRate: Constant,
    SerialOpenFormat: Literal[
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "26",
        "27",
        "29",
        "30",
        "31",
    ],
    TXDelay: Variable | Constant,
    BufferSize: Constant | Integer,
    CommsMode: Literal["0", "1", "2", "3", "4", "5", "6*", "7*", "*"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialopen.htm).

                When the SerialOpen function is executed, the serial port is "opened" and subsequent textual messages will flow in and out of the port in between PakBus packets. The data are directed away from the terminal mode input based on subsequent SerialIn and SerialOut functions. This function returns True when successful or False when unsuccessful.
    This instruction can be placed after BeginProg and prior to the Scan instruction (so it is executed only once) or after the Scan instruction (so that it is executed with each scan). Once opened, the serial port will remain open and the datalogger will not go into low power mode until a SerialClose is encountered (note that an exception is format 4, where the port will go to sleep after 40 seconds of inactivity, allowing the datalogger to go into a lower power mode).  If a serial port is open, other communication may be prevented from occurring over that port. Note also that keeping the RS232 port open, and thus powered up, will increase power consumption. However, it will also prevent the possibility of the first few incoming characters being lost. Consideration should be given to which is the better tradeoff for the application.
    SerialOpen will close an existing PPP connection if it opens the ComPort for a PPP interface on that same ComPort.
    SerialFlush can be used to clear the buffer under program control.
    When the communications port is set up for PakBus protocol, a combination of TXDelay and BufferSize are used to send serial packets. All ports except COM ports are set for PakBus active, unless set otherwise with SerialOpen. With each packet sent, communication is delayed for the period in TXDelay, and then a packet is sent. (An exception is that PakBus Hello messages are delayed for 4 times the TXDelay.) During communication with some devices it may be necessary to limit the packet size (BufferSize) and add a delay (TXDelay) for communication to be successful. For example, PakBus packets are 1000 bytes. The largest packet that an RF95 can accommodate is 248 bytes. Setting the buffer to 240 would limit the packet size and ensure that the RF95's buffer was not exceeded. A delay (e.g.,1,000,000 us) would ensure that each packet has sufficient time to arrive at its destination before the next packet is transmitted.
    It may also be necessary to set up a buffer for the receipt of incoming characters (such as the response to dial commands). If a buffer is needed for both sending and receiving characters, you can perform a SerialOpen/ send data /SerialClose, and then SerialOpen/ receive data /SerialClose.
    NOTE: This instruction runs inside the processing task.

    Args:
                    ComPort (Constant): The communication  port that will be used by the instruction. Right-click to display a list. SerialOpen, SerialClose, SerialOut, and SerialOutBlock also support output via SDE pin enabled or any SDC address by using extended ComPorts. Valid extended ComPorts are &H1F through &Hff (31..255, SDC address including mode bits. Note, however, that 31 is SDE pin enabled and 32 through 47 are used to address the SDM-SIO1A). When an extended ComPort is used, the output instructions will turn on SDE or address the CS I/O port with the specified SDC address, delay the amount of time specified by TXDelay, output asynchronously at the specified baud rate in the SerialOpen() instruction, delay the amount of time specified by TXDelay, then reset the CS I/O port. NOTE: The Argos and GOES satellite extended ComPort address is &H41 (65). To specify an SDC address, the most significant bit is the address; e.g., SDC 7 would be &H70 (112). NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), Com310 (Datalogger's CS I/O port; COM310 modem), Com320 (Datalogger's CS I/O port; COM320 modem), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            BaudRate (Constant): The rate, in bps, at which data is transmitted. The options are 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200. Selecting one of these options fixes the baud rate at that rate of communication.If a negative baud rate is entered, the first communication attempt will be at the specified baud rate, but if communication fails at that rate, the datalogger will go into autobaud mode (where it will try different rates until successful or until the instruction times out).  NOTE: 300 baud is not applicable for the RS232 port. Autobaud is not available on control ports used as com ports. Baud rate for SDC ports must be 9600 or greater. If a serial port is opened, it must be closed before changing the port baud rate. NOTE:  If you are using SerialOpen to control a SDM-SIOx (SDM-SI01A, SDM-SIO1A, SDM-SIO2R) automatic baud rate detection is not supported. Rather, setting the baud rate to a negative value  enables automatic flow control (RTS/CTS). Click here for additional information. Right-click this parameter to display a list.

            SerialOpenFormat (Constant): The Format parameter is used to specify the type of error detection to be used for the exchange of data. These format options apply to all ComPorts except COM310 and COMSDC ports,  as the format is ignored for these ports due to their predefined behavior. If you are using SerialOpen to control a SDM-SIO1A, SDM-SIO4A, or SDM-SIO2R module, click here for details on SerialOpen format parameters that are specific for SDM-SIO devices. NOTE:  Typical RS-232 connections use logic 1 low. Typical TTL connections use logic 1 high. NOTE:  With RS-485 and RS-422 communications, logic level is ignored. You must select the parity, stop, and data bits.  However, either logic level can be used. NOTE:  All formats use one start bit. C Terminals Only By default, the RS-232 is set up for PakBus communication (i.e., PakBus active), unless changed by SerialOpen. However, the control ports are not. They must first be set up for PakBus communication using option 4.  NOTE:  Formats 0 and 16 ignores ASCII character 0 (Null) and ASCII characters above 127. Formats 3 and 19 should be used in place of formats 0 and 16 respectively, when handling binary data. Formats 0 and 16 should be used only for ASCII communication. Non-ASCII characters will be filtered by the PakBus communications stack while searching for a PakBus frame. When disabling PakBus communication on the RS232 port, an alternative method of connection should be used, such as the ComUSB port.
      Must be one of following options: 16 (Logic 1 high; No parity, one stop bit, 8 data bits; No error checking; PakBus communication can occur concurrently on the same port), 17 (Logic 1 high; Odd parity, one stop bit, 8 data bits), 18 (Logic 1 high; Even parity, one stop bit, 8 data bits), 19 (Logic 1 high; Binary, no parity, one stop bit, 8 data bits), 20 (Logic 1 high; PakBus protocol active, 2 stop bits, 8 data bits), 21 (Logic 1 high; Odd parity, two stop bits, 8 data bits), 22 (Logic 1 high; Even parity, two stop bits, 8 data bits), 23 (Logic 1 high; Binary, no parity, two stop bits, 8 data bits), 25 (Logic 1 high; Odd parity, one stop bit, 7 data bits), 26 (Logic 1 high; Even parity, one stop bit, 7 data bits), 27 (Logic 1 high; Binary, no parity, one stop bit, 7 data bits), 29 (Logic 1 high; Odd parity, two stop bits, 7 data bits), 30 (Logic 1 high; Even parity, two stop bits, 7 data bits), 31 (Logic 1 high; Binary, no parity, two stop bits, 7 data bits)

            TXDelay (Variable | Constant): Specifies the amount of time to delay, in microseconds, before outputting strings. A delay may be necessary in some situations, such as half duplex RF media. When communicating with an SDC device on a port other than SDC7 or SDC8, the TXDelay parameter applies a delay both after addressing the SDC device and before resetting the SDC device.

            BufferSize (Constant | Integer): Specifies the number of bytes allocated for input on the ComPort. This buffer is set up as ring memory. Use SerialFlush to clear the buffer. Note that the datalogger tracks a write pointer and a read pointer for the buffer. It determines if new data has been written by write pointer - read pointer. If the number of incoming bytes stored in the buffer is equal to the buffer size, the datalogger may not detect that new data has been received in the buffer. Therefore, the buffer size should be set to at least the number of expected incoming characters + 1.  For PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. communication (format option 4, PakBus protocol active), there is a PakBus buffer by default,so BufferSize can normally be left at 0.

            CommsMode (Variable | Constant | Expression | Array | Integer | ConstantInteger): This optional parameter is left blank when used with the SDM-SIO1A or SDM-SIO4A. The CommsMode specifies the configuration of the datalogger's control port used by this instruction. The ports can also be configured using Device Configuration Utility. Configuring the ports using the SerialOpen instruction will change the setting if it was previously set by other means. TIP:RS-422 protocol is similar to RS-485. Most RS-422 sensors will work with RS-485 protocol.
      Must be one of following options: 0 (Configures the port as RS-232, 5V and -5V voltage levels (ComC1-ComC7, and CPI/RS-232 )), 1 (Configures the port as TTL, 5V and 0V voltage levels ( ComC1-ComC7)), 2 (Configures the port as LVTTL, 3.3V and 0V voltage levels (
     ComC1-ComC7
    )), 3 (Configures the port as RS-485 half-duplex, PakBus communication (ComC1, ComC3, ComC5, or ComC7;  Odd ports  = A-; Even ports = B+)), 4 (Configures the port as RS-485 half-duplex, transparent (ComC1-ComC7 only; Odd ports  = A-; Even ports = B+)), 5 (Configures the port as RS-485 full-duplex (ComC1 or ComC5 only; requires 4 adjacent control ports For ComC1, C1 = TX-, C2 = TX+, C3 = RX-, C4 = RX+). For ComC5, C5=TX-, C6 = TX+, C7=RX-, C8=RX+)), 6* (RS-485 TX only. In this configuration the transceiver is left on so the A(-) and B(+) idle in a marking state (logical '1').), 7* (RS-422 full-duplex transparent. In this configuration, the transceiver for the transmit pair is left on. The transmit pair A(-) and B(+) idle in a marking state (logical '1').), * (Optional parameter added in OS 8.00 and newer.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialOpen({ComPort},{BaudRate},{SerialOpenFormat},{TXDelay},{BufferSize},{CommsMode})"


def SerialClose(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialclose.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialclose.htm).

                This function returns True (-1) if the port was opened or False (0) if it was already closed.
    Note that when executed, SerialClose will drop the DTR line on ComRS232 or the ME (modem enable) line on ComME.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.
    NOTE: This instruction runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode.

    Args:
                    ComPort (Constant): The communication  port that will be used by the instruction. Right-click to display a list. SerialOpen, SerialClose, SerialOut, and SerialOutBlock also support output via SDE pin enabled or any SDC address by using extended ComPorts. Valid extended ComPorts are &H1F through &Hff (31..255, SDC address including mode bits. Note, however, that 31 is SDE pin enabled and 32 through 47 are used to address the SDM-SIO1A). When an extended ComPort is used, the output instructions will turn on SDE or address the CS I/O port with the specified SDC address, delay the amount of time specified by TXDelay, output asynchronously at the specified baud rate in the SerialOpen() instruction, delay the amount of time specified by TXDelay, then reset the CS I/O port. NOTE: The Argos and GOES satellite extended ComPort address is &H41 (65). To specify an SDC address, the most significant bit is the address; e.g., SDC 7 would be &H70 (112). NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), Com310 (Datalogger's CS I/O port; COM310 modem), Com320 (Datalogger's CS I/O port; COM320 modem), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialClose({ComPort})"


def SerialFlush(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialflush.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialflush.htm).

                This function clears the buffer and leaves the port open. If the input buffer should be cleared before each execution of SerialIn, place SerialFlush in the code before the SerialIn instruction.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.
    NOTE:  Beginning with OS 3 in the SDM-SIO1A and SDMSIO4A, and OS 2 in the SDM-SIO2R, the Seiralflush() instruction will purge all information from the data logger and SDM recieve buffers. Prior to these SDM operating systems, SerialFlush cleared both the transmit and receive buffers; it now only clears the receive buffer.
    NOTE:  This instruction runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode.

    Args:
                    ComPort (Constant): The communication  port that will be used by the instruction. Right-click to display a list. SerialOpen, SerialClose, SerialOut, and SerialOutBlock also support output via SDE pin enabled or any SDC address by using extended ComPorts. Valid extended ComPorts are &H1F through &Hff (31..255, SDC address including mode bits. Note, however, that 31 is SDE pin enabled and 32 through 47 are used to address the SDM-SIO1A). When an extended ComPort is used, the output instructions will turn on SDE or address the CS I/O port with the specified SDC address, delay the amount of time specified by TXDelay, output asynchronously at the specified baud rate in the SerialOpen() instruction, delay the amount of time specified by TXDelay, then reset the CS I/O port. NOTE: The Argos and GOES satellite extended ComPort address is &H41 (65). To specify an SDC address, the most significant bit is the address; e.g., SDC 7 would be &H70 (112). NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), Com310 (Datalogger's CS I/O port; COM310 modem), Com320 (Datalogger's CS I/O port; COM320 modem), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialFlush({ComPort})"


def SerialIn(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ComPort_Serial_In: Literal[
        "ComRS232",
        "ComMe",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    TimeOut: Constant,
    TerminationChar: Variable | Constant | Integer,
    MaxNumChars: Variable | Constant | Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialin.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialin.htm).

                Incoming data is stored in the destination variable until the TerminationChar is received, MaxNumChars value is met, or the TimeOut parameter is exceeded. After the end condition is met, SerialIn will terminate the destination variable with a null. Strings used as termination characters are included in the destination variable; however, numeric characters are not. A null character will terminate the string, but any characters after the null will nevertheless continue to be received into the variable space until one of the termination conditions is met. Incoming characters are buffered in ring memory, the size of which is determined by the SerialOpen function. The buffer can be cleared using the SerialFlush instruction. For incoming data, extended ASCII characters (128-255) are supported only by SerialOpen format options 1-7 and 17-23.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable in which the incoming data will be stored. The variable is formatted as a string. NOTE:  Beginning with OS 7,  a variable of type UINT1 may be used (See also Data Types.). Arrays of UINT1 variables can be used to store binary data received from serial sensors allowing easier processing of that data, compared to string variables.

            ComPort_Serial_In (Constant): The COM port that will be used by the instruction. Right-click to display a list. A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen. NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComMe (Datalogger's CS I/O port;modem enabled), Com310 (Datalogger's CS I/O port; Com310 modem), Com320 (Datalogger's CS I/O port; Com320 modem), ComSDC7 (Datalogger's CS I/O port; SDC7), ComSDC8 (Datalogger's CS I/O port; SDC8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            TimeOut (Constant): For the SerialIn instruction, the TimeOut parameter is used to specify the amount of time, in 0.01 seconds, that the datalogger should wait before proceeding to the next instruction. If a 0 is entered for this parameter, the datalogger will wait for the termination character (TerminationChar parameter) or maximum number of characters (MaxNumChars parameter) to be received before proceeding. TimeOut is reset with each new incoming character.  For the SerialOut instruction, the TimeOut parameter is used to specify the amount of time, in 0.01 seconds, that the datalogger should wait for the WaitString or echo of each character in the OutString. If the TimeOut is 0, the datalogger does not wait (or even check) for the WaitString or Echo before proceeding to the next instruction. The TimeOut applies to each of the NumberTries; the overall timeout period for the instruction is cumulative. TimeOut is reset with each new incoming character. As a result of internal buffering in the datalogger and/or external interfaces, data may not appear in the serial port buffer for a period of up to 50 ms (depending on the serial port being used). If the TimeOut is set at too short of an interval, the instruction may time out even though data has been received in the internal buffer (though not yet passed on to the serial port buffer). This should be taken into consideration when setting the TimeOut parameter.

            TerminationChar (Variable | Constant | Integer): Specifies a single character that marks the end of the incoming block of data. The character can be entered as an ASCII Abbreviation for American Standard Code for Information Interchange / American National Standards Institute. An encoding scheme in which numbers from 0-127 (ASCII) or 0-255 (ANSI) are used to represent pre-defined alphanumeric characters. Each number is usually stored and transmitted as 8 binary digits (8 bits), resulting in 1 byte of storage per character of text. character code or as a string. The termination character can be included in, or excluded from, the result string. For more information, see ASCII Codes and Characters. Exclude TerminationChar: If the TerminationChar is an ASCII value between 0 and 255, it will terminate the string input upon seeing the character. The character is not included in the result string. To enter the termination character, simply use the ASCII code. Include TerminationChar: If the TerminationChar is declared as a string, the input string will terminate after a match of the termination string is found. The matching termination string will be included in the resultant string. For printable characters, the string can be entered directly (for instance, for a period character, enter “.”). For non-printable characters, use the CHR() instruction along with the ASCII code. As an example, for a carriage return (CR), enter CHR(13). Entering a negative number or a null for the TerminationChar means there is no termination character.

            MaxNumChars (Variable | Constant | Integer): Specifies the maximum number of characters to expect per input. Once the maximum number of characters is received, the datalogger will proceed to the next instruction.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialIn({Dest},{ComPort_Serial_In},{TimeOut},{TerminationChar},{MaxNumChars})"


def SerialInBlock(
    ComPort_Serial_In: Literal[
        "ComRS232",
        "ComMe",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    Dest: Variable | Array,
    MaxNumberBytes: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinblock.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinblock.htm).

                Incoming serial data, up to the value defined in MaxNumberBytes, is stored in the Dest parameter. SerialInBlock will not wait for the return of characters. If no new characters are received since the last execution of the function, 0 is returned by the function. This function can be used as the expression for the NumberBytes parameter in the SerialOutBlock function. For incoming data, extended ASCII characters (128-255) are supported only by SerialOpen format options 1-7 and 17-23.
    NOTE: This function runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode. When SerialIn, SerialOut, SerialInBlock, and/or SerialOutBlock are used to access a COM port, the instructions should be placed in the same sequence (main program or slow sequence) to avoid unintentional concurrent reads or writes of that port.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    ComPort_Serial_In (Constant): The COM port that will be used by the instruction. Right-click to display a list. For the SerialInBlock instruction, the ComPort parameter specifies the communication port and mode that is used when receiving the binary data. A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen. NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComMe (Datalogger's CS I/O port;modem enabled), Com310 (Datalogger's CS I/O port; Com310 modem), Com320 (Datalogger's CS I/O port; Com320 modem), ComSDC7 (Datalogger's CS I/O port; SDC7), ComSDC8 (Datalogger's CS I/O port; SDC8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  NOTE:  Beginning with OS 7,  a variable of type UINT1 may be used (See also Data Types.). Arrays of UINT1 variables can be used to store binary data received from serial sensors allowing easier processing of that data, compared to string variables. For the SerialInBlock instruction, the Dest parameter is the variable in which to store the incoming serial data. Once the MaxNumberBytes of incoming data is received, no more data is stored. Note that Dest is not reset to null if no new characters are received. The program can be written to ignore Dest if the instruction returns 0, or to process Dest for the number of characters received at each execution.

            MaxNumberBytes (Constant): The maximum number of bytes of binary data that will be stored in the Dest parameter.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialInBlock({ComPort_Serial_In},{Dest},{MaxNumberBytes})"


def SerialInChk(
    ComPort_Serial_In: Literal[
        "ComRS232",
        "ComMe",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinchk.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinchk.htm).

                A variable can hold the result of the SerialInChk function (variable = SerialInChk(Comport)) or the function can be used in an expression (If SerialInChk(Comport)>20 Then…). If the serial port has not been opened (using SerialOpen), a -1 is returned. If the serial port buffer overflows before it has been read, it is reset to 0 and the remainder of the bytes available is returned by the function. For instance, if you have a buffer of 100 bytes, and 120 bytes come in before the buffer is read, SerialInChk returns a value of 20 (the last 20 bytes received). In this instance, there is no way to detect that the buffer has overflowed and been reset.
    Beginning with OS 7.0, SerialInChk() will flush the hardware buffer to the serial buffer immediately when the SerialInChk() fiunction is executed. Prior to the OS change, data may not appear in the serial port buffer until there is at least 50 ms of idle communication time. If the SerialIn instruction's TimeOut is set at too short of an interval, the instruction may time out even though data has been received in thehardware buffer (though not yet passed on to the serial port buffer). This should be taken into consideration when setting that instruction's TimeOut parameter.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    ComPort_Serial_In (Constant): The COM port that will be used by the instruction. Right-click to display a list. A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComMe (Datalogger's CS I/O port;modem enabled), Com310 (Datalogger's CS I/O port; Com310 modem), Com320 (Datalogger's CS I/O port; Com320 modem), ComSDC7 (Datalogger's CS I/O port; SDC7), ComSDC8 (Datalogger's CS I/O port; SDC8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialInChk({ComPort_Serial_In})"


def SerialInRecord(
    ComPort_Serial_In: Literal[
        "ComRS232",
        "ComMe",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    Dest: Variable | Array,
    BeginWord: Constant,
    NBytes: Constant,
    EndWord: Constant,
    NBytesReturned: Variable,
    SerialInRecOption: Literal["00", "01", "10", "11"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinrecord.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialinrecord.htm).

                The SerialInRecord instruction can be used to read in and parse a string/record from a serial sensor. The BeginWord and EndWord parameters are used to define the beginning and/or ending of each string/record.
    This instruction is typically handled by the digital task sequencer in the datalogger. However, if the ComPort parameter is a variable, the instruction is handled by the processing task.
    The SerialOpen or TCPOpen instruction is used to set the size of the serial buffer in which the incoming data is held until it is stored into Dest. The buffer should be large enough to hold all of the data that can come in between calls to the SerialInRecord. In most cases data records are received by the datalogger asynchronous with the datalogger's scan rate (or rate of execution of SerialInRecord). The buffer size should be at least the size of two records plus one byte if the data records are coming in faster than the scan rate or at least one record plus one byte if the records are coming in slower than the scan rate. (The additional byte avoids the situation where if the number of incoming bytes stored in the buffer is equal to the buffer size, the datalogger may not detect that new data has been received in the buffer.) The size of a record includes the BeginWord, EndWord, and all bytes in between.
    Note that when the datalogger is executing its program in Pipeline mode, the BufferOption in the Scan instruction affects the size of the buffer. The actual buffer size is Scan BufferOption * BufferSize (BufferSize in the SerialOpen/TCPOpen command). Thus, assigning large buffer sizes should be avoided as it will use large amounts of memory unnecessarily.
    Multiple SerialInRecord instructions can be used in the program so that more than one sensor can be read via a single COM port, or multiple responses from one sensor can be read and stored separately. The SerialInRecordOption parameter is used to determine if the instructions will use one memory read pointer (global) for all incoming records or if memory pointers are tracked with each call of the instruction (local). For multiple sensors or responses through the same COM port, a local pointer should be used.
    Examples of using multiple SerialInRecord instructions to process data received on a single COM port are:
    For incoming data, extended ASCII characters (128-255) are supported only by SerialOpen format options 1-7 and 17-23.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    ComPort_Serial_In (Constant): The COM port that will be used by the instruction. Right-click to display a list. A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen. NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, Modbus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display).
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComMe (Datalogger's CS I/O port;modem enabled), Com310 (Datalogger's CS I/O port; Com310 modem), Com320 (Datalogger's CS I/O port; Com320 modem), ComSDC7 (Datalogger's CS I/O port; SDC7), ComSDC8 (Datalogger's CS I/O port; SDC8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.  NOTE:  Beginning with OS 7,  a variable of type UINT1 may be used (See also Data Types.). Arrays of UINT1 variables can be used to store binary data received from serial sensors allowing easier processing of that data, compared to string variables.

            BeginWord (Constant): A two byte word (1 to 65535) that indicates the beginning of a record. If the value entered is less than 256, the datalogger will look only for a single byte. If 0 is entered, a BeginWord is not used and the data stored in Dest will be NBytes prior to the EndWord. If &H80000000 is entered, a Null character will be used for BeginWord. Hexadecimal values can be entered for BeginWord and EndWord by preceding the characters with &H.

            NBytes (Constant): The number of bytes that should be stored in Dest after the BeginWord has been received. If NBytes is equal to or less than 0, then bytes are read between the BeginWord and the EndWord, exclusive of the BeginWord and EndWord. If the BeginWord is not used (BeginWord=0) then this parameter is the number of bytes to store prior to the EndWord.

            EndWord (Constant): A two byte word (1 to 65535) that indicates the end of a record. If 0 is entered, an EndWord is not used and the data stored in Dest will be NBytes after to the BeginWord. If &H80000000 is entered, a Null character will be used for EndWord. If the value entered is less than 256, the datalogger will look only for a single byte. Hexadecimal values can be entered for BeginWord and EndWord by preceding the characters with &H.

            NBytesReturned (Variable): A variable in which the number of bytes read by the instruction is stored, not including the BeginWord or EndWord. If the number of bytes received is too large to fit into Dest, a negative value will be returned in this parameter.

            SerialInRecOption (Variable | Constant | Expression | Array | Integer | ConstantInteger): Determines what record from the serial buffer is stored into Dest and whether the datalogger loads a NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. value or if the last value loaded will remain. Option codes include: Add 100 to the Code to use a local read pointer (i.e., 100, 101, 110, 111). If option 01 or 11 is chosen and no new record is received, the NAN value stored in Dest will depend upon its data type. If Dest is formatted as a float, NAN will be stored. If it is formatted as a LONG, &H80000000 will be stored. If Dest is formatted as a string, a NAN will be stored. See ASCII Codes and Characters for more information. NOTE: Hexadecimal values can be entered for BeginWord and EndWord by preceding the characters with &H. This instruction can be run in a conditional statement only in SequentialMode or a SlowSequence scan.
      Must be one of following options: 00 (Most recent record in serial buffer, do not store NAN if no records), 01 (Most recent record in serial buffer, store NAN if no record), 10 (Oldest record in serial buffer, do not store NAN if no record), 11 (Oldest record in serial buffer, store NAN if no record)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialInRecord({ComPort_Serial_In},{Dest},{BeginWord},{NBytes},{EndWord},{NBytesReturned},{SerialInRecOption})"


def SerialOut(
    ComPort_Serial_Out: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    OutString: Variable,
    WaitString: Variable,
    NumberTries: Variable | Constant | Integer,
    TimeOut: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialout.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialout.htm).

                This function returns the following:
    If a delay is needed before outputting the string, it should be entered in the TXDelay parameter of the SerialOpen function. If the OutString and WaitString variables are not formatted as a string, they are converted to a string by the datalogger.
    One of three conditions determines when the datalogger should proceed to the next instruction: when the WaitString is received, the NumberTries is exhausted, or the TimeOut is met.
    When this function is used to send table data out the serial port (by loading the OutString array with a data table record using GetRecord), the Tablename.Timestamp function can be used to include a timestamp in the data string.
    NOTE: This function runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode. When SerialIn, SerialOut, SerialInBlock, and/or SerialOutBlock are used to access a COM port, the instructions should be placed in the same sequence (main program or slow sequence) to avoid unintentional concurrent reads or writes of that port.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    ComPort_Serial_Out (Constant): The COM port that will be used by the instruction. Right-click to display a list. SerialOpen, SerialClose, SerialOut, and SerialOutBlock also support output via SDE pin enabled or any SDC address by using extended ComPorts. Valid extended ComPorts are &H1F through &Hff (31..255, SDC address including mode bits. Note, however, that 31 is SDE pin enabled and 32 through 47 are used to address the SDM-SIO1A). When an extended ComPort is used, the output instructions will turn on SDE or address the CS I/O port with the specified SDC address, delay the amount of time specified by TXDelay, output asynchronously at the specified baud rate in the SerialOpen() instruction, delay the amount of time specified by TXDelay, then reset the CS I/O port. NOTE:  The Argos and GOES satellite extended ComPort address is &H41 (65). To specify an SDC address, the most significant bit is the address; e.g., SDC 7 would be &H70 (112). NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, ModBus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display). A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), Com310 (Datalogger's CS I/O port; COM310 modem), Com320 (Datalogger's CS I/O port; COM320 modem), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            OutString (Variable): The variable to be sent out the serial port. If the data type being transferred is not a string, it will be formatted as one.  OutString can be null ("") if you don't want to send a string but want to wait for an incoming string before proceeding to the next instruction.

            WaitString (Variable): An incoming string for which the datalogger should wait before proceeding to the next instruction after the OutString has been sent. The WaitString will be formatted as a string by the datalogger if it is not already in that format.  A null ("") WaitString can be entered to tell the datalogger to wait for the echo of each character in the OutString. The datalogger sends the OutString one character at a time and looks for the echo of each character. If the TimeOut is 0, the datalogger does not wait for the WaitString or echo of the OutString. The datalogger will simply send each character of the OutString the NumberTries and move on to the next instruction. If TimeOut > 0, the datalogger will wait for an echo of each character sent in the OutString, failing only when the TimeOut and NumberTries are met.

            NumberTries (Variable | Constant | Integer): The total number of times the datalogger should attempt to send the OutString.  If NumberTries is 0, the OutString is sent only once without checking for a WaitString. The length of the string sent is returned. If NumberTries is 1 the OutString is sent only once but the instruction checks for the WaitString. If the WaitString is received the length of the WaitString is returned.   If the WaitString or echo of the OutString is received before the NumberTries is met, the communication is successful and the datalogger executes the next instruction. If the WaitString is null, the datalogger will wait the NumberTries for an echo of each character output. If a negative NumberTries is entered and the WaitString is null, the datalogger will exit the instruction after the first failure of an echo (where failure = the amount of time specified in the TimeOut parameter has elapsed prior to receiving the echoed character).

            TimeOut (Constant): For the SerialIn instruction, the TimeOut parameter is used to specify the amount of time, in 0.01 seconds, that the datalogger should wait before proceeding to the next instruction. If a 0 is entered for this parameter, the datalogger will wait for the termination character (TerminationChar parameter) or maximum number of characters (MaxNumChars parameter) to be received before proceeding. TimeOut is reset with each new incoming character.  For the SerialOut instruction, the TimeOut parameter is used to specify the amount of time, in 0.01 seconds, that the datalogger should wait for the WaitString or echo of each character in the OutString. If the TimeOut is 0, the datalogger does not wait (or even check) for the WaitString or Echo before proceeding to the next instruction. The TimeOut applies to each of the NumberTries; the overall timeout period for the instruction is cumulative. TimeOut is reset with each new incoming character. As a result of internal buffering in the datalogger and/or external interfaces, data may not appear in the serial port buffer for a period of up to 50 ms (depending on the serial port being used). If the TimeOut is set at too short of an interval, the instruction may time out even though data has been received in the internal buffer (though not yet passed on to the serial port buffer). This should be taken into consideration when setting the TimeOut parameter.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialOut({ComPort_Serial_Out},{OutString},{WaitString},{NumberTries},{TimeOut})"


def SerialOutBlock(
    ComPort_Serial_Out: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    Expression: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumberBytes: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialoutblock.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialoutblock.htm).

                This instruction is needed when the data to be transmitted contains a null value. (The SerialOut instruction is terminated with a null value, thus, the transmission of binary data is required.) It can also be used when the number of bytes to be output is variable, or when the device receiving the transmitted data requires that data to be in a binary format.
    NOTE: This instruction normally runs sequentially from the processing task sequencer, regardless of whether the datalogger is in pipeline or sequential mode. However, when running in pipeline mode, if the COMPort parameter is a constant set to COMC1, COMC3, COMC5, or COMC7 and NumberBytes is a constant, the instruction will run from the digital task sequencer. This instruction will also run from the digital task sequencer when used with the SDM-SIO1 (SerialOpen ComPort parameter set to 32..47). When run from the digital task in these instances, care must be taken while using other serial I/O instructions, which may run in the processing task and be out of sequence with SerialOutBlock.
    This instruction can also be used along with other serial instructions to set up and control the  SDM-SIO1A or SDM-SIO4A or SDM-SIO2R.

    Args:
                    ComPort_Serial_Out (Constant): The COM port that will be used by the instruction. Right-click to display a list. SerialOpen, SerialClose, SerialOut, and SerialOutBlock also support output via SDE pin enabled or any SDC address by using extended ComPorts. Valid extended ComPorts are &H1F through &Hff (31..255, SDC address including mode bits. Note, however, that 31 is SDE pin enabled and 32 through 47 are used to address the SDM-SIO1A). When an extended ComPort is used, the output instructions will turn on SDE or address the CS I/O port with the specified SDC address, delay the amount of time specified by TXDelay, output asynchronously at the specified baud rate in the SerialOpen() instruction, delay the amount of time specified by TXDelay, then reset the CS I/O port. NOTE:  The Argos and GOES satellite extended ComPort address is &H41 (65). To specify an SDC address, the most significant bit is the address; e.g., SDC 7 would be &H70 (112). NOTE: When using the ComME ComPort with non-PakBus protocols (PPP, ModBus, DNP3, or generic serial applications), incoming characters can be corrupted by concurrent use of the CS I/O port for SDC communication (e.g., keyboard display). A variable can be used in the ComPort parameter for use with functions that return a communication port. If communication occurs using TCP/IP, enter the variable for the socket returned by TCPOpen.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger's CS I/O port; modem enabled), Com310 (Datalogger's CS I/O port; COM310 modem), Com320 (Datalogger's CS I/O port; COM320 modem), ComSDC7 (Datalogger's CS I/O port; SDC 7), ComSDC8 (Datalogger's CS I/O port; SDC 8), ComSDC10 (Datalogger's CS I/O port; SDC10), ComSDC11 (Datalogger's CS I/O port; SDC 11), ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

            Expression (Variable | Constant | Expression | Array | Integer | ConstantInteger): The data that is being transmitted over the specified COM port.

            NumberBytes (Constant): The number of bytes of binary data from the Expression that should be transmitted. An expression  or the SerialInBlock function can also be used in this parameter.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SerialOutBlock({ComPort_Serial_Out},{Expression},{NumberBytes})"


def SerialBrk(
    ComPort: Literal["ComC1", "ComC3", "ComC5", "ComC7"], Break: Variable | Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialbrk.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/serialbrk.htm).

              SerialBrk puts the TX line of a COMPort into a break condition for the specified Break time. This instruction runs in the processing task.

    Args:
                  ComPort (Constant): Specifies the communication port to which the break will be sent.
    Must be one of following options: ComC1 (Datalogger's control ports 1 (TX) & 2 (RX)), ComC3 (Datalogger's control ports 3 (TX) & 4 (RX)), ComC5 (Datalogger's control ports 5 (TX) & 6 (RX)), ComC7 (Datalogger's control ports 7 (TX) & 8 (RX))

          Break (Variable | Constant): The duration for the break in milliseconds.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SerialBrk({ComPort},{Break})"


def SetSettings(
    FieldName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Value: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm).

                Most fields in the Status table are Read Only. However, some fields, such as StationName, may be set with the SetStatus instruction. Also, error counters in the Status table (for example, WatchdogErrors or SkippedScan) may be reset to 0 for troubleshooting purposes. Status table values may be accessed programmatically using Tablename.Fieldname syntax. E.g. Variable = Status.fieldname. For example, status fields may be used to monitor CS CELL2XX-Series diagnostic information and data usage programmatically.
    Many of the fields in the Settings table may be changed with the SetSetting instruction.  A list of setting field names is also available from the datalogger's terminal mode using command "F". Note that some settings are Read Only and cannot be set. However, Read Only setting values may be accessed programmatically using Tablename.Fieldname syntax (for example, Variable = settings.fieldname).
    The FieldName parameter is the name of the field to be changed; the name must be enclosed in quotes. The Value parameter is the value to which that field should be set. If the value being set is a string (such as StationName), it must be enclosed in quotes. If the value to be set is Long (such as baud rate) quotes are not used. If the field that is being set is defined as a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports., the string "TRUE" will be interpreted as True (-1) and the string "FALSE" will be interpreted as False (0). Any other string variable will flag an error in the compile results. Click here to see the proper syntax for SetSetting() with different field types.
    SetSetting can also be used to set the value of a User Setting under program control.
    An alternative to the SetSetting instruction is to use Tablename.Fieldname syntax to set setting values. For example, the IP address used for PPP communications could be changed with : Settings.PPPIPAddr="10.10.10.10".
    WARNING: SetSettings may cause the datalogger to reboot! Take care not to put the datalogger into an endless loop of rebooting when changing settings within a program scan.

    Args:
                    "FieldName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): "FieldName" (No description provided)

            Value (Variable | Constant | Expression | Array | Integer | ConstantInteger): Value (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SetSettings({FieldName},{Value})"


def SetSecurity(
    Security1: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Security2: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Security3: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setsecurity.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setsecurity.htm).

                The SetSecurity instruction is executed at compile time. Up to three levels of security can be set in the datalogger. Level 1 must be set before Level 2 can be set, and Level 2 must be set before Level 3 can be set. If a level is set to 0, any level greater than it will also be set to 0 (for example, if Level 2 is 0, Level 3 is 0). Valid security codes are 1 through 65535 (0 is no security). Each level must have a unique code.
    Use the SetSetting instruction to set security during run-time by using a variable for the security code, which can then be edited by the user.
    Software access functions affected by each level of security are:

    Args:
                    Security1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Security1 (No description provided)

            Security2 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Security2 (No description provided)

            Security3 (Variable | Constant | Expression | Array | Integer | ConstantInteger): Security3 (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SetSecurity({Security1},{Security2},{Security3})"


def SetStatus(
    FieldName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Value: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm).

                Most fields in the Status table are Read Only. However, some fields, such as StationName, may be set with the SetStatus instruction. Also, error counters in the Status table (for example, WatchdogErrors or SkippedScan) may be reset to 0 for troubleshooting purposes. Status table values may be accessed programmatically using Tablename.Fieldname syntax. E.g. Variable = Status.fieldname. For example, status fields may be used to monitor CS CELL2XX-Series diagnostic information and data usage programmatically.
    Many of the fields in the Settings table may be changed with the SetSetting instruction.  A list of setting field names is also available from the datalogger's terminal mode using command "F". Note that some settings are Read Only and cannot be set. However, Read Only setting values may be accessed programmatically using Tablename.Fieldname syntax (for example, Variable = settings.fieldname).
    The FieldName parameter is the name of the field to be changed; the name must be enclosed in quotes. The Value parameter is the value to which that field should be set. If the value being set is a string (such as StationName), it must be enclosed in quotes. If the value to be set is Long (such as baud rate) quotes are not used. If the field that is being set is defined as a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports., the string "TRUE" will be interpreted as True (-1) and the string "FALSE" will be interpreted as False (0). Any other string variable will flag an error in the compile results. Click here to see the proper syntax for SetSetting() with different field types.
    SetSetting can also be used to set the value of a User Setting under program control.
    An alternative to the SetSetting instruction is to use Tablename.Fieldname syntax to set setting values. For example, the IP address used for PPP communications could be changed with : Settings.PPPIPAddr="10.10.10.10".
    WARNING: SetSettings may cause the datalogger to reboot! Take care not to put the datalogger into an endless loop of rebooting when changing settings within a program scan.

    Args:
                    "FieldName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): "FieldName" (No description provided)

            Value (Variable | Constant | Expression | Array | Integer | ConstantInteger): Value (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SetStatus({FieldName},{Value})"


def SetSetting(
    FieldName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Value: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/setstatussetsetting.htm).

                Most fields in the Status table are Read Only. However, some fields, such as StationName, may be set with the SetStatus instruction. Also, error counters in the Status table (for example, WatchdogErrors or SkippedScan) may be reset to 0 for troubleshooting purposes. Status table values may be accessed programmatically using Tablename.Fieldname syntax. E.g. Variable = Status.fieldname. For example, status fields may be used to monitor CS CELL2XX-Series diagnostic information and data usage programmatically.
    Many of the fields in the Settings table may be changed with the SetSetting instruction.  A list of setting field names is also available from the datalogger's terminal mode using command "F". Note that some settings are Read Only and cannot be set. However, Read Only setting values may be accessed programmatically using Tablename.Fieldname syntax (for example, Variable = settings.fieldname).
    The FieldName parameter is the name of the field to be changed; the name must be enclosed in quotes. The Value parameter is the value to which that field should be set. If the value being set is a string (such as StationName), it must be enclosed in quotes. If the value to be set is Long (such as baud rate) quotes are not used. If the field that is being set is defined as a Boolean Data type used to represent conditions or hardware that have only two states (true or false) such as flags and control ports., the string "TRUE" will be interpreted as True (-1) and the string "FALSE" will be interpreted as False (0). Any other string variable will flag an error in the compile results. Click here to see the proper syntax for SetSetting() with different field types.
    SetSetting can also be used to set the value of a User Setting under program control.
    An alternative to the SetSetting instruction is to use Tablename.Fieldname syntax to set setting values. For example, the IP address used for PPP communications could be changed with : Settings.PPPIPAddr="10.10.10.10".
    WARNING: SetSettings may cause the datalogger to reboot! Take care not to put the datalogger into an endless loop of rebooting when changing settings within a program scan.

    Args:
                    "FieldName" (Variable | Constant | Expression | Array | Integer | ConstantInteger): "FieldName" (No description provided)

            Value (Variable | Constant | Expression | Array | Integer | ConstantInteger): Value (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SetSetting({FieldName},{Value})"


def SNMPVariable(
    Name: Variable,
    OID: Constant,
    Type: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Access: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Valid: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/snmpvariable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/snmpvariable.htm).

        The ESSInitialize instruction must be in the program to enable SNMP in the datalogger. Both ESSInitialize and SNMPVariable should be included in the program after the BeginProg statement.

    Args:
            Name (Variable): The name of the variable or variable array in the CRBasic program. If the variable is not already declared, it will be declared by this instruction as a Public variable.

    OID (Constant): The object identifier, represented using dot notation; e.g., 1.3.6.1.4.1.111.4.1.1. If the variable is an array, elements of that array are accessed using the syntax root.element (where root is the OID and element is the element number of the array; e.g., 1.3.6.1.4.1.111.4.1.1.2 specifies element number 2 of the object ID 1.3.6.1.4.1.111.4.1.1 variable). In addition to the user defined OIDs, the following OIDs are supported in the datalogger: 1.3.6.1.2.1.1.1 sysDescr1.3.6.1.2.1.1.2 sysObjectID1.3.6.1.2.1.1.3 sysUpTime1.3.6.1.2.1.1.4 sysContact1.3.6.1.2.1.1.5 sysName1.3.6.1.2.1.1.6 sysLocation1.3.6.1.2.1.1.7 sysServices When ESSVariables and SNMPVariable are used in the same program, these user-defined OIDs must begin with an identifier of 1.3.6.1.4.1.1207 or greater (the last OID in the datalogger OS structure for ESSVariables is 1.3.6.1.4.1.1206).

    Type (Variable | Constant | Expression | Array | Integer | ConstantInteger): The data type of the managed object. Type can be Integer, Counter, String, TimeTicks, Opaque, Gauge, or Float. If this parameter is omitted, the object assumes the data type of the variable declared in the CRBasic program. If a variable has not been declared, the default is Integer. If the type is Float, the OID is advertised as a String and conversion takes place automatically (since SNMP does not natively support a type of Float).

    Access (Variable | Constant | Expression | Array | Integer | ConstantInteger): By default, an object is defined as read-only. RWRITE can be used in the Access parameter to set the object to read/write.

    Valid (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to define a valid range or set of values that can be written. RANGES is used to set a range of values; e.g., RANGES 0,65535 defines a range of values of 0 to 65535. VALUES 1,2,3,4,5 defines valid input as the numbers 1 2 3 4 and 5. If the Valid parameter is omitted, any value can be written.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SNMPVariable({Name},{OID},{Type},{Access},{Valid})"


def StaticRoute(
    ComPort: Literal[
        "ComRS232",
        "ComME",
        "Com310",
        "Com320",
        "ComSDC7",
        "ComSDC8",
        "ComSDC10",
        "ComSDC11",
        "ComC1",
        "ComC3",
        "ComC5",
        "ComC7",
    ],
    NeighborAddr: Integer,
    PakBusAddr: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/staticroute.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/staticroute.htm).

                The StaticRoute is used in instances where the datalogger does not have a known dynamic route to a remote PakBus node. An example might be where the datalogger is trying to route a PakBus packet through LoggerNet to a remote datalogger, but its only connection to the LoggerNet server is via a telephone modem. In this instance, LoggerNet would send a "good bye" message after each communication with the datalogger, thus, the known route to the remote datalogger would be reset (and unknown).
    StaticRoute is a declaration and does nothing at runtime. Multiple StaticRoutes to a device can be defined in a program.

    Args:
                    ComPort (Constant): The communications port that will be used by the instruction. Right-click to display a list. Options vary depending on the instruction. When communicating over TCP/IP, use the variable returned by the TCPOpen function for the ComPort.
      Must be one of following options: ComRS232 (RS232 port of the datalogger), ComME (Datalogger CS I/O port; modem enabled), Com310 (Datalogger CS I/O port; COM310 modem), Com320 (Datalogger CS I/O port, COM320 modem), ComSDC7 (Datalogger CS I/O port; SDC7), ComSDC8 (Datalogger CS I/O port; SDC8), ComSDC10 (Datalogger CS I/O port; SDC10), ComSDC11 (Datalogger CS I/O port; SDC11), ComC1 (Datalogger control terminals 1 & 2), ComC3 (Datalogger control terminals 3 & 4), ComC5 (Datalogger control terminals 5 & 6), ComC7 (Datalogger control terminals 7 & 8)

            NeighborAddr (Integer): Used to specify the PakBus address of the "neighbor" device that the datalogger can go through to communicate with the remote datalogger. NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.

            PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"StaticRoute({ComPort},{NeighborAddr},{PakBusAddr})"


def StdDev(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "String", "Boolean", "BOOL8", "Long", "NSEC", "UINT1", "UINT2", "UINT4"
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/stddev.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/stddev.htm).

              The following equation is used to calculate the StdDev:

    Args:
                  Reps (Constant): The number of repetitions for the measurement or instruction. For the StdDev instruction, the Reps are the number of variables for which to calculate a standard deviation. If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error is returned when the program is compiled.

          Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. Source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

          DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
    Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

          DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, RMSSpa, StdDev, StdDevSpa, and Totalize.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"StdDev({Reps},{Source},{DataType},{DisableVar})"


def StdDevSpa(Dest: Variable | Array, Swath: Constant, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/stddevspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/stddevspa.htm).

                The spatial standard deviation is calculated as:
    If a NAN is returned by the datalogger it is not included in the spatial standard deviation.
    Source and/or Dest can be a Float or Long data type, but not a String.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Swath (Constant): The number of values of the array over which to perform the specified operation.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, RMSSpa, StdDev, StdDevSpa, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"StdDevSpa({Dest},{Swath},{Source})"


def Sgn(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sgn.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sgn.htm).

                The SGN function returns an integer indicating the sign of a number.
    The Number argument can be any valid numeric expression. The sign of Number argument determines the value returned by the SGN function.
    If X > 0, then SGN( X ) = 1
    If X = 0, then SGN( X ) = 0

    Args:
                    number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Sgn({number})"


def Sin(
    angle: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sin.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sin.htm).

                The SIN function takes an angle and returns the ratio of two sides of a right triangle. The result lies in the range -1 to 1. The ratio is the length of the side opposite the angle divided by the length of the hypotenuse. The Angle argument can be any valid numeric expression measured in radians.
    AngleDegrees can be used to change the source for this function to degrees instead of radians.

    Args:
                    angle (Variable | Constant | Expression | Array | Integer | ConstantInteger): angle (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Sin({angle})"


def Sinh(
    Expr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sinh.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sinh.htm).

    Args:
        Expr (Variable | Constant | Expression | Array | Integer | ConstantInteger): Expr (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Sinh({Expr})"


def SDMSIO4(
    Dest: Variable | Array,
    Reps: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SIO4Mode: Literal["1", "2", "3", "4", "5"],
    SIO4Cmd: Literal[
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "66",
        "67",
        "320",
        "321",
        "1024",
        "1025",
        "1026",
        "1027",
        "2049",
        "2054",
        "2304",
        "2305",
    ],
    Param1: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Param2: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    ValuesPerRep: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmsio4.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmsio4.htm).

              NOTE: Unlike other SDM instructions, the SDMSIO4 instruction is called from the datalogger's processing task. Therefore, if a delay is required between SDMSIO4 instructions, use the Delay instruction's Option 1 for parameter 1.

    Args:
                  Dest (Variable | Array): The variable in which to store the results of the instruction when retrieving data from the SIO4. If data is being sent to the SIO4, then Dest becomes the source array for the data to be sent. The Dest array must be at least as large as the Reps parameter value multiplied by the ValuesPerRep parameter value.

          Reps (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the number of sequential SIO4s that will be called by the instruction. The datalogger will poll the SIO4 with the address set by the Address parameter first, receive or send the number of values set by the ValuesPerRep parameter next, and then poll the SIO4 with the next sequential address. If the Reps parameter is 2, the ValuesPerRep is 3, and the Command parameter is set to receive, then three values from the first SIO4 would be sent to the first three elements of the Dest array, and three values from the second SIO4 would be received and written to the fourth through sixth elements of the Dest array. Constant integer (or expression that evaluates as a constant).

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          SIO4Mode (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines which port the instruction will affect.
    Must be one of following options: 1 (Send/Receive Port 1), 2 (Send/Receive Port 2), 3 (Send/Receive Port 3), 4 (Send/Receive Port 4), 5 (Send to all Ports (global))

          SIO4Cmd (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to configure the SIO4. The commands are listed briefly below. See the SDM-SIO4 manual for details.
    Must be one of following options: 1 (Poll of available data), 2 (Get EPROM and memory signatures.), 3 (Flush all receive buffers.), 4 (Send data to datalogger.), 5 (Return number of watchdog errors, invalid command executed, and lithium battery voltage.), 6 (Flush transmit buffer.), 7 (Activate command line.), 8 (Poll TX buffers for data.), 9 (Flush converted data buffer.), 66 (Send single-byte data to datalogger.), 67 (Get return code), 320 (Send byte data to SDM-SIO4.), 321 (Execute command line command.), 1024 (Send string to SIO4.), 1025 (Transmit a byte.), 1026 (Serial port status.), 1027 (Manual handshake mode.), 2049 (Communication parameters.), 2054 (Set up receive filter.), 2304 (Transmit string and/or data to device (formatter/filter).), 2305 (Transmit bytes.)

          Param1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): The first parameter that should be passed to the SIO4 for the selected Command. Refer to the SDM-SIO4 manual for details.

          Param2 (Variable | Constant | Expression | Array | Integer | ConstantInteger): The second parameter that should be passed to the SIO4 for the selected Command. Refer to the SDM-SIO4 manual for details.

          ValuesPerRep (Variable | Constant | Expression | Array | Integer | ConstantInteger): The number of values to be sent or received from each SIO4 each time this instruction is performed.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SDMSIO4({Dest},{Reps},{SDMAddress},{SIO4Mode},{SIO4Cmd},{Param1},{Param2},{ValuesPerRep},{Mult},{Offset})"


def SDMIO16(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    IO16Status: Variable,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    IO16Cmd: Literal[
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
    ],
    Mode: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmio16.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sdmio16.htm).

              The ports on the SDM-IO16 can be configured for either input or output. When configured as input, the SDM-IO16 can measure the logical state of each port, count pulses, and measure the frequency of and determine the duty cycle of applied signals. The module can also be programmed to generate an interrupt signal to the datalogger when one or more input signals change state. When configured as an output, each port can be set to 0 or 5 V by the datalogger. In addition to being able to drive normal logic level inputs, when an output is set high a ‘boost’ circuit allows it to source a current of up to 100 mA, allowing direct control of low voltage valves, relays, etc.

    Args:
                  Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Dest parameter is a variable or variable array in which to store the results of the measurement (Command codes 1 - 69, 91, 92, 99) or the Source value for the Command Codes (70 - 85, 93 - 98). The variable array for this parameter must be dimensioned to accommodate the number of values returned (or sent) by the instruction.

          IO16Status (Variable): Holds the result of the command issued by the instruction. If the command is successful a 0 is returned; otherwise, the value is incremented by 1 with each failure.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          IO16Cmd (Constant): A code used to set up the SDM-IO16:
    Must be one of following options: 1 (Read port 1's accumulated counts into Dest), 2 (Read port 2's accumulated counts into Dest), 3 (Read port 3's accumulated counts into Dest), 4 (Read port 4's accumulated counts into Dest), 5 (Read port 5's accumulated counts into Dest), 6 (Read port 6's accumulated counts into Dest), 7 (Read port 7's accumulated counts into Dest), 8 (Read port 8's accumulated counts into Dest), 9 (Read port 9's accumulated counts into Dest), 10 (Read port 10's accumulated counts into Dest), 11 (Read port 11's accumulated counts into Dest), 12 (Read port 12's accumulated counts into Dest), 13 (Read port 13's accumulated counts into Dest), 14 (Read port 14's accumulated counts into Dest), 15 (Read port 15's accumulated counts into Dest), 16 (Read port 16's accumulated counts into Dest), 17 (Read ports 1-4's accumulated counts into Dest (Dest must be dimensioned to 4)), 18 (Read ports 5-8's accumulated counts into Dest (Dest must be dimensioned to 4)), 19 (Read ports 9-12's accumulated counts into Dest (Dest must be dimensioned to 4)), 20 (Read ports 13-16's accumulated counts into Dest (Dest must be dimensioned to 4)), 21 (Read ports 1-8's accumulated counts into Dest (Dest must be dimensioned to 8)), 22 (Read ports 9-16's accumulated counts into Dest (Dest must be dimensioned to 8)), 23 (Read ports 1-16's accumulated counts into Dest (Dest must be dimensioned to 16)), 24 (Read port 1's frequency into Dest), 25 (Read port 2's frequency into Dest), 26 (Read port 3's frequency into Dest), 27 (Read port 4's frequency into Dest), 28 (Read port 5's frequency into Dest), 29 (Read port 6's frequency into Dest), 30 (Read port 7's frequency into Dest), 31 (Read port 8's frequency into Dest), 32 (Read port 9's frequency into Dest), 33 (Read port 10's frequency into Dest), 34 (Read port 11's frequency into Dest), 35 (Read port 12's frequency into Dest), 36 (Read port 13's frequency into Dest), 37 (Read port 14's frequency into Dest), 38 (Read port 15's frequency into Dest), 39 (Read port 16's frequency into Dest), 40 (Read ports 1-4's frequency into Dest (Dest must be dimensioned to 4)), 41 (Read ports 5-8's frequency into Dest (Dest must be dimensioned to 4)), 42 (Read ports 9-12's frequency into Dest (Dest must be dimensioned to 4)), 43 (Read ports 13-16's frequency into Dest (Dest must be dimensioned to 4)), 44 (Read ports 1-8's frequency into Dest (Dest must be dimensioned to 8)), 45 (Read ports 9-16's frequency into Dest (Dest must be dimensioned to 8)), 46 (Read ports 1-16's frequency into Dest (Dest must be dimensioned to 16)), 47 (Read port 1's duty cycle into Dest), 48 (Read port 2's duty cycle into Dest), 49 (Read port 3's duty cycle into Dest), 50 (Read port 4's duty cycle into Dest), 51 (Read port 5's duty cycle into Dest), 52 (Read port 6's duty cycle into Dest), 53 (Read port 7's duty cycle into Dest), 54 (Read port 8's duty cycle into Dest), 55 (Read port 9's duty cycle into Dest), 56 (Read port 10's duty cycle into Dest), 57 (Read port 11's duty cycle into Dest), 58 (Read port 12's duty cycle into Dest), 59 (Read port 13's duty cycle into Dest), 60 (Read port 14's duty cycle into Dest), 61 (Read port 15's duty cycle into Dest), 62 (Read port 16's duty cycle into Dest), 63 (Read ports 1-4's duty cycle into Dest (Dest must be dimensioned to 4)), 64 (Read ports 5-8's duty cycle into Dest (Dest must be dimensioned to 4)), 65 (Read ports 9-12's duty cycle into Dest (Dest must be dimensioned to 4)), 66 (Read ports 13-16's duty cycle into Dest (Dest must be dimensioned to 4)), 67 (Read ports 1-8's duty cycle into Dest (Dest must be dimensioned to 8)), 68 (Read ports 9-16's duty cycle into Dest (Dest must be dimensioned to 8)), 69 (Read ports 1-16's duty cycle into Dest (Dest must be dimensioned to 16)), 70 (Set port 1's debounce time from Dest), 71 (Set port 2's debounce time from Dest), 72 (Set port 3's debounce time from Dest), 73 (Set port 4's debounce time from Dest), 74 (Set port 5's debounce time from Dest), 75 (Set port 6's debounce time from Dest), 76 (Set port 7's debounce time from Dest), 77 (Set port 8's debounce time from Dest), 78 (Set port 9's debounce time from Dest), 79 (Set port 10's debounce time from Dest), 80 (Set port 11's debounce time from Dest), 81 (Set port 12's debounce time from Dest), 82 (Set port 13's debounce time from Dest), 83 (Set port 14's debounce time from Dest), 84 (Set port 15's debounce time from Dest), 85 (Set port 16's debounce time from Dest), 86 (Set port 16-13 from Mode parameter), 87 (Set port 12-9 from Mode parameter), 88 (Set port 8-5 from Mode parameter), 89 (Set port 4-1 from Mode parameter), 90 (Set port 16-1 from Mode parameters), 91 (Read state of ports 1-16 into one variable (Dest). The result is a 16-bit decimal representation from 0-65535.), 92 (Read state of ports 1-16 into 16 separate variables (Dest must be dimensioned to 16). Dest(1) holds the state of port 1, Dest(2) port 2, etc. State is represented by 0 or 1.), 93 (Set state of ports 1-16 from a single variable (Dest). Dest should be a 16-bit decimal representation from 0-65535.), 94 (Set state of ports 1-16 from 16 separate variables (Dest must be dimensioned to 16). Dest(1) sets the state of port 1, Dest(2) port 2, etc. State is represented by 0 or 1.), 95 (Set direction of ports 1-16 from a single variable (Dest). Dest should be a 16-bit decimal representation from 0-65535.), 96 (Set direction of ports 1-16 from 16 separate variables (Dest must be dimensioned to 16). Dest(1) sets the direction of port 1, Dest(2) port 2, etc. Direction is represented by 0 or 1.), 97 (Set interrupt mask of ports 1-16 from a single variable (Dest). Dest should be a 16-bit decimal representation from 0-65535.), 98 (Set interrupt mask of ports 1-16 from 16 separate variables (Dest should be dimensioned to 16). Dest(1) sets port 1, Dest(2) port 2, etc. The mask is represented by 0 or 1.), 99 (Read the OS signature, OS version and counters for watchdog resets and communication errors into 4 separate variables (Dest must be dimensioned to 4). Using this command also resets the counters.)

          Mode (Constant): Used to configure a bank of four ports when a Command code 86 through 90 is used (if any other Command Code is used, enter 0 for the Mode parameters). Mode is entered as a four digit parameter, where each parameter indicates the setting for a port. Ports are represented from the highest port number to the lowest, from left to right (e.g., 16 15 14 13; 12 11 10 9; 8 7 6 5; 4 3 2 1). There is a Mode for Ports 16 - 13, 12 - 9, 8 - 5, and 4 - 1. The valid codes are:
    Must be one of following options: 0 (Output logic low), 1 (Output logic high), 2 (Input digital, no debounce filter), 3 (Input switch closure 3.17 msec debounce filter), 4 (Input digital interrupt enabled, no debounce filter), 5 (Input switch closure interrupt enabled 3.17 msec, debounce filter), 6 (Undefined), 7 (Undefined), 8 (Undefined), 9 (No change)

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SDMIO16({Dest},{IO16Status},{SDMAddress},{IO16Cmd},{Mode},{Mult},{Offset})"


def SplitStr(
    SplitResult: Variable | Array,
    SearchString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    FilterString: Variable,
    NumSplit: Constant,
    SplitOption: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8", "1x"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/splitstr.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/splitstr.htm).

                The splitting can be based on fixed delimiters (for example, commas) or semi-automatic (for example, reading numeric variables out of a string of mixed types as might be returned by a sensor). The FilterString and SplitOption help to define the array returned by the SplitStr instruction.

    Args:
                    SplitResult (Variable | Array): An array or structure in which the split string will be stored.

            SearchString (Variable | Constant | Expression | Array | Integer | ConstantInteger): The string to evaluate.

            FilterString (Variable): Provides a filter for the string(s) to be returned. For a FilterString using non-printable ASCII characters, use the CHR function and the appropriate ASCII code. For a full list of ASCII codes, see ASCII Codes and Characters.

            NumSplit (Constant): The maximum number of strings or values returned by the instruction.

            SplitOption (Variable | Constant | Expression | Array | Integer | ConstantInteger): A code specifying the method used to split the string. For option 5, if a null string exists between two filter strings, a null string will be returned. For option 7, any null strings will be ignored.  Add 100 to any of the non-numeric options above to parse a string that includes quotes, with the quotes being omitted in the result. String variables can be declared as only one or two dimensions; for example, String(x) or String(x,y). To begin reading or modifying a string at a particular location into the string, enter the location as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element. The Mid instruction can also be used to split strings. It may be useful in cases where SplitStr will not work.  NOTE: String functions are case sensitive. Uppercase or lowercase can be used to convert to all one case prior to processing the string if desired.
      Must be one of following options: 0 (NUMERIC – Numeric values are split out of the SearchString and stored into the array. Non-numeric characters are discarded. Delimiters are any characters but + - . 0 1 2 3 4 5 6 7 8 9 0 E). With this option, FilterString is ignored.), 1 (NON-NUMERIC – Non-numeric sub-strings (text strings) are split out of the SearchString and stored into the array. Numeric characters are discarded. Delimiters are . 0 1 2 3 4 5 6 7 8 9 0 E). With this option, FilterString is ignored.), 2 (SEARCHSTRING - SearchString is split and stored into the array based upon the occurrence of the entire FilterString.), 3 (SEARCHCHARS - SearchString is split and stored into the array based upon each occurrence of any character that is in FilterString.), 4 (HEADERFILTER - Any string succeeding FilterString is returned in SplitResult.), 5 (FOOTERFILTER -The number of values specified are parsed from the SearchString using the FilterString, or until the end of the SearchString is reached.), 6 (HEADERFILTERCHARS - Strings succeeding any character in the FilterString char list are returned in SplitResult. Redundant delimiters are treated as a single delimiter; for example, a string of “AA    BB    CC” with a Header Filter of “ “ (space) will be returned as “AA BB CC”. In addition, multiple delimiters can be specified; for example, “:;” will split a string based on the colon or semicolon.), 7 (FOOTERFILTERCHARS - Strings preceding any character in the FilterString char
    list are returned in SplitResult. Redundant delimiters are treated as a single
    delimiter. In addition, multiple delimiters can be specified; for example, “:;” will
    split a string based on the colon or semicolon.), 8 (NUMERICHEX - SearchString is split and stored in the array based upon the occurrence of hexadecimal numerics in the string (delimiters are any character but 0 1 2 3 4 5 6 7 8 9 0 A B C D E F). The hexadecimal value is stored in the array. With this option, FilterString is ignored.), 1x (Where X is one of the options above, right justify the resultant array, filling vacant elements with NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. (if numeric) or a NULL string if a string.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SplitStr({SplitResult},{SearchString},{FilterString},{NumSplit},{SplitOption})"


def Sprintf(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Format: Literal["+", "Space", "-", "#", "0"],
    *args: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sprintf.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sprintf.htm).

                The Sprintf function returns the length of the string written to the destination variable (Dest). Up to 10 arguments can be passed into the Format string, with format specifiers corresponding one-to-one with the arguments. The function requires an argument for each format specifier. Any arguments not paired with a format specifier are discarded.

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): Variable in which to store the formatted output string. Dest should be sized large enough to accommodate all of the characters written to the resulting string. No error is returned if Dest is sized too small.

            Format (Variable): A string used to define the format to be used for the arguments. Up to 10 format specifiers (with corresponding arguments) can be used in a format string. The format specifiers are: NOTE: If ‘L’ is specified before f, e, or g, then the value passed in is of type double and, therefore, the precision of double can be displayed. The maximum number of digits possible is 7 for floats (IEEE4, single precision) and 18 for doubles(IEEE8, double precision). Width and precision may be specified directly in the format string or may be passed in from one of the arguments. When specifying width and/or precision as an argument their place should be indicated by an asterisks (*). The following examples are equivalent and will return a floating point value with a field width of at least 3 characters and a precision of 2 characters. sprintf(dest,"%3.2f",67.89) sprintf(dest,"%*.2f",3,67.89) sprintf(dest,"%*.*f",3,2,67.89) Precision for f specifies the number of digits after the decimal point, whereas precision for g and e specifies the total number of digits displayed, including digits before and after the decimal point.   For example: sprintf(Str(6),"%.10Lf",112.000009R) prints 112.0000090000 sprintf(Str(8),"%.10Lg",112.000009R) prints 112.000009 Up to five Flags can be used immediately following the % sign:
      Must be one of following options: + (Always denote the sign of a number), Space (Prefixes a non-negative signed number with a space), - (Left-align the output of the placeholder (default is to right-align)), # (For g and G, trailing zeros are not removed. For f, e, g, or G, the output
    always contains a decimal point. For o, x, and X, prepend o, Ox, or OX to
    non-zero numbers), 0 (Use 0 spaces to pad a field when the width option is used)

            Argument1..Argument10 (Variable | Constant | Expression | Array | Integer | ConstantInteger): The arguments to pass into the format string. Up to 10 arguments can be entered. These arguments can be decimal values, integers, strings, variables, or expressions. The data type of these arguments must match the format specifier. Usage notes: Sprintf performs no data type conversions on the arguments passed into the format string. The format specifier must match the argument type or erroneous values are returned.  TableName.Timestamp by default is returned as an integer. To print a timestamp it must be placed inside an expression that forces it to be converted to a string.  Arguments from a data table that are stored as FP2 Two-byte floating-point data type. Default datalogger data type for stored data. While IEEE four-byte floating point is used for variables and internal calculations, FP2 is adequate for most stored data. FP2 provides three or four significant digits of resolution, and requires half the memory as IEEE4. are converted to floats before they are accessed. The precision for these values can be represented fairly closely by using %4.g, though if the mantissa is <1000 it is only 3 significant digits (i.e., %.3g).  For all options but y (or Y), infinity is output as INF A data word indicating the result of a function is infinite or undefined. and not a number NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.. A formatted value can be padded with zeros (or spaces), using the notation %#code (right justified) or %-#code (left justified), where # is the number of spaces for the field. Consider the following examples, where the Long variable is 12345. If FormatString = %8d the result is (space)(space)(space)12345 If FormatString = %-8d the result is 12345(space)(space)(space) If FormatString = %08d the result is 00012345 If FormatString = %-08d the result is 12345000

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Sprintf({Dest},{Format},{','.join(x for x in args)})"


def SolarPosition(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TimeArray: Variable,
    TimeOffset: Constant,
    Latitude: Constant,
    Longitude: Constant,
    Altitude: Constant,
    Pressure: Variable,
    AirTemp: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/solarposition.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/solarposition.htm).

                The SolarPosition instruction makes use of the Solpos algorithm developed by the National Renewable Energy Laboratory (NREL). The instruction has a minimum uncertainty of 0.01 degrees in both the zenith and azimuth angles. This level of accuracy is more than adequate for most engineering applications.
    The instruction returns five elements into the Destination (Dest) array:
    The output from SolarPosition can also be used to calculate the following parameters for the site:
    The HourAngle is a negative number in the morning before solar noon; it is positive in the afternoon after solar noon. HourAngle can be used to calculate Local Solar Noon as well as sunrise and sunset time for the location. The example program includes these calculations.

    Args:
                    Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger): The variable array in which the results of the instruction will be written. Dest must be dimensioned to 5 or a compilation error will occur. The following 5 values are returned:  Dest(1) = SolarAzimuth (degrees from North; N=0, E=90, S=180, W=270)Dest(2) = SunElevation (degrees above the horizon; 90 degrees corresponds to solar noon)Dest(3) = HourAngle (Radians West from solar noon). Converts local solar time into an angular displacement for the sun's movement across the sky.Dest(4) =Declination (Radians North or South). Angle between the equator and the location of the sun.Dest(5) = AirMass (air mass coefficient). Ratio of the path length of the current solar position to the path length at solar noon. Calculated via Kasten and Young’s method 1989. If a pressure measurement is possible, a correction will be applied and will refer to the airmass as an absolute airmass.  If pressure is not used, airmass may be referred to as a relative airmass.

            TimeArray (Variable): A variable array dimensioned to 9 that holds the following values:  (1) year, (2) month, (3) day of month, (4) hour of day, (5) minutes, (6) seconds, (7) microseconds, (8) day of week (1-7; Sunday = 1), and (9) day of year. These values can be derived from the RealTime instruction. If TimeArray is not dimensioned to 9, a compilation error will occur.

            TimeOffset (Constant): The local time offset, in seconds, from UTC. The TimeOffset parameter is ignored if the "UTC Offset" setting in the datalogger is a value other than -1 (disabled). In other words, the UTCOffset setting in the datalogger overrides this  instruction parameter.  The UTCOffset  setting can be found in the Settings table. For more information, see Settings Available Using SetSetting NOTE: For the GPS() instruction, in order to use GPS coordinates without setting the datalogger clock, set the TimeOffset parameter to -1.

            Latitude (Constant): A constant or variable that provides the latitude for the datalogger station. The range for Latitude is 0 to ±90 (positive value for Northern hemisphere and negative value for Southern hemisphere).

            Longitude (Constant): A constant or variable that provides the longitude for the datalogger station, expressed in decimal degrees east of the Greenwich meridian. For longitudes measured going west from the Greenwich meridian, a negative value can be entered or a corrected value (360 – WestDegrees) can be used. For example, Tokyo, Japan has a longitude of 220.3 when measured going west. This could be entered as -220.3, or the corrected longitude value of 139.7 degrees East could be used.

            Altitude (Constant): A constant or variable that provides the altitude above sea level for the datalogger station. This value must be in meters.

            Pressure (Variable): The  variable that holds the local annual average barometric pressure (not current measurement) in millibars, that will be used in calculating the solar position. If Pressure is defined as -1, AirTemp will be used to calculate an estimate of barometric pressure.

            AirTemp (Variable): The variable that holds a temperature measurement in degrees C that will be used in calcuating the solar position.  NANs may occur in the output array for Zenith angles if a temperature measurement is not used. If temperature is unavailable, consider using the datalogger's panel temperature (though this may affect accuracy of the instruction).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SolarPosition({Dest},{TimeArray},{TimeOffset},{Latitude},{Longitude},{Altitude},{Pressure},{AirTemp})"


def SortSpa(
    Dest: Variable, Swath: Constant, Source: Variable, Dimension: Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sortspa.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sortspa.htm).

        The results from SortSpa can be stored in the same variable or a different variable. If the results are stored in a different variable, the array is copied from Source and stored into Dest prior to sorting. If the Source and Dest variables are the same, then the sorting is done in place. NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.s and ±INF A data word indicating the result of a function is infinite or undefined.s are sorted to the top of the array (that is, the most minimum value).

    Args:
            Dest (Variable): A variable in which to store the results of the function. Dest must be dimensioned to the size of the swath.

    Swath (Constant): The number of elements in the array to include in the values to be sorted.

    Source (Variable): The first variable in the array for which the sort should be performed. When using the optional dimension parameter with a two- or three-dimensional array, Source also determines the row, column, or plane to sort on. For example, in a two-dimensional array Source(1,2) will sort on the second column of the array, keeping the rows intact. For example: Public Result (3,2), Source(3,2) SortSpa (Result(1,1),3,Source(1,2),2) 'sort 3 rows of 2-D array by 2nd column For a three-dimensional array, the example below demonstrates sorting the planes of the array and then using a For/Next loop to sort the rows of each plane: Public Result(5,4,3), Source(5,4,3) SortSpa(Result(1,1,1),5,Source(1,1,1),3) 'sort the planes Dim I For i = 1 To 5  SortSpa (Result6(i,1,1),4,Result5(i,1,1),2) 'sort the rows of each plane Next i

    Dimension (Constant): An optional parameter that is used to specify the dimension to perform the sort on, in a multi-dimensional array. Valid options are: 1: Sort on the first dimension of the array (for example, sort on X in Array (X,Y)). This is the default behavior if Dimension is not specified.2: Sort on the second dimension of the array (for example, sort on Y in Array(X,Y)).3: Sort on the third dimension of the array (for example, sort on Z in Array(X,Y,Z)).

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"SortSpa({Dest},{Swath},{Source},{Dimension})"


def Sqr(
    number: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sqr.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sqr.htm).

    Args:
        number (Variable | Constant | Expression | Array | Integer | ConstantInteger): number (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Sqr({number})"


def StrainCalc(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    BrZero: Variable,
    BrConfig: Literal["1", "2", "3", "4", "5", "6"],
    GageFactor: Variable,
    PoissonFactor: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/straincalc.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/straincalc.htm).

                The StrainCalc function calculates microstrain (με) using the appropriate formulae for the bridge configuration.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. If the Reps parameter is greater than 1, the Dest, Source, and BrZero parameters also must be variable arrays.  NOTE: If starting index is greater than 1 and Reps are greater than 1, use the syntax SourceArray(X)() to indicate the first array element to be used for the mVPerVolt, BrZero and GageFactor source arrays (where X is the starting index of the array, for example mVPerVolt(1)()). The empty set of parenthesis is the mechanism to automatically increment the source array index with each rep.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the StrainCalc instruction, the Source parameter is the variable array containing the mV/Volt output(s) from the bridge measurement(s) that should be converted to microstrain. The Source is expected to be in millivolts out per volts in (the result of a full bridge measurement with a multiplier of 1 and an offset of 0).

            BrZero (Variable): The variable array that holds the  zero strain value (millivolts per volt) for the instruction. This value will be subtracted from subsequent strain readings so that the strain output values will be relative to the zero condition.

            BrConfig (Constant): Used to determine which equation should be used for the strain calculation. A positive or negative code can be entered. A negative code reverses the output polarity. Right-click the parameter to display a list. 1Where n : Poisson's Ratio (0 if not applicable).GF: Gage Factor.Vr: 0.001 (Source-Zero) if BRConfig code is positive (+).Vr: –0.001 (Source-Zero) if BRConfig code is negative (–). and where: "source": the result of the full-bridge measurement (X = 1000 • V1 / Vx) when multiplier = 1 and offset = 0."zero": gage offset to establish an arbitrary zero.
      Must be one of following options: 1 (Quarter-bridge strain gage1:






    CASE 1 - If a Campbell Scientific 4WFBXXX Terminal Input Module is utilized, the bridge set up is as depicted in Case 1. For this set up, a negative Option (-1) should be used for the datalogger to output positive strain values when the strain gage experiences positive strain.
    CASE 2 - If the excitation voltage polarity is reversed, or the output polarity
    is reversed, or if the bridge is configured as shown in Case 2, then a positive Code (1) should be used for the datalogger to output positive strain values when the strain gage experiences positive strain.), 2 (Half-bridge strain gage1. One gage parallel to strain, the other at 90° to strain:), 3 (Half-bridge strain gage. One gage parallel to +ɛ, the other parallel to -ɛ1:






    If a Campbell Scientific 4WFBXXX Terminal Input Module is utilized with the G2 gage wired to positive excitation and the G1 gage wired to ground, then the bridge set-up is as depicted above. For this set up, a negative Option (-2) should be used for the datalogger to output positive strain values when the G1 strain gage experiences positive strain.
    If the excitation voltage polarity is reversed, or the output polarity is reversed, or if the output data needs to be positive when the G2 strain gage sees positive strain, then a positive 2 should be inserted into the Code parameter.), 4 (Full-bridge strain gage. Two gages parallel to +ɛ, the other two parallel to -ɛ1:), 5 (Full-bridge strain gage. Half the bridge has two gages parallel to +ɛ  and -ɛ, and the other half to +nɛ and -nɛ  1:), 6 (Full-bridge strain gage. Half the bridge has two gages parallel to +ɛ  and -nɛ , and the other half to -nɛ and +ɛ1:






    This example assumes that the bridge (shown above) is set up such that the strain is considered to be positive when the G1 and G4 strain gauges experience positive strain (tension) while the G2 and G3 strain gauges experience negative strain (compression). In other words, when G1 and G4 increase in resistance (while G2 and G3 decrease in resistance), the strain is considered to be positive. The default setting for the output was configured for this bridge setup, and the datalogger's output strain data will be positive when the G1 and G4 strain gauges experiences positive strain.
    If the excitation voltage polarity is reversed, the output polarity is reversed, or if the output data needs to be positive when the G2 and G3 strain gauges experience positive strain, then Reverse should be clicked on.)

            GageFactor (Variable): The name of the Variable that is the gage factor for the instruction. The GageFactor can be entered as a constant that will be used for all repetitions or as a variable array that is loaded with the individual gage factors for each Rep. To use an array, enter the parameter as ArrayName() without an element number specified in the parentheses.

            PoissonFactor (Variable): The name of the Variable that is the Poisson factor for the instruction. When using Codes 2, 5, or 6, enter the Poisson Ratio of the strained material. Enter 0 if the PoissonRatio (ⱱ) does not apply to the configuration.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"StrainCalc({Dest},{Reps},{Source},{BrZero},{BrConfig},{GageFactor},{PoissonFactor})"


def StrComp(
    String1: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    String2: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/strcomp.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/strcomp.htm).

                The StrComp instruction is typically used to determine the sorting order of two strings. StrComp can also be used to simply determine if the strings are identical, but that task is more commonly accomplished with the logical expression of “If String1 = String2 Then / EndIf”.
    Starting with the first character in each string, the characters in String2 are subtracted from the characters in String1 until the difference is non-zero or until the end of String2 is reached. The result of this instruction is an integer in the range of -255 to +255. If 0 is returned, the strings are identical. StrComp is case sensitive.
    String variables can be declared as only one or two dimensions; for example, String(x) or String(x,y). To begin reading or modifying a string at a particular location into the string, enter the location as a third dimension; for example, String(x,y,n) where n is the desired character. For example, given an array of strings Str(10,10), Str(2,2,n) refers to n character in the (2,2) element of the array. Use Str(1,1,n) for a scalar variable and Str(x,1,n) for a one dimensional array element.

    Args:
                    String1 (Variable | Constant | Expression | Array | Integer | ConstantInteger): String1 (No description provided)

            String2 (Variable | Constant | Expression | Array | Integer | ConstantInteger): String2 (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"StrComp({String1},{String2})"


def SW12(
    SW12Chan: Literal["SW12_1", "SW12_2", "SW12_CSIO"],
    State: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Option: Literal["Omitted", "0", "1"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sw12.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/sw12.htm).

              The datalogger has two switched 12 volt outputs. These ports are used to provide a 12 volt supply to external peripherals under program control. At room temperature the switched 12 volt supply can source 900 mA between the SW12 terminal and Ground.

    Args:
                  SW12Chan (Variable | Constant | Expression | Array | Integer | ConstantInteger): The SW12Chan parameter indicates which SW12 port to set. Valid ports are:
    Must be one of following options: SW12_1 (Switched 12 V port 1 (SW12-1)), SW12_2 (Switched 12 V port 2 (SW12-2)), SW12_CSIO (CSIO - CR1000Xe Only)

          State (Variable | Constant | Expression | Array | Integer | ConstantInteger): The State parameter indicates whether the switched 12 volts is High (non-zero) or low (0).

          Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter that determines whether the instruction will run in the measurement task sequence or the processing task sequence; also affects whether the program will compile and run in SequentialMode or PipelineMode: *other programming may force the program into SequentialMode Running the SW12 instruction in the processing task when the program is run in Pipeline mode can prove to be problematic if you are using the SW12 control to power a sensor. Because processing tasks can lag behind measurement tasks in PipelineMode, the SW12 instruction may be processed by the datalogger after the measurement has already been made. To avoid this scenario, program the datalogger to operate in SequentialMode. NOTE: The SW12 supply is unregulated and can supply up to 1.10 A at 20 degrees C, 640 mA at 70 degrees C, and 500 mA at 85 degrees C. A resettable polymeric fuse protects against over-current. Reset is accomplished by removing the load or turning off the SW12 for several seconds.
    Must be one of following options: Omitted (Instruction is run within the measurement task sequence; program will compile in SequentialMode), 0 (Instruction is run within the measurement task sequence; program will attempt to compile in PipelineMode*), 1 (Instruction is run within the processing task sequence; program will attempt to compile in PipelineMode*)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"SW12({SW12Chan},{State},{Option})"


def TCSe(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    TCType: Literal[
        "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    TRef: Variable | Expression | Array,
    MeasOff: Literal["0", "1"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcse.htm).

                The calculations used for the TCSE instruction are based on the thermocouple type selected (TCType). The instruction adds the measured voltage to the voltage calculated for the reference temperature relative to 0 degrees Celsius, and converts the combined voltage to temperature in degrees Celsius.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the TCSE instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. CR1000X burst measurement sampling rate is determined by the fN1 (first notch frequency) parameter (see following information on fN1).

            TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric code is entered. Right-click on the parameter to display a list of valid options. NOTE: When using TEMP408 modules, the TCType selected must match the module type.
      Must be one of following options: TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

            TRef (Variable | Expression | Array): The name of the variable that is the source of the reference temperature (or the result of the reference temperature measurement), in degrees C, for the thermocouple measurements. Right-click the parameter to display a list of defined variables.  Note that for accurate thermocouple measurements, an external reference temperature is recommended, rather than a PanelTemp measurement. See PanelTemp for additional information.

            MeasOff (Constant): Determines whether the ground offset voltage is measured before the measurement is made on the analog channel. If the ground offset is measured it is subtracted from the sensor measurement and the result is stored in Dest.
      Must be one of following options: 0 (Offset voltage is corrected from background calibration.), 1 (Offset voltage is measured each scan  (this option
    effectively increases the measurement time as if an additional rep were added to
    the instruction).)

            Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
      Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TCSe({Dest},{Reps},{Range},{SEChan},{TCType},{TRef},{MeasOff},{SettlingTime},{fN1},{Mult},{Offset})"


def TCDiff(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Literal["1", "2", "3", "4", "5", "6", "7", "8"],
    TCType: Literal[
        "TypeT", "TypeE", "TypeK", "TypeJ", "TypeB", "TypeR", "TypeS", "TypeN"
    ],
    TRef: Variable | Expression | Array,
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcdiff.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcdiff.htm).

              The calculations used for the TCDiff instruction are based on the thermocouple type selected (TCType). The instruction adds the measured voltage to the voltage calculated for the reference temperature relative to 0 degrees Celsius, and converts the combined voltage to temperature in degrees Celsius.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the TCDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          DiffChan (Constant): Specifies the differential channel on which to make the first measurement. If the Reps parameter is greater than 1, additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible. The CR1000X burst measurement sampling rate is determined by the fN1 (first notch frequency) parameter (described in following section on fN1).
    Must be one of following options: 1 (Differential Channel 1 (SE 1 and 2)), 2 (Differential Channel 2 (SE 3 and 4)), 3 (Differential Channel 3 (SE 5 and 6)), 4 (Differential Channel 4 (SE 7 and 8)), 5 (Differential Channel 5 (SE 9 and 10)), 6 (Differential Channel 6 (SE 11 and 12)), 7 (Differential Channel 7 (SE 13 and 14)), 8 (Differential Channel 8 (SE 15 and 16))

          TCType (Constant): The TCType argument is used to identify the type of thermocouple being measured. An alphanumeric code is entered. Right-click on the parameter to display a list of valid options. NOTE: When using TEMP408 modules, the TCType selected must match the module type.
    Must be one of following options: TypeT (Copper Contstantan), TypeE (Chromel Constantan), TypeK (Chromel Alumel), TypeJ (Iron Constantan), TypeB (Platinum Rhodium), TypeR (Platinum Rhodium), TypeS (Platinum Rhodium), TypeN (Nicrosil-Nisil)

          TRef (Variable | Expression | Array): The name of the variable that is the source of the reference temperature (or the result of the reference temperature measurement), in degrees C, for the thermocouple measurements. Right-click the parameter to display a list of defined variables.

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TCDiff({Dest},{Reps},{Range},{DiffChan},{TCType},{TRef},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def TCPClose(
    TCPSocket: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpclose.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpclose.htm).

                TCPSocket is the variable returned by the TCPOpen function.
    If TCPSocket is negated, TCPClose does not close the socket but instead allows PakBus communication to occur on the socket. This feature allows a socket to be opened first for Serial I/O, perhaps to "log in", and then converts the socket so that it can communicate via PakBus. (Note that if TCPSocket is opened by TCPOpen where IPBuffer is non-zero, the socket is opened for Serial I/O only and not for PakBus.)
    TCPClose returns 0 if there is no IP interface (Ethernet or PPP).
    If a positive TCPSocket is used, this function waits until the socket is closed and should always return 0. (It can take up to 200 msec to close the socket.)
    If a negative TCPSocket is used, this function returns:

    Args:
                    TCPSocket (Variable | Constant | Expression | Array | Integer | ConstantInteger): TCPSocket (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TCPClose({TCPSocket})"


def TCPOpen(
    IPAddr: Variable,
    TCPPort: Variable | Constant,
    IPBuffer: Constant,
    IPTimeOut: Constant | Integer | None = None,
    ConnectHandle: Variable | None = None,
    MaxConnect: Constant | Integer | None = None,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpopen.htm).

                TCPOpen is used to initiate a TCP client socket connection or set up a listening TCP server. Common uses of TCPOpen include:
    When the datalogger acts as a TCP client, it will initiate a socket connection to the destination address and port number when TCPOpen is executed. If the specified connection already exists, TCPOpen will quickly return; it will not close the existing good connection and then reopen it. However, TCPOpen will not return a result until the connection is successful or until a timeout period has expired, potentially delaying the scan unpredictably. Placing it in a slow sequence will allow TCPOpen to run in the background and not hold up the main program while it waits for the socket to be opened successfully. If using a TCP socket for non-PakBus communications (for example, as an extended serial port) the datalogger will be unable to ensure the connection is functional as it does not know the frequency or nature of the expected data. If possible, your program should either monitor for unexpected inactivity (no data received) and then close and reopen the socket, or simply close and reopen the socket at regular intervals.
    When the datalogger acts as a TCP server (i.e., when IPAddr = “”), it will begin listening for incoming connections on the specified port after the first time TCPOpen is executed. Each time TCPOpen is called, it will return either 0 (no connection yet) or a connection handle if the datalogger has accepted a connection from a remote client. By default TCPOpen only allows a single active socket connection per listening port. To allow multiple concurrent connections, use the optional MaxConnect parameter. The connection handles from multiple connections are returned in the ConnectHandle variable (which, therefore, should be an array if multiple connections are expected). A new connection is stored in a vacant element in the array. The TCPOpen function will continue to return a connection handle as long as the connection remains open. If the connection is closed for any reason, the datalogger will immediately start listening again for a new connection, and until a new connection has been accepted, the function will again return 0.
    If you have set up the datalogger to listen for an incoming TCP/IP connection, the TCPPort parameter should be different than the PakBus/TCP Service Port setting in the datalogger (6785 by default), since the datalogger is already listening on that port for PakBus packets.
    A datalogger will maintain only one direct neighbor route to another PakBus address. Thus, intermittent communication can be caused if the datalogger program has two TCPOpen instructions to the same PakBus device or if two PakBus devices use TCPOpen to maintain a connection to each other. The established route to the PakBus device is dropped in order to set up the new route, causing communication failures.
    When the function is executed, TCPOpen will return a non-zero integer value if a socket connection is successfully established. This value represents the datalogger resource handle used to reference the connection and can be treated like an extended ComPort. The non-zero value returned will start at 101 and will increment by 1 each time a new connection is created. If the socket fails to be created or is closed, a 0 is returned. If an established route is terminated unexpectedly and then restablished, the value of the returned integer is incremented by 1. The result variable can be used for determining if a connection has successfully been established or not. Additionally, it can often be used to specify the communications port (ComPort) in another function, such as SerialOut() or ModbusClient().

    Args:
                    IPAddr (Variable): The IP address for the socket you are trying to open. This is a string variable, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255), or an IPv6 address, or a fully-qualified domain name (for example, "computer-name.domain.com"). Numeric IPv4 addresses should be entered in decimal notation, with no leading zeros (i.e., 192.168.1.123, not 192.168.001.123). If you use a domain name, the address of a DNS Domain name server. A TCP/IP application protocol. server must be specified in datalogger settings. For all instructions except UDPOpen and IPRoute, the IPAddr can also be set to a null string (""), in which case the datalogger will listen for an incoming TCP/IP connection on the specified port. The entry for the IPAddr must be enclosed in quotes.

            TCPPort (Variable | Constant): An integer value ranging from 1 to 65535 and may be specified as a constant or variable. When acting as a TCP client, this parameter specifies the destination port the datalogger will connect to on the remote device. When acting as a server, this parameter specifies the port the datalogger will listen on for incoming TCP connections. When acting as a server, care should be taken to not use a port number already in use by other datalogger services such as FTP (20/21), Telnet (23), HTTP (80), NTP (123), SNMP (161), HTTPS (443), Modbus (502), PakBus (6785), or DNP3 (20000).Caution: If you have set up the datalogger to listen for an incoming TCP/IP connection, the TCPPort parameter should be different than the TCPort setting in the datalogger (6785 by default), since the datalogger is already listening on that port.

            IPBuffer (Constant): If the socket is being opened for communication with a serial (non-PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc.) device, enter a value for the size of the input serial buffer that should be created in datalogger memory. Set this parameter to 0 for communication with a PakBus device. When this parameter is set to 0, the port will be opened as a PakBus port and PakBus beaconing will take place every 3 minutes. For serial communications with non-PakBus devices, specify a buffer size large enough to hold the number of bytes that will arrive between serial input reads. Note that oversizing the buffer needlessly takes away from datalogger memory. For non-PakBus communication, do not set this parameter to 0 or PakBus beacons initiated by the datalogger may interfere with communications. For non-PakBus communication that does require a user-specified buffer (such as when used with ModbusClient(), set this parameter to 1 so that beaconing does not occur.

            IPTimeOut (Constant | Integer): When acting as a TCP client, the IPTimeOut parameter specifies the amount of time the datalogger will spend attempting to initiate the socket connection before failing. The value is entered in centiseconds (i.e., 0.01 seconds). If omitted, the timeout default is 75 seconds (7500). When acting as a TCP server, this parameter specifies the maximum amount of time allowed to elapse without active communications once a connection is accepted. If the timeout expires, the datalogger will close the connection. If omitted, a timeout will not be used and the datalogger will not close the connection due to lack of communications.

            ConnectHandle (Variable): ConnectHandle is a variable or array to which resource handles associated with the socket connection(s) will be stored. The argument should be declared as a variable or array of type LONG. This parameter must be used if a single TCPOpen instruction is to be used in a loop structure (typically) for the purpose of opening or serving multiple concurrent connections; the alternative would be to use multiple independent TCPOpen instructions within the program. This feature makes it easier to loop through an array of IPAddr and TCPPort combinations for the purpose of initiating multiple TCP client connections. When used for listening (IPAddr = “”), it allows for MaxConnect clients to connect to a single TCPPort number. Unlike the value returned by TCPOpen, the ConnectHandle argument is updated in the background, asynchronous to the execution of TCPOpen. If the connection is closed for any reason, its corresponding ConnectHandle will immediately be set to a value of 0.

            MaxConnect (Constant | Integer): The maximum number of connections that can be created with a single instance of the TCPOpen function. MaxConnect must be a constant integer with a value of 1 or greater. Set this value to the size of the ConnectHandle array, or 1 if ConnectHandle is a single variable. Optional parameters can be omitted in the program without consequence if they are not needed.  NOTE: The datalogger has a PakBus/TCP Client Connection setting, which can be used instead of the TCPOpen function, to specify up to four outgoing TCP/IP connections that the datalogger should attempt to maintain. In this instance, any PakBus instructions in the datalogger program should use a COMPort parameter of 0 and an invalid NeighborAddr (for example, -1 or 4099).

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TCPOpen({IPAddr},{TCPPort},{IPBuffer},{IPTimeOut},{ConnectHandle},{MaxConnect})"


def TGA(
    Dest: Variable | Array,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    DataList: Literal["0", "1", "2", "3", "4", "5", "6", "7", "8"],
    ScanMode: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tga.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tga.htm).

    Args:
                  Dest (Variable | Array): The array in which to store the results of the measurement. The length of the input variable array depends on the values of parameters DataList and ScanMode.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          DataList (Constant): Specifies the data to be retrieved from the sensor. If DataList = 1, only concentration and status are returned. If DataList = 2, then laser temperature, pressure, and DC Current are returned in addition to concentration and status. If DataList = 3, then the TGA analog signal 1 and TGA temperatures are also returned. If DataList = 4, then all data except DutyCycle1 and DutyCycle2 are returned. If DataList = 5, then all data are returned. See the list below for complete information: Status Flags - The TGAStatus value gives an indication of the overall status of the TGA. A value of zero indicates a normal condition. A nonzero value indicates one or more of the bits are set. The meaning of each of the bits is given below.
    Must be one of following options: 0 (1), 1 (2), 2 (4), 3 (8), 4 (16), 5 (32), 6 (64), 7 (128), 8 (256)

          ScanMode (Constant): Specifies the number of values to be retrieved for scan-specific data. Normally the ScanMode parameter corresponds to the TGA100A "number of ramps" parameter that specifies how many absorption lines are being measured. If ScanMode is set to a lower number than the TGA100A "number of ramps" parameter, the data for ramp B and/or C will not be retrieved from the TGA100A. If ScanMode is set to a higher number than the TGA100A "number of ramps" parameter, the TGA100A will return zero for the ramp B and/or C values.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TGA({Dest},{SDMAddress},{DataList},{ScanMode})"


def Therm109(
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the these instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels.

          ExChan (Constant): Enter the excitation channel number to excite first measurement. If multiple thermistors are measured with one instruction, all repetitions will use the same excitation channel. An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (1), VX2 (2), VX3 (3), VX4 (2)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Therm109({Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def Therm108(
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the these instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels.

          ExChan (Constant): Enter the excitation channel number to excite first measurement. If multiple thermistors are measured with one instruction, all repetitions will use the same excitation channel. An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (1), VX2 (2), VX3 (3), VX4 (2)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Therm108({Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def Therm107(
    Dest: Variable | Array,
    Reps: Constant,
    SEChan: Constant,
    ExChan: Literal["VX1", "VX2", "VX3", "VX4"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/therm107therm108therm109.htm).

              This instruction makes a half bridge voltage measurement and processes the results using the Steinhart-Hart calculation. The output is temperature in degrees C.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the these instructions, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels.

          ExChan (Constant): Enter the excitation channel number to excite first measurement. If multiple thermistors are measured with one instruction, all repetitions will use the same excitation channel. An alphanumeric code is entered. Right-click within the parameter to display a list.
    Must be one of following options: VX1 (1), VX2 (2), VX3 (3), VX4 (2)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Therm107({Dest},{Reps},{SEChan},{ExChan},{SettlingTime},{fN1},{Mult},{Offset})"


def TimedControl(
    TCSize: Constant,
    TCSyncInterval: Variable | Constant,
    TCIntervalUnits: Constant,
    TCDefaultValue: Variable | Constant,
    TCCurrentIndex: Variable,
    TCSource: Variable | Array,
    TCClockOption: Literal["1", "2", "3"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timedcontrol.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timedcontrol.htm).

                As currently implemented, the TimedControl instruction allows a series of SDM-CD16AC settings controling valves, to be defined so that the switching sequence occurs at precise times, even if processing is lagging behind measurements. This is accomplished by running the instruction in the SDM task sequencer rather than in the processing task sequencer, thus assigning the task a higher priority of execution in the datalogger.
    The TimedControl instruction must be placed before BeginProg to declare the use of the timed control. If it is necessary to change the sequence while the program is running, additional TimedControl instructions can be placed within the program.

    Args:
                    TCSize (Constant): Defines the number of values in the sequence.

            TCSyncInterval (Variable | Constant): The interval on which to run the TimedControl sequence. When the program is compiled and starts running or when TimedControl is reset, the program will wait until an even multiple of the SyncInterval to start the sequence. Enter 0 to start immediately. The ClockOption parameter determines whether the SyncInterval will be restarted or remain unchanged when the datalogger's clock is changed or the instruction is reset.

            TCIntervalUnits (Constant): The unit of measure to use for the SyncInterval. Valid options are microseconds, milliseconds, seconds, minutes, hours, or days.

            TCDefaultValue (Variable | Constant): A binary value sent to the SDMCD16 prior to the beginning of the TimedControl sequence or when ClockOption 1 is selected and the clock is reset.

            TCCurrentIndex (Variable): A variable that holds the array index that indicates which control sequence is being executed for the TimedControl instruction. The CurrentIndex is set to 0 when TimedControl is reset or is resyncing.

            TCSource (Variable | Array): A two-dimensional array that holds a binary value to be sent to the SDMCD16 to determine the port to be set and the duration (number of scans) the value should be used. For Array(x,y), x is the binary value determining the port and y is the number of scans. X should be dimensioned to at least the size of the Size parameter.

            TCClockOption (Constant): The ClockOption parameter behaves somewhat differently depending upon whether the TimedControl instruction is placed outside of the program scan or within the program scan. When the TimedControl instruction occurs prior to BeginProg, this option is used to set how the instruction will behave when the datalogger's clock is reset. When the TimedControl instruction is used within the program to reset or change the sequence, this option is used to set what happens between the time the instruction is executed and the SyncInterval occurs. Only option codes 1 and 2 are valid for this latter case. Right-click the parameter to display a list box of options.
      Must be one of following options: 1 (The instruction behaves as if it were just started after compile, and the value sent to the SDMCD16 is the DefaultValue.), 2 (The sequence continues running as if nothing happened until the next occurrence of the SyncInterval, at which time it restarts.), 3 (The change in the clock is ignored, and the TimedControl instruction proceeds with the CurrentIndex and duration as if nothing has happened.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TimedControl({TCSize},{TCSyncInterval},{TCIntervalUnits},{TCDefaultValue},{TCCurrentIndex},{TCSource},{TCClockOption})"


def TimeIsBetween(
    BeginTime: Variable | Constant,
    EndTime: Variable | Constant,
    Interval: Variable | Constant,
    Units: Literal["usec", "msec", "sec", "min", "hr", "day"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeisbetween.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timeisbetween.htm).

              The TimeIsBetween function returns True (-1) if the datalogger's real-time clock falls within the specified range; otherwise, the function returns False (0). TimeIsBetween can be used to control a process or task within the program (for instance, to control power to a device).

    Args:
                  BeginTime (Variable | Constant): Enter the start of the time range to be used for the function. BeginTime is included in the range of time that will return True.

          EndTime (Variable | Constant): Enter the end of the time range to be used for the function. EndTime is not included in the range of time that will return True.

          Interval (Variable | Constant): The Interval parameter is used to define how frequently the TimeIsBetween statement will evaluate as True, based on the datalogger's real-time clock. This parameter must be an integer. If a variable is used in this parameter, it is recommended to define it as a Long. Use of non-integers may result in the interval not evaluating as True when expected.

          Units (Constant): Defines the unit of time to be used for the BeginTime, EndTime, and Interval. Right-click the parameter to display a list. NOTE: When days are used, the first interval starts on a Monday. For example, TimeIsBetween(0,5,7,day) would perform a function every Monday through Friday.
    Must be one of following options: usec (microseconds), msec (milliseconds), sec (seconds), min (minutes), hr (hours), day (days)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TimeIsBetween({BeginTime},{EndTime},{Interval},{Units})"


def Timer(
    TimerNo: Variable | Integer,
    TUnits: Literal["0", "1", "2", "3", "4"],
    TimeOpt: Literal["0", "1", "2", "3", "4"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timer.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timer.htm).

              A typical use of the Timer is to set a variable equal to the Timer instruction (i.e., Variable=Timer(1, sec, 2). The Timer value is then stored in the defined variable. Multiple Timers can be defined in the program; each must have a unique TimerNo argument.

    Args:
                  TimerNo (Variable | Integer): A number assigned to the timer (for example, 0, 1, 2, …). Memory is allocated for timers based on the value entered + 1 (for example, using a TimerNo of 100 will allocate memory for 101 timers even if there is only one Timer in the program). Use a low number to conserve memory.  If this value is a variable, memory for 17 (0 - 16) timers is allocated. If more than 17 timers are needed, and TimerNo also needs to be a variable, use a "dummy" Timer instruction, which does not execute at run-time, with a TimerNo of the maximum number of timers needed in the program.

          TUnits (Constant): The TUnits argument is the time unit in which to report the Timer. A numeric or alphabetical code can be entered. Note, when using microseconds:  The datalogger does not go into quiescent mode. This increases the power consumption of the datalogger. If a microsecond timer is needed within the program, stop the timer after its use to allow the datalogger to go into quiescent mode when it is not actively running its program. The datalogger uses a 32-bit counter, so the maximum amount of elapsed time that can be tracked when using microseconds is 2147 seconds or approximately 35 minutes. Furthermore, the results are stored as a float that has 24-bits of resolution, so precision will be lost after 8 seconds.
    Must be one of following options: 0 (usec), 1 (msec), 2 (sec), 3 (min), 4 (hr)

          TimeOpt (Constant): The action on the Timer. The timer instruction returns the value of the timer after the action is performed. A numeric code is entered. Right-click the parameter to display a list.
    Must be one of following options: 0 (Start), 1 (Stop), 2 (Reset and start), 3 (Stop and reset), 4 (Read only)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Timer({TimerNo},{TUnits},{TimeOpt})"


def Totalize(
    Reps: Constant,
    Source: Variable,
    DataType: Literal[
        "IEEE4",
        "FP2",
        "IEEE8",
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
    ],
    DisableVar: Variable | Constant | Expression,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/totalize.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/totalize.htm).

                If the DisableVar is true for the entire output interval, 0 is stored. If a NAN is included in the values being processed, NAN is stored. Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 is -7999, so NAN for FP2 data will appear in a data table as -7999.  If the data type is Long, NAN will appear in the data table as -2147483648.
    Call the output table conditionally (for example, do not call the table if a variable = NAN) to keep NANs from affecting the other good values.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. If the Reps parameter is greater than 1, an array must be specified for Source. If not, a Variable Out of Bounds error will be returned when the program is compiled.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the Totalize instruction, source may also be an expression. The resulting fieldname is AnonymousN, where N is an incrementing number assigned to each output value entered as an expression. The FieldNames instruction can then be used to change AnonymousN to a more appropriate fieldname; for example, Sample (1,PTemp*1.8+32,FP2) FieldNames("PTempDegFSample:Sample Panel Temp in degrees F")

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions. For Average, Covariance, Maximum, Minimum, Moment, StdDev, Totalize - if DisableVar is an array and Reps are greater than 1, a different DisableVar can be used for each rep. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, RMSSpa, StdDev, StdDevSpa, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Totalize({Reps},{Source},{DataType},{DisableVar})"


def TableFile(
    FileName: Constant,
    Options: Literal[
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "32",
        "33",
        "34",
        "35",
        "259",
        "64",
    ],
    MaxFiles: Constant,
    NumRecsTimeIntoInterval: Variable | Constant,
    Interval: Variable | Constant,
    Units: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    OutStat: Variable,
    LastFileName: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tablefile.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tablefile.htm).

                The TableFile instruction must be placed inside a data table declaration for the table you wish to write to file.The values set for the Tablefile NumRecs and Interval parameters depend on the desired data storage mode. For the SC115, two data "plug-and-pull" modes are available: standard and enhanced. With both plug-and-pull modes, data collection is automatically initiated by connecting the  SC115 to the datalogger. In standard mode, only the newest data (that is, data written to datalogger memory since the last time the drive was connected) is collected. In enhanced mode, all data stored in the datalogger's memory is collected every time the drive is reconnected.
    The standard plug-and-pull mode is enabled by entering 0 for both the NumRecs (Number of Records) and the Interval parameter.
    TableFile("USB:"+Status.SerialNumber+"_FileName",8,-1,0,0,Hr,0,0) 'standard mode
    Enhanced mode is enabled by entering 0 for the NumRecs parameter and -1 for the Interval parameter.
    TableFile("USB:"+Status.SerialNumber+"_FileName",8,-1,0,-1,Hr,0,0) 'enhanced mode
    In addition to these plug-and-pull modes, a resident mode is available for the SC115. In the resident mode, the SC115 remains attached to a single datalogger allowing it to be used as resident external memory. The datalogger can be programmed to bale data to the SC115 at regular intervals or at uniform bale sizes. See the SC115 manual for details.
    The resulting file can be copied manually to a PC (using File Control or Windows Explorer), copied to an FTP site using the FTPClient function, or sent as an attachment to an SMTP mail server using the EMailRelay function. The value of the OutStat variable can be monitored to determine when a new file has been written, and thus control the transfer of the file via email or FTP. If this functionality is used, the value should be checked after the CallTable instruction that refers to the data table containing the TableFile instruction. Because the file write operation is executed by a separate task within the datalogger, the OutStat and LastFileName variables will not be updated until the next execution of the EndTable instruction after the scan in which the file was written. This results in a one-scan lag of when the file is written and the variables are updated. The effect of this lag can be lessened with a faster scan rate. Note, however, that if the table is called rapidly (for example, 1 second interval), when viewing the variable on a numeric display, you may never see the value update to -1.
    Note that when the Interval is true, because the active file is closed, and a new file is subsequently opened, the two files may appear to have the same timestamp when viewed in a directory listing (such as LoggerNet or PC400's File Control). The newly opened file will be assigned a final timestamp when it is closed, and the next new file is opened.
    NOTE: Data table access syntax such as TableName.FieldName is only available with the open or most recent Tablefile that is created with option 64. Data table access is not accessible with other options of Tablefile.

    Args:
                    FileName (Constant): Specifies the device to write to and the name of the file to create. The created file will have a suffix of X.dat, where X is a number that will be incremented each time a new file is written.  FileName must be a constant and enclosed in quotes. It is entered in the format of "Device:FileName". The device choices are CRD (memory card), USR (user-defined drive), or USB (SC115). The USR drive is an area of memory that can be set up by the user by assigning a value to the datalogger's UsrDriveSize setting in the Status table. This drive must be set to at least 8192 bytes, in 512 byte increments (if the value entered is not a multiple of 512 bytes, the size will be rounded up. It may also be rounded up if additional bytes are needed for overhead).

            Options (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the type of file to be saved and whether or not to include the header information, timestamp, and/or record number. Right-click the parameter for a list of valid options.  The Options parameter is used to specify the type of file to be saved and whether or not to include the header information, timestamp, and/or record number. Options 0, 8, 16, and 32 correspond to Campbell Scientific defined formats for TOB1, TOA5, CSIXML, and CSIJSON, respectively. Choosing an option that is different than these defined formats may make the file incompatible with other Campbell Scientific applications designed to read or process those files (for instance, any option that does not include the Header will make the file unreadable by CardConvert or View Pro). Negating the Options parameter for all options except 0 and 64, results in each new record being appended to the file at the time it is written, rather than waiting for the next interval to "bale" the data. This "append" mode may have advantages for long intervals that are vulnerable to loss of data in the event that an interval is missed due to power loss or a program restart. However, append mode is not recommended for "fast" data storage (e.g., intervals less than 5 min).   See Table File Append Mode for more information. With any of the options above, when a card is removed from the datalogger, any records waiting to be written at the next output interval will be written immediately to the card. If 100 is added to the code above, the records are not written immediately; they will be written at the next output interval during which a card is present. If the TableFile instruction is writing to a memory card, and the program uses the CardOut instruction as well, then prior to creating the fixed size CardOut tables the required card space will be calculated and reserved for all fixed size TableFile files. Space is reserved by subtracting the estimated space required by the instruction from the available memory on the card (however, space is not preallocated). If the TableFile instruction uses auto-allocation then no space is reserved for its files and the MaxFiles value will be set once the card is full. If both the TableFile and the CardOut instruction attempt to use auto-allocation, a compile error will be returned. With Options 0 through 35, before a memory card is removed (when the removal button is pressed), all TableFiles will be written to the card, regardless of whether the output condition (time interval or fixed number of records) has been met. With Options 100 to 135, any outstanding records are not written to the card immediately; they will be written to the card on the next output interval at which a card is present. *Option 64 applies only to files being written to the CRD drive. Additionally, CardOut cannot be used in the same table that is using TableFile to write TOB3 files.
      Must be one of following options: 0 (TOB1, Header, TimeStamp, Record#), 1 (TOB1, Header, TimeStamp), 2 (TOB1, Header, Record#), 3 (TOB1, Header), 4 (TOB1, TimeStamp, Record#), 5 (TOB1, TimeStamp), 6 (TOB1, Record#), 7 (TOB1), 8 (TOA5, Header, TimeStamp, Record#), 9 (TOA5, Header, TimeStamp), 10 (TOA5, Header, Record#), 11 (TOA5, Header), 12 (TOA5, TimeStamp, Record#), 13 (TOA5, TimeStamp), 14 (TOA5, Record#), 15 (TOA5), 16 (CSIXML, TimeStamp, Record#), 17 (CSIXML, TimeStamp), 18 (CSIXML, Record#), 19 (CSIXML), 32 (CSIJSON, TimeStamp, Record#), 33 (CSIJSON, TimeStamp), 34 (CSIJSON, Record#), 35 (CSIJSON), 259 (AmeriFlux, Header), 64 (TOB3 (CRD Drive Only)*)

            MaxFiles (Constant): Used to specify the maximum number of files to retain on the storage device. When the MaxFiles is reached, the oldest file will be deleted prior to writing the new one. If the destination drive is not large enough to accommodate MaxFiles, the datalogger will adjust MaxFiles internally (though the parameter will not be changed in the instruction). If MaxFiles is set to -1, then no limit will be set for the maximum number of files that can be written, until the storage device is full. Once the device is full, the oldest file will be deleted prior to writing the new one. If MaxFiles is set to -2, there is no limit set for the maximum number of files that can be written, but once the storage device is full, no new files will be written. Thus, -1 is analogous to an auto-allocated ring memory mode, and -2 is analogous to an auto-allocated fill and stop mode. If MaxFiles is set to 0, FileName will not be incremented and the file will be overwritten with a new file each time.

            NumRecs/TimeIntoInterval (Variable | Constant): The function of this parameter depends upon whether or not Interval is a non-zero value. If Interval is set to 0, enter the number of records to include in each file. A new file will not be written until enough records have been written to the datalogger's table to satisfy the NumRec parameter. If Interval is a non-zero value, enter the time into the interval (or offset) that a file should be written. For instance, if Interval is set to 60, Units is set to minutes, and this parameter is set to 15, records will be written at 15 minutes past the hour, each hour.

            Interval (Variable | Constant): Determines whether the instruction will write files based on a specified number of records or on a time interval. If Interval is set to 0, files will be written once a specified number of records is available in the datalogger's data table. If Interval has a non-zero value, files will be written based on a time interval (which is determined by using three parameters: TimeIntoInterval, Interval, and Units). When using an SC115, if Interval is set to -1, all data or a specified number of records will be written when the media is plugged into the datalogger or when CardFlush is executed. All data is set by using 0 in the NumRecs parameter, and a specified number of records is set by putting the desired number of records in NumRecs.

            Units (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the units on which the TimeIntoInterval and Interval parameters will be based. The options are microseconds, milliseconds, seconds, minutes, hours, or days. Right-click the parameter to display a list.

            OutStat (Variable): A variable that holds a value indicating whether or not a new file has been stored. If a new file is written when the instruction is executed, a -1 will be stored. If a new file is not written, a 0 will be stored. If this parameter is set to 0 instead of a variable, it will be ignored. Note that this variable is updated one scan behind when the file is written.

            LastFileName (Variable): A variable that contains the name of the last file written. It must be defined as a string and sized large enough to accommodate the saved file name. If 0 is entered for this parameter, it is ignored. Note that this variable is updated the next time the data table is called.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TableFile({FileName},{Options},{MaxFiles},{NumRecsTimeIntoInterval},{Interval},{Units},{OutStat},{LastFileName})"


def Tan(
    angle: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tan.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tan.htm).

                The TAN function evaluates an angle and returns the ratio of two sides of a right triangle. The ratio is the length of the side opposite an angle divided by the length of the side adjacent to the angle. The Angle argument can be any valid numeric expression measured in radians.
    AngleDegrees can be used to change the source for this function to degrees instead of radians.

    Args:
                    angle (Variable | Constant | Expression | Array | Integer | ConstantInteger): angle (No description provided)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Tan({angle})"


def Tanh(
    Expr: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tanh.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tanh.htm).

    Args:
        Expr (Variable | Constant | Expression | Array | Integer | ConstantInteger): Expr (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Tanh({Expr})"


def TDR100(
    Dest: Variable | Array,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Option: Literal["0", "1", "2", "3"],
    MuxProbeSelect: Constant,
    WaveAvg: Variable | Constant,
    Vp: Variable | Constant,
    Points: Constant,
    CableLength: Variable | Constant | Array,
    WindowLength: Variable | Constant,
    ProbeLength: Variable | Constant,
    ProbeOffset: Variable | Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tdr100.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tdr100.htm).

              This instruction can be used to measure one TDR probe connected to the TDR100 directly or multiple TDR probes connected to one or more SDMX50 multiplexers.

    Args:
                  Dest (Variable | Array): A variable or variable array in which to store the results of the measurement. The variable must be dimensioned to accommodate all of the values returned by the instruction, which is determined by the Option parameter.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          Option (Constant): Determines the output of the instruction.
    Must be one of following options: 0 (Measure La/L (ratio of apparent to physical probe rod length)), 1 (Collect Waveform values - Outputs reflection waveform values as an array of floating point numbers with a range of -1 to 1. The waveform values are prefaced by a header containing values of key parameters for this instruction including averaging, propagation velocity, points, cable length, window length, probe length, probe offset, multiplier, and offset. For the TDR200, noise rejection frequency, filter level, and Laa are also included in the header.), 2 (Collect Waveform plus First Derivative - Returns (2*n-5)+9 values where n is the number of waveform reflection values specified by the Points parameter.), 3 (Measure Electrical Conductivity - Outputs a value that when multiplied by the Multiplier parameter determines soil bulk electrical conductivity in S/m.)

          Mux/ProbeSelect (Constant): Used to define the setup of any multiplexers and attached probes in the system. The addressing scheme used is ABCR, where A = level 1 multiplexer channel, B = level 2 multiplexer channel, C = level 3 multiplexer channel, and R = the number of consecutive probes to be read, starting with the channel specified by the ABC value (maximum of 8). 0 is entered for any level not used.

          WaveAvg (Variable | Constant): Used to define the number of waveform reflections averaged by the TDR100/200 to give a single result. A waveform averaging value of 4 provides good signal-to-noise ratio under typical applications. Under high noise conditions averaging can be increased. The maximum averaging possible is 128.

          Vp (Variable | Constant): Allows you to enter the propagation velocity of a cable when using the instruction to test for cable lengths or faults. Vp adjustment is not necessary for soil water content or electrical conductivity measurement and should be set to 1.0 for output Option 1, 2, or 3.

          Points (Constant): Used to define the number of values in the displayed or collected waveform (20 to 2048 for the TDR100; 20 to 10,112 for the TDR200). An entry of 251 is recommended for soil water measurements. The waveform consists of the number of Points equally spaced over the WindowLength.

          CableLength (Variable | Constant | Array): Specifies the cable length, in meters, of the TDR probes. If a 0 is entered for the Option parameter, cable length is used by the analysis algorithm to begin searching for the TDR probe. If a 1 or 2 is entered for the Option parameter, cable length is the distance to the start of the collected waveform. The value used for CableLength is best determined using PCTDR with the Vp = 1.0. Adjust the CableLength and WindowLength values in PCTDR until the probe reflection can be viewed. Subtract about 0.5 meters from the distance associated with the beginning of the probe reflection. Note that if CableLength is a scalar the specified CableLength applies to all probes read by this instruction; therefore, all probes must have the same cable lengths. However, CableLength can be a variable array loaded with the cable length values to use for each probe; e.g., CableLength(1) is used for the first probe, CableLength(2) is use for the second probe, etc. In this instance, the CableLength array should be loaded with values prior to the start of the scan.

          WindowLength (Variable | Constant): Specifies the length, in meters, of the waveform to collect or analyze. The waveform begins at the CableLength and ends at the CableLength + WindowLength. This is an apparent length because the value set for Vp may not be the actual propagation velocity. For water content measurements, the WindowLength must be large enough to contain the entire probe reflection for probes with 20 to 30 cm rods. A Vp = 1 and Window length = 5 is recommended.

          ProbeLength (Variable | Constant): Specifies the length, in meters, of the probe rods that are exposed to the medium being measured. The value of this parameter only has an affect when Option 0, La/L, is used for the measurement.

          ProbeOffset (Variable | Constant): An apparent length value used to correct for the portion of the probe rods that may be encapsulated in epoxy and not surrounded by soil or other medium being measured. This value is supplied by Campbell Scientific for the probes we manufacture. The value of this parameter only has an affect when Option 0, La/L, is used for the measurement.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TDR100({Dest},{SDMAddress},{Option},{MuxProbeSelect},{WaveAvg},{Vp},{Points},{CableLength},{WindowLength},{ProbeLength},{ProbeOffset},{Mult},{Offset})"


def TDR200(
    Dest: Variable | Array,
    SDMAddress: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Option: Literal["0", "1", "2", "3"],
    MuxProbeSelect: Constant,
    WaveAvg: Variable | Constant,
    Vp: Variable | Constant,
    Points: Constant,
    CableLength: Variable | Constant | Array,
    WindowLength: Variable | Constant,
    ProbeLength: Variable | Constant,
    ProbeOffset: Variable | Constant,
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
    NoiseRejectionFreq: Literal["0", "50", "60"],
    TDRFilterLevel: Constant,
    TDRLaa: Literal["0", "1", "2"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tdr200.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tdr200.htm).

              This instruction can be used to measure one TDR probe connected to the TDR200 directly or multiple TDR probes connected to one or more SDMX50 multiplexers.

    Args:
                  Dest (Variable | Array): A variable or variable array in which to store the results of the measurement. The variable must be dimensioned to accommodate all of the values returned by the instruction, which is determined by the Option parameter.

          SDMAddress (Variable | Constant | Expression | Array | Integer | ConstantInteger): Defines the address of the device with which to communicate. Valid SDM Synchronous Device for Measurement. A processor-based peripheral device or sensor that communicates with the datalogger via hardwire over a short distance using a protocol proprietary to Campbell Scientific. addresses are 0 through 14. Address 15 is reserved for the SDMTrigger instruction.  Some SDM instructions support repetitions. If a Reps parameter is present and it is greater than 1, the data logger will increment the SDM address used in the instruction for each subsequent device with which it communicates.

          Option (Constant): Determines the output of the instruction.
    Must be one of following options: 0 (Measure La/L (ratio of apparent to physical probe rod length)), 1 (Collect Waveform values - Outputs reflection waveform values as an array of floating point numbers with a range of -1 to 1. The waveform values are prefaced by a header containing values of key parameters for this instruction including averaging, propagation velocity, points, cable length, window length, probe length, probe offset, multiplier, and offset. For the TDR200, noise rejection frequency, filter level, and Laa are also included in the header.), 2 (Collect Waveform plus First Derivative - Returns (2*n-5)+9 values where n is the number of waveform reflection values specified by the Points parameter.), 3 (Measure Electrical Conductivity - Outputs a value that when multiplied by the Multiplier parameter determines soil bulk electrical conductivity in S/m.)

          Mux/ProbeSelect (Constant): Used to define the setup of any multiplexers and attached probes in the system. The addressing scheme used is ABCR, where A = level 1 multiplexer channel, B = level 2 multiplexer channel, C = level 3 multiplexer channel, and R = the number of consecutive probes to be read, starting with the channel specified by the ABC value (maximum of 8). 0 is entered for any level not used.

          WaveAvg (Variable | Constant): Used to define the number of waveform reflections averaged by the TDR100/200 to give a single result. A waveform averaging value of 4 provides good signal-to-noise ratio under typical applications. Under high noise conditions averaging can be increased. The maximum averaging possible is 128.

          Vp (Variable | Constant): Allows you to enter the propagation velocity of a cable when using the instruction to test for cable lengths or faults. Vp adjustment is not necessary for soil water content or electrical conductivity measurement and should be set to 1.0 for output Option 1, 2, or 3.

          Points (Constant): Used to define the number of values in the displayed or collected waveform (20 to 2048 for the TDR100; 20 to 10,112 for the TDR200). An entry of 251 is recommended for soil water measurements. The waveform consists of the number of Points equally spaced over the WindowLength.

          CableLength (Variable | Constant | Array): Specifies the cable length, in meters, of the TDR probes. If a 0 is entered for the Option parameter, cable length is used by the analysis algorithm to begin searching for the TDR probe. If a 1 or 2 is entered for the Option parameter, cable length is the distance to the start of the collected waveform. The value used for CableLength is best determined using PCTDR with the Vp = 1.0. Adjust the CableLength and WindowLength values in PCTDR until the probe reflection can be viewed. Subtract about 0.5 meters from the distance associated with the beginning of the probe reflection. Note that if CableLength is a scalar the specified CableLength applies to all probes read by this instruction; therefore, all probes must have the same cable lengths. However, CableLength can be a variable array loaded with the cable length values to use for each probe; e.g., CableLength(1) is used for the first probe, CableLength(2) is use for the second probe, etc. In this instance, the CableLength array should be loaded with values prior to the start of the scan.

          WindowLength (Variable | Constant): Specifies the length, in meters, of the waveform to collect or analyze. The waveform begins at the CableLength and ends at the CableLength + WindowLength. This is an apparent length because the value set for Vp may not be the actual propagation velocity. For water content measurements, the WindowLength must be large enough to contain the entire probe reflection for probes with 20 to 30 cm rods. A Vp = 1 and Window length = 5 is recommended.

          ProbeLength (Variable | Constant): Specifies the length, in meters, of the probe rods that are exposed to the medium being measured. The value of this parameter only has an affect when Option 0, La/L, is used for the measurement.

          ProbeOffset (Variable | Constant): An apparent length value used to correct for the portion of the probe rods that may be encapsulated in epoxy and not surrounded by soil or other medium being measured. This value is supplied by Campbell Scientific for the probes we manufacture. The value of this parameter only has an affect when Option 0, La/L, is used for the measurement.

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          NoiseRejectionFreq     (Constant): The type of noise rejection to be applied to the measurement. Valid options are:
    Must be one of following options: 0 (No frequency rejection will be used in the measurement.), 50 (The TDR will take 2 contiguous measurements that are exactly 10 ms out of phase in order to cancel 50 Hz noise. If the WaveAvg parameter is an odd number, the actual number of averages will be the next highest even integer.), 60 (The TDR will take 2 contiguous measurements that are exactly 8.33 ms out of phase in order to cancel 60 Hz noise. If the WaveAvg parameter  is an odd number, the actual number of averages will be the next highest even integer.)

          TDRFilterLevel (Constant): The TDR200 can reduce noise of the TDR trace by applying a weighted moving average (arithmetic convolution) to the data points. This parameter is used to determine the number of neighboring values to include in the weighted average. Acceptable values are 0 (no filtering) to 10 (maximum filtering). As an example, choosing a Filter Level of 2 will use 5 measured values in calculating the final output value: 2 values prior to the point of interest, the actual measured point of interest, and the 2 values after that point. Each of those points is weighted with the closer points having more weight than those further away.

          TDRLaa (Constant): Allows the user to select the desired algorithm that the TDR200 will use to determine the end of the probe (2nd reflection). The following algorithms are available: Reference: Wang, Z., Y. Kojima, S. Lu, Y. Chen, R. Horton, and R.C. Schwartz. 2014. Time domain reflectometry waveform analysis with second order bounded mean oscillation. Soil Sci. Soc. Am. J. 78:1146–1152. doi:10.2136/sssaj2013.11.0497 Wang, Z., Y. Lu, Y. Kojima, S. Lu, M. Zhang, Y. Chen, R. Horton. 2016. Tangent Line/Second-Order Bounded Mean Oscillation Waveform Analysis for Short TDR Probe. Vadose Zone J. Vol. 15, Iss. 1. doi:10.2136/vzj2015.04.0054
    Must be one of following options: 0 (Legacy Algorithm. This algorithm is similar to that used in the TDR100 and uses the 2nd derivative of the waveform to detect inflection points. This is a simple method that is consistent over varying soils and water contents. It will yield the same values as those given by the TDR100. This algorithm has difficulty in electrically noisy environments (nearby radios, motors, fluorescent and LED lighting) or when the length of probes are short.), 1 (Tangent Line Method. This algorithm uses the flatline method made popular in the WinTDR software package. This method works well without any predefined waveform attributes and has the advantage of being more resistant to noisy environments.), 2 (Second-Order Bounded Mean Oscillation (BMO) Method. The second-order BMO method has been developed to aid in researchers using short probes with non-smooth lines (Wang et al., 2014). When this method is selected, PCTDR uses a combined approach of both tangent line and second-order BMO methods (Wang et al., 2016). This combined method uses the tangent line to narrow in on the region of the waveform where the second reflection appears and then uses the second-order BMO method to finalize the point representing the probe’s end)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TDR200({Dest},{SDMAddress},{Option},{MuxProbeSelect},{WaveAvg},{Vp},{Points},{CableLength},{WindowLength},{ProbeLength},{ProbeOffset},{Mult},{Offset},{NoiseRejectionFreq},{TDRFilterLevel},{TDRLaa})"


def TimerInput(
    Dest: Variable | Array,
    StartChan: Literal["C1"],
    Edge: Literal["0", "1"],
    Function: Literal["0", "1", "2", "3", "5"],
    Timeout: Variable | Constant,
    Timeout_Units: Literal["μsec", "msec", "Sec", "Min"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timerinput.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/timerinput.htm).

              This instruction measures the timing of the edges on the control ports. The instruction can be used in Low Frequency Mode (<1 kHz) for edge timing, period, and frequency measurements or in High Frequency Mode (up to about 2.3 kHz) for edge counting only. The edge timing resolution is 500 nS. Time values are always returned in μsec. This instruction will return NAN if the timeout expires or if a signal on a channel is too fast.

    Args:
                  Dest (Variable | Array): The Dest parameter is a variable array in which to store the results of the measurement. The array must be dimensioned equal to the number of ports for which results are requested.

          StartChan (Constant): The channel to use as a reference for edge timing for this instruction.
    Must be one of following options: C1 (Control Port 1 and 2)

          Edge (Constant): The Edge parameter is a digit (0 or 1) that represents each of the ports, from left to right: C8….C1. If a 1 is entered for a port, the transition will be counted on the rising edge (from <1.5V to >3.5V). If a 0 is entered, the transition will be counted on the falling edge (from >3.5V to <1.5V). For example, getting a rising edge on C8 starting at C1 would be done with: TimerInput(Dest,C1,10000000,20000000,0,usec).
    Must be one of following options: 0 (falling), 1 (rising)

          Function (Constant): The Function parameter is a value where each digit represents the function for the channel associated with that digit (see Edges, above). Leading 0s do not have to be used if you are using only the first few channels for the instruction. For example, measure the frequency on the falling edge of C1 could be specified with either: TimerInput(Dest,C1,0,2,0,usec) or TimerInput(Dest,C1,0000,0002,0,usec).
    Must be one of following options: 0 (The associated channel is not used.), 1 (Calculate the period of the signal on the specified channel (in microseconds).), 2 (Calculate the frequency (Hz) for the specified channel.), 3 (Calculate the time from an edge on the previous channel (1 number lower) to an edge on the specified channel (in microseconds) (even channels only, for example, time from C4 since C3, or C8 since C7).), 5 (Return the count of edges since the last execution.)

          Timeout (Variable | Constant): Used to determine the results to be returned when no changes have occurred in the specified ports since the last execution of the instruction. If the timeout period has expired and no change has occurred, a null value will be returned (0 for frequency and NaN for period or time since last edge). If the timeout period has not expired the last valid result will be returned. This is useful for measuring signals with periods greater than the scan interval. The maximum Timout is 2^32 x the scan. Typically, a timeout value is at least one scan interval. However, 0 can be entered to make the calculation each time the instruction is executed. A timeout less than the scan interval will default to the scan interval.

          Timeout_Units (Constant): The units for the Timeout parameter. Right-click the parameter to display a drop-down list box.
    Must be one of following options: μsec (microseconds), msec (milliseconds), Sec (seconds), Min (minutes)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TimerInput({Dest},{StartChan},{Edge},{Function},{Timeout},{Timeout_Units})"


def TotalRun(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Number: Constant,
    RunReset: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    Count: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TotalCalls: Constant,
    Call_ID: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/totalrun.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/totalrun.htm).

                This instruction, when used, must appear between the Scan … NextScan instructions. A running total is the total of the last N values where N is specified in the Number argument. Until the datalogger has taken N measurements the total is calculated based on the number of actual measurements made.
    NAN values are not included in the running total. However, they can affect the running total by reducing the number of values contained in the total. The running total is calculated from the non-NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. values in the buffer of historical data. Note that all values, including NAN, are stored in the ring buffer. When a new value comes in, the running total is calculated by adding in the new value (if not NAN) and subtracting the oldest value (if not NAN). For example, if you have an N (number of values) of 5, but 2 of those are NANs, then N is reduced to 3, which results in a “poorer” total. In the event that all values in the buffer are NAN, a NAN is returned as the running total (this can be useful in detecting faults; for example, a broken sensor). If you want to ensure there are always N values used in the running total, theTotalRun instruction should be called conditionally (only when good values are received). This will eliminate any memory in the buffer being allocated to NAN values that are not used in the calculation. Calling the TotalRun instruction conditionally could also be used to remove values that are out-of-range.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the TotalRun instruction, the Reps parameter is the number of variables in the array for which a running total should be calculated. When the Source is not an array, or only a single variable in the array should be totaled, Reps should be 1.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

            Number (Constant): The number of values of Source to be used for calculating the running average, running total, running minimum, running maximum, or running standard deviation.

            RunReset (Variable | Constant | Expression | Array | Integer | ConstantInteger): When RunReset is true, the history over which the running value (for example, running average, running maximum, running minimum, running total, or running standard deviation)  is calculated is cleared, so that the value returned is calculated from a a single value, the current input. Note that the reset parameter does not automatically toggle back to false once set to true. When the reset parameter is set back to false (problematically or manually), then the running average, running maximum, running minimum, or running total continues, starting with the current input. Note that until the data logger has taken N measurements, the running average/total/maximum/minimum is calculated based on the actual number of measurements made since reset was set back to false.

            Count (Variable | Constant | Expression | Array | Integer | ConstantInteger): Optional parameter added in OS 3.02 and greater that returns the actual number of values used to calculate the running value. The actual number of values used may be different than the number specified for the calculation due to NAN values in the buffer of historical data. The Count parameter can only be used if the optional Reset parameter is also used. The Count parameter is a variable of Type Long and must be the same dimension as the array that is being averaged (i.e., the same as reps). A count used for each rep will be written to this variable on each execution of the instruction.  The TotalCalls and Call_ID optional parameters below, allow a single instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun)  to be called with different source variables, as in a subroutine or function.  Click here for additional information. These parameters are available with operating system 7 and later.

            TotalCalls (Constant): Optional parameter that specifies the total number of calls to a specific instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun) in the program.

            Call_ID (Integer): Specifies a unique ID number for each specific call of the instruction. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"TotalRun({Dest},{Reps},{Source},{Number},{RunReset},{Count},{TotalCalls},{Call_ID})"


def MinRun(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Number: Constant,
    RunReset: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TotalCalls: Constant,
    Call_ID: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minrun.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/minrun.htm).

                This instruction, when used, must appear between the Scan … NextScan instructions. A running minimum is the minimum of the last N values where N is specified in the Number argument. Until the data logger has taken N measurements the minimum is calculated based on the number of actual measurements made.
    NAN values are not included in the running minimum. However, they can affect the running minimum by reducing the number of values contained in the minimum. The running minimum is calculated from the non-NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. values in the buffer of historical data. Note that all values, including NAN, are stored in the ring buffer. If you have an N (number of values) of 5, but 2 of those are NANs, then N is reduced to 3, which results in a “poorer” minimum. In the event that all values in the buffer are NAN, a NAN is returned as the running minimum (this can be useful in detecting faults; for example, a broken sensor). If you want to ensure there are always N values used in the running minimum, the MinRun instruction should be called conditionally (only when good values are received). This will eliminate any memory in the buffer being allocated to NAN values. Calling the MinRun instruction conditionally could also be used to remove values that are out-of-range.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the MinRun instruction, the Reps parameter is the number of variables in the array for which a running minimum should be calculated. When the Source is not an array, or only a single variable in the array should be used, Reps should be 1.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

            Number (Constant): The number of values of Source to be used for calculating the running average, running total, running minimum, running maximum, or running standard deviation.

            RunReset (Variable | Constant | Expression | Array | Integer | ConstantInteger): When RunReset is true, the history over which the running value (for example, running average, running maximum, running minimum, running total, or running standard deviation)  is calculated is cleared, so that the value returned is calculated from a a single value, the current input. Note that the reset parameter does not automatically toggle back to false once set to true. When the reset parameter is set back to false (problematically or manually), then the running average, running maximum, running minimum, or running total continues, starting with the current input. Note that until the data logger has taken N measurements, the running average/total/maximum/minimum is calculated based on the actual number of measurements made since reset was set back to false. The TotalCalls and Call_ID optional parameters below, allow a single instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun)  to be called with different source variables, as in a subroutine or function.  Click here for additional information. These parameters are available with operating system 7 and later.

            TotalCalls (Constant): Optional parameter that specifies the total number of calls to a specific instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun) in the program.

            Call_ID (Integer): Specifies a unique ID number for each specific call of the instruction. NOTE:  If more than one instance of the instruction occurs in the program, each instance requires its own set of TotalCalls and Call_ID parameters. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MinRun({Dest},{Reps},{Source},{Number},{RunReset},{TotalCalls},{Call_ID})"


def MaxRun(
    Dest: Variable | Array,
    Reps: Constant,
    Source: Variable,
    Number: Constant,
    RunReset: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TotalCalls: Constant,
    Call_ID: Integer,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maxrun.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/maxrun.htm).

                This instruction, when used, must appear between the Scan … NextScan instructions. A running maximum is the maximum of the last N values where N is specified in the Number argument. Until the datalogger has taken N measurements the maximum is calculated based on the number of actual measurements made.
    NAN values are not included in the running maximum. However, they can affect the running maximum by reducing the number of values contained in the maximum. The running maximum is calculated from the non-NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. values in the buffer of historical data. Note that all values, including NAN, are stored in the ring buffer. If you have an N (number of values) of 5, but 2 of those are NANs, then N is reduced to 3, which results in a “poorer” maximum. In the event that all values in the buffer are NAN, a NAN is returned as the running maximum (this can be useful in detecting faults; for example, a broken sensor). If you want to ensure there are always N values used in the running maximum, the MaxRun instruction should be called conditionally (only when good values are received). This will eliminate any memory in the buffer being allocated to NAN values. Calling the MaxRun instruction conditionally could also be used to remove values that are out-of-range.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the MaxRun instruciton, the Reps parameter is the number of variables in the array for which a running maximum should be calculated. When the Source is not an array, or only a single variable in the array should be used, Reps should be 1.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables.

            Number (Constant): The number of values of Source to be used for calculating the running average, running total, running minimum, running maximum, or running standard deviation.

            RunReset (Variable | Constant | Expression | Array | Integer | ConstantInteger): When RunReset is true, the history over which the running value (for example, running average, running maximum, running minimum, running total, or running standard deviation)  is calculated is cleared, so that the value returned is calculated from a a single value, the current input. Note that the reset parameter does not automatically toggle back to false once set to true. When the reset parameter is set back to false (problematically or manually), then the running average, running maximum, running minimum, or running total continues, starting with the current input. Note that until the data logger has taken N measurements, the running average/total/maximum/minimum is calculated based on the actual number of measurements made since reset was set back to false. The TotalCalls and Call_ID optional parameters below, allow a single instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun)  to be called with different source variables, as in a subroutine or function.  Click here for additional information. These parameters are available with operating system 7 and later.

            TotalCalls (Constant): Optional parameter that specifies the total number of calls to a specific instance of the instruction (AvgRun, MaxRun, MinRun, StdDevRun) in the program.

            Call_ID (Integer): Specifies a unique ID number for each specific call of the instruction. NOTE: This instruction uses high precision math A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision.  Instructions that use high precision are Average, AvgRun, AvgSpa, CovSpa, MovePrecise, RMSSpa, StdDev, StdDevSpa, TotalRun, and Totalize.. A normal single precision float has 24 bits of mantissa. With high precision, a 32 bit extension of the mantissa is saved and used internally, resulting in 56 bits of precision. Instructions that use high precision are AddPrecise, Average, AvgRun, AvgSpa, CovSpa, MinRun, MaxRun, MovePrecise, RMSSpa, StdDev, StdDevRun, StdDevSpa, TotalRun, and Totalize.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MaxRun({Dest},{Reps},{Source},{Number},{RunReset},{TotalCalls},{Call_ID})"


def Trim(
    TrimString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/trim.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/trim.htm).

    The TrimString parameter is the string that should be stripped of leading and trailing spaces.

    Args:
        TrimString (Variable | Constant | Expression | Array | Integer | ConstantInteger): TrimString (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"Trim({TrimString})"


def LTrim(
    TrimString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ltrim.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/ltrim.htm).

    The TrimString parameter is the string that should be stripped of leading spaces.

    Args:
        TrimString (Variable | Constant | Expression | Array | Integer | ConstantInteger): TrimString (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"LTrim({TrimString})"


def RTrim(
    TrimString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rtrim.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/rtrim.htm).

    The TrimString parameter is the string that should be stripped of trailing spaces.

    Args:
        TrimString (Variable | Constant | Expression | Array | Integer | ConstantInteger): TrimString (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"RTrim({TrimString})"


def UDPDataGram(
    IPAddr: Variable,
    UDPPort: Variable | Constant,
    UDPSendVar: Variable,
    UDPSendLen: Constant,
    UDPRecVar: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    UDPTimeOut: Constant,
    ConnectionHandle: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
    IPVersion: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/udpdatagram.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/udpdatagram.htm).

    Args:
            IPAddr (Variable): The IP address for the socket you are trying to open. This is a string variable, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255), or an IPv6 address, or a fully-qualified domain name (for example, "computer-name.domain.com"). Numeric IPv4 addresses should be entered in decimal notation, with no leading zeros (i.e., 192.168.1.123, not 192.168.001.123). If you use a domain name, the address of a DNS Domain name server. A TCP/IP application protocol. server must be specified in datalogger settings. For all instructions except UDPOpen and IPRoute, the IPAddr can also be set to a null string (""), in which case the datalogger will listen for an incoming TCP/IP connection on the specified port. The entry for the IPAddr must be enclosed in quotes.

    UDPPort (Variable | Constant): The port number over which the datalogger will communicate. The valid range is 0 through 65535. In most instances, the value should be 49151 or greater. Values less than this are used by other common applications.

    UDPSendVar (Variable): Holds the value(s) that will be sent via the UDP communications protocol.

    UDPSendLen (Constant): The length, in bytes, of the packet to send. The maximum number of bytes is one IP packet (for example, ~1500 bytes).If UDPSendLen is 0, no packet will be sent.

    UDPRecVar (Variable | Constant | Expression | Array | Integer | ConstantInteger): UDPRecVar is the variable that will store a UDP datagram that is received by the datalogger.

    UDPTimeOut (Constant): The UDPTimeOut is the timeout period, in ms, for a UDP communications attempt. The timeout is in effect only when there are no messages in the received message queue.

    ConnectionHandle (Variable | Constant | Expression | Array | Integer | ConstantInteger): An optional parameter that returns the communications port (socket) of incoming UDP datagrams so that it can be used for subsequent serial out instructions.

    IPVersion (Constant): Optional parameter used to specify an IPV4 or IPV6 address type when the IPAddr parameter is null (and thus, the datalogger is listening on the port rather than initiating the connection). 0 = IPV4, 1 = IPV6.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"UDPDataGram({IPAddr},{UDPPort},{UDPSendVar},{UDPSendLen},{UDPRecVar},{UDPTimeOut},{ConnectionHandle},{IPVersion})"


def UDPOpen(
    IPAddr: Variable,
    UDPPort: Variable | Constant,
    IPBuffer: Constant,
    IPVersion: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/udpopen.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/udpopen.htm).

                This function returns a non-zero long integer if the socket is created. If the socket fails to be created a 0 is returned. Once a port is opened, serial input and output instructions can be used to transfer packets.
    UDPOpen can be placed in a slow sequence scan. In a slow sequence, it will run in the background and will not hold up the main program waiting for the socket to be opened successfully.

    Args:
                    IPAddr (Variable): The IP address for the socket you are trying to open. This is a string variable, which can be entered as a numeric address (for example, "xxx.xxx.xxx.xxx", with each xxx being a value of 0 to 255), or an IPv6 address, or a fully-qualified domain name (for example, "computer-name.domain.com"). Numeric IPv4 addresses should be entered in decimal notation, with no leading zeros (i.e., 192.168.1.123, not 192.168.001.123). If you use a domain name, the address of a DNS Domain name server. A TCP/IP application protocol. server must be specified in datalogger settings. For all instructions except UDPOpen and IPRoute, the IPAddr can also be set to a null string (""), in which case the datalogger will listen for an incoming TCP/IP connection on the specified port. The entry for the IPAddr must be enclosed in quotes.

            UDPPort (Variable | Constant): The port number over which the datalogger will communicate. The valid range is 0 through 65535. In most instances, the value should be 49151 or greater. Values less than this are used by other common applications.

            IPBuffer (Constant): If the socket is being opened for communication with a serial (non-PakBus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc.) device, enter a value for the size of the input serial buffer that should be created in datalogger memory. Set this parameter to 0 for communication with a PakBus device. When this parameter is set to 0, the port will be opened as a PakBus port and PakBus beaconing will take place every 3 minutes. For serial communications with non-PakBus devices, specify a buffer size large enough to hold the number of bytes that will arrive between serial input reads. Note that oversizing the buffer needlessly takes away from datalogger memory. For non-PakBus communication, do not set this parameter to 0 or PakBus beacons initiated by the datalogger may interfere with communications. For non-PakBus communication that does require a user-specified buffer (such as when used with ModbusClient(), set this parameter to 1 so that beaconing does not occur. Caution: For the UDPOpen instruction, do not set this parameter to 0 or the datalogger will attempt PakBus communication over the port and beaconing will interfere with communication. For non-PakBus communication that does not require a buffer set this parameter to 1 so that beaconing does not occur

            IPVersion (Constant): Optional parameter used to specify an IPV4 or IPV6 address type when the IPAddr parameter is null (and thus, the datalogger is listening on the port rather than initiating the connection). 0 = IPV4, 1 = IPV6.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"UDPOpen({IPAddr},{UDPPort},{IPBuffer},{IPVersion})"


def UpperCase(
    SourceString: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/uppercase.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/uppercase.htm).

    Args:
        SourceString (Variable | Constant | Expression | Array | Integer | ConstantInteger): SourceString (No description provided)

    Returns:
        str: A string of the CRBasic function call.

    """
    return f"UpperCase({SourceString})"


def PakBusClock(PakBusAddr: Integer) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pakbusclock.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/pakbusclock.htm).

                The PakBusAddr parameter is the address of the datalogger from which this datalogger will accept a ClockReport. The ClockReport instruction is used in the sending datalogger to send its clock value to this datalogger. PakBusClock needs to be executed only once for the datalogger to accept clock reports from another PakBus address. Thus, it should be placed immediately after the BeginProg instruction, and before the Scan instruction.
    Inclusion of the PakBusClock instruction does not preclude clock sets being accepted from software clients like LoggerNet. When the datalogger sets its clock as a result of this instruction, there is potential for time-base instructions to be skipped (such as Scan, DataInterval, or IfTime). This is true of a clock set from any source.

    Args:
                    PakBusAddr (Integer): The Pakbus PakBus® is a proprietary communication protocol developed by Campbell Scientific to facilitate communications between Campbell Scientific devices. Similar in concept to IP (Internet Protocol), PakBus is a packet-switched network protocol with routing capabilities. A registered trademark of Campbell Scientific, Inc. address of the device that will be contacted as a result of this instruction. Each PakBus device in the network must have a unique address. If PakBus encryption is enabled in the datalogger, by default the datalogger will encrypt the communications sent using PakBus communication. To disable encryption for one or more Pakbus addresses, use the EncryptExempt instruction. This is useful if a remote device does not support encryption (such as a CR200 or an AVW200). NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089, Konect GDS a value in the range of 4000 – 4050. 4095 is a broadcast address that can be used in a limited number of instructions.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"PakBusClock({PakBusAddr})"


def VaporPressure(Dest: Variable | Array, Temp: Variable, RH: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/vaporpressure.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/vaporpressure.htm).

                The vapor pressure is found from relative humidity and saturation vapor pressure using the following equation. The saturation vapor pressure is found from the dry bulb temperature.
    where VP = vapor pressure and SVP = saturation vapor pressure.
    The result is in kilopascals.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Temp (Variable): The variable in the program that contains the measurement, in degrees C, for temperature. For the VaporPressure instruction, the Temp parameter is the program variable that contains the value for the temperature sensor.

            RH (Variable): The variable in the program that contains the measurement for relative humidity. For the VaporPressure instruction, the RH measurement must be in percent of RH.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"VaporPressure({Dest},{Temp},{RH})"


def VoltSE(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    SEChan: Constant,
    MeasOff: Literal["0", "1"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/voltse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/voltse.htm).

                This instruction measures the voltage of a single ended analog channel with respect to ground.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the VoltSE instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
      Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

            SEChan (Constant): The single-ended channel number on which to make the first measurement. When Reps are used, subsequent measurements will be automatically made on the following channels. For the VoltSE instruction, if the SEChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible.

            MeasOff (Constant): Determines whether the ground offset voltage is measured before the measurement is made on the analog channel. If the ground offset is measured it is subtracted from the sensor measurement and the result is stored in Dest.
      Must be one of following options: 0 (Offset voltage is corrected from background calibration.), 1 (Offset voltage is measured each scan  (this option
    effectively increases the measurement time as if an additional rep were added to
    the instruction).)

            Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
      Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"VoltSE({Dest},{Reps},{Range},{SEChan},{MeasOff},{SettlingTime},{fN1},{Mult},{Offset})"


def VoltDiff(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal[
        "mV5000",
        "mV1000",
        "mv200",
        "Autorange",
        "AutorangeC",
        "mV5000C",
        "mV1000C",
        "mV200C",
    ],
    DiffChan: Literal["1", "2", "3", "4", "5", "6", "7", "8"],
    ReverseDifferential: Literal["False", "True"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/voltdiff.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/voltdiff.htm).

              This instruction measures the voltage difference between the high and low inputs of a differential channel. Both the high and low inputs must be in the range of -100 mV to +5000 mV relative to the datalogger's ground.

    Args:
                  Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

          Reps (Constant): The number of repetitions for the measurement or instruction. For the VoltDiff instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

          Range (Constant): The voltage range for the measurement or input sensor. An alphanumeric code is entered. Right-click the parameter to display a list or enter the code directly. Autorange increases the time to make the measurement. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. The second measurement is then performed using the range determined from the first measurement, along with the fN1 chosen for the measurement instruction. Both measurements use the settling time chosen for the particular measurement instruction. Auto-ranging optimizes resolution but takes longer than a fixed range measurement because of the two-measurement sequence. The exception to this two-measurement sequence is if Reps are made on the same channel (Reps parameter is negative). In this instance, the test measurement is made only once. Subsequent repetitions are made with the delay between each measurement being the specified settling time. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement. The C options check for an open connection on the analog input by applying a short overranging test signal to the analog input prior to making the measurement. For a voltage range of mv5000C, 5.6V is applied. For a voltage range of mv1000C or mv200C, 1.25V is applied. An open (broken) sensor will result in a measurement overrange, clearly indicating a sensor problem instead of returning a bad measured value caused by a floating input. The open-detect option may not work properly in the presence of external leakage (< 1 MOhm) to ground, as the overrange test signal could discharge through the external leakage during the input settling time such that an overrange condition no longer exists. In this case the measurement settling time should be minimized to minimize the discharge time of the overrange test signal. The open circuit detection (C option) can cause measurement errors for slow responding sensors, as such sensors may not have sufficient time to recover from the applied short duration (50 microseconds) test signal. For such sensors, increasing the measurement settling time beyond the default may be necessary for sufficient sensor recovery time. If measurement speed is critical with a slow responding sensor, then it may be preferable to not use the open detect (C option).
    Must be one of following options: mV5000 (+5000 mV), mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range.), AutorangeC (Autorange, checks for open input.), mV5000C (+5000 mV, checks for open input, sets excitation to ~5600 mV. Overrange values may go undetected; use code to detect overrange values.), mV1000C (+1000 mV, checks for open input, sets excitation to ~1250 mV.), mV200C (+200 mV, checks for open input, sets excitation to ~1250 mV.)

          DiffChan (Constant): Specifies the differential channel on which to make the first measurement. If the Reps parameter is greater than 1, additional measurements will be made on sequential channels. If the DiffChan number is entered as a negative value, all Reps are performed on the same channel (burst measurement). The CR1000X burst measurement sampling frequency is determined by the fN1 (first notch frequency) parameter which can go up to a maximum of 31250 Hz (minimum sample interval of 32 uS). The SettlingTime parameter is used to delay once prior to beginning the burst. The total time prior to beginning the burst is the SettlingTime plus the ADC flush time (which is 450 uS). The sample interval resolution is 1/31250 Hz. The specified notch frequency will use the nearest multiple of (1/31250 Hz) to get as close to the specified frequency as possible.
    Must be one of following options: 1 (Differential Channel 1 (SE 1 and 2)), 2 (Differential Channel 2 (SE 3 and 4)), 3 (Differential Channel 3 (SE 5 and 6)), 4 (Differential Channel 4 (SE 7 and 8)), 5 (Differential Channel 5 (SE 9 and 10)), 6 (Differential Channel 6 (SE 11 and 12)), 7 (Differential Channel 7 (SE 13 and 14)), 8 (Differential Channel 8 (SE 15 and 16))

          Reverse Differential (Variable | Constant): A constant value is entered to determine whether the inputs are reversed and a second measurement made. This removes any voltage offset errors due to the datalogger measurement circuitry, including operational input voltage errors. Enabling this parameter doubles the measurement time. Measurement time will increase four times if RevEx is used. Right-click to display a list.
    Must be one of following options: False (Signal is measured with the high side referenced to the low. Do not make second measurement.), True (Reverse input and make second measurement.)

          Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

          fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
    Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

          Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

          Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"VoltDiff({Dest},{Reps},{Range},{DiffChan},{ReverseDifferential},{SettlingTime},{fN1},{Mult},{Offset})"


def WaitDigTrig(
    ControlPort: Literal["C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8"],
    Option: Literal["0", "1", "2", "3"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/waitdigtrig.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/waitdigtrig.htm).

                The WaitDigTrig instruction is used to trigger measurement scans from an external digital input to a datalogger terminal. When the digital channel is in the state specified by the Option parameter, the scan takes place. For subsequent scans to occur, the digital channel’s state must evaluate as false and then true again (i.e., if the trigger condition remains true, only one scan will occur). A common use of this instruction is to control the scan rate of one datalogger based on another datalogger or control the scan rate of a datalogger based on an external device such as a GPS.
    The WaitDigTrig instruction can be executed within a Scan/NextScan sequence or it can be executed outside a scan (most commonly in a SlowSequence). When used inside a scan, execution of the scan occurs when WaitDigTrig evaluates as true (for example, port rises/falls or goes high/low) rather than basing the scan rate on the datalogger's clock. Thus, an external trigger controls the scan rate. This has ramifications:
    When used outside a scan, WaitDigTrig behaves similarly to a Delay instruction, though the delay is based on the state or transition of a control port instead of based on time. In this instance, the WaitDigTrig instruction can be placed inside an infinite Do/Loop, and the remaining instructions in that loop will be performed only when WaitDigTrig is true. This results in functionality similar to the Interrupt Subroutine available in Edlog-programmed dataloggers (such as the CR10X or CR23X's subroutine 96, 97, or 98).
    NOTE: If the program is running in sequential mode and has a slow sequence that includes a WaitDigTrig instruction, once triggered, that sequence will not be able to perform any measurement tasks when the main scan is running. The slow sequence will pause before its first measurement instruction, until the main scan is completed, after which it will continue. If the slow sequence contains only processing tasks, these tasks can run in conjunction with the main scan.

    Args:
                    ControlPort (Constant): The ControlPort parameter is used to specify the digital channel that will be used to trigger the scan. Right-click to display a list.
      Must be one of following options: C1 (Control Port 1), C2 (Control Port 2), C3 (Control Port 3), C4 (Control Port 4), C5 (Control Port 5), C6 (Control Port 6), C7 (Control Port 7), C8 (Control Port 8)

            Option (Constant): Used to specify what type of signal will cause the scan to begin. Right-click to display a list of options: Caution: The port for WaitDigTrig is configured at compile time. Once a port has been configured using WaitDigTrig, you cannot use a different option for that port using a different WaitDigTrig instruction later in the program.
      Must be one of following options: 0 (ControlPort going from low to high (edge triggered)), 1 (ControlPort going from high to low (edge triggered)), 2 (ControlPort is high (level triggered)), 3 (ControlPort is low (level triggered))

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"WaitDigTrig({ControlPort},{Option})"


def WetDryBulb(
    Dest: Variable | Array,
    DryTemp: Variable,
    WetTemp: Variable,
    Pressure: Variable | Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/wetdrybulb.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/wetdrybulb.htm).

        The WetDryBulb instruction uses an equation given by List, Robert. J.: 1966, Smithsonian Meteorological Tables, Sixth Revised Edition, Smithsonian Institution, Washington, D.C., page 365. This equation is also used by the National Weather Service. The results are in kPa.

    Args:
            Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

    DryTemp (Variable): The program variable that contains the value for the ambient air temperature sensor. The temperature measurement must be in degrees C.

    WetTemp (Variable): The program variable that contains the value for the wet bulb temperature sensor. The temperature measurement must be in degrees C.

    Pressure (Variable | Constant): The program variable that contains the value for the air pressure sensor. The air pressure measurement must be in kilopascals. If an air pressure sensor is not available, for most applications a constant pressure value for the site can be used without significantly affecting the resulting vapor pressure calculation.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"WetDryBulb({Dest},{DryTemp},{WetTemp},{Pressure})"


def WorstCase(
    TableName: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumCases: Constant,
    MaxMin: Literal["0", "1"],
    Change: Constant,
    RankVar: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/worstcase.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/worstcase.htm).

                To use WorstCase, a DataTable sized to hold one data storage event must be created to act as the event buffer. Data can be stored to the table using the DataEvent instruction or some other trigger condition.
    The user must create an algorithm in the program by which to test the WorstCase event. The algorithm should calculate a numerical ranking value of the event, which is stored as a variable.
    When WorstCase is executed, it checks the ranking variable. When checking for Max Worst Cases (MaxMin option set to 1), if the current value of the ranking variable has a higher value than the lowest ranked WorstCase DataTable clone's recorded ranking variable, then the new data in the event DataTable will replace the data in this clone.
    When checking for Min Worst Cases (MaxMin option set to 0), if the current value of the ranking variable has a lower value than the highest ranked WorstCase DataTable clone's recorded ranking variable, then the new data in the event DataTable will replace the data in this clone.
    Multiple WorstCase events can be saved. The number of WorstCase events is specified with the NumCases variable. A separate table is created for each of the WorstCase events. These tables use the name of the DataTable with a two-digit number appended to the end (i.e., a table called Temp's WorstCase tables will be named Temp01, Temp02, Temp03…). An additional table, nameWC (e.g., TempWC), stores the rank variable values for each of the worst case tables as well as the last time to which each table was written.
    WorstCase must be used with data tables sent to the CPU.  It will not work if the event table is sent to the PC card (CardOut).
    The same data will not be written to two WorstCase Tables. If a trigger has occurred without the requisite number of pre-trigger records since the last event, the DataTable will not have the specified number of records.
    If the data storage event table is stored on a memory card all the worst case tables will be stored on the same card. Because the WorstCase instruction requires the capability of erasing and writing over data, CPU Flash memory cannot be used with WorstCase.

    Args:
                    TableName (Variable | Constant | Expression | Array | Integer | ConstantInteger): The TableName parameter is the name of the DataTable for which to create WorstCase Events. The name should be 4 characters or less so that the complete names of the worst case tables are retained when collected.

            NumCases (Constant): The number of “worst cases" to store. A separate table is created for each worst case. The tables use the name of the DataTable with a two-digit number appended to the end (i.e., a table called Temp's WorstCase tables will be named Temp01, Temp02, Temp03…). The numbers give the tables unique names, they have no relationship to the ranking of the events.

            MaxMin (Constant): A constant that is entered to specify whether the maximum or minimum events should be saved. Right-click to display a drop-down list box.
      Must be one of following options: 0 (Min, save the events associated with the minimum rank variable; i.e., copy if Trigger is less than previous maximum (over event with previous maximum).), 1 (Max, save the events associated with the maximum ranking variable; i.e., copy if Trigger is greater than previous lowest (over event with previous minimum).)

            Change (Constant): The minimum change that must occur in the RankVariable before a new worst case is stored.

            RankVar (Variable): The Variable by which to rank the events. Right-click to display a drop-down list box of defined variables.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"WorstCase({TableName},{NumCases},{MaxMin},{Change},{RankVar})"


def WriteIO(Mask: Integer, Source: Variable) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/writeio.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/writeio.htm).

                By default, 5 V is applied to the port when the State is set high. Use the PortPairConfig instruction to set the output to 3.3 V.
    There are 8 digital control ports available on the datalogger. The WriteIO instruction is used to set these ports using a binary number where a high port (+5 V) equals to 1 and a low port (0 V) equals to 0. For example, if ports 1 and 3 are to be set high and the remaining ports are to be low, the binary representation is 00000101, or decimal 5.
    This instruction is not controlled by the task sequencer, but is controlled by processing. Therefore this instruction can be placed within a conditional statement. It should be remembered that processing can lag multiple scans behind measurements. See also PortSet.
    NOTE: Programs with WriteIO will compile in sequential mode unless put into pipeline mode using the PipelineMode instruction. Because WriteIO runs as a processing task, when run in PipelineMode port changes may not occur in synchrony with measurements being made. Thus in PipelineMode, the instruction should not be used to control power to sensors from which measurements are being made.

    Args:
                    Mask (Integer): The Mask parameter is used to select which of the ports to read or write. It is a binary representation of the ports. WriteIO: If a port position in the mask is set to 1, the datalogger sets the port based on the value for that port in the Source. If a port position in the mask is set to 0 the value in the Source is ignored. Binary numbers are entered into CRBasic by preceding the number with "&B". For example, if the mask is entered as &B110 (leading zeros can be omitted in binary format just as in decimal) and the source is 5 decimal (binary 101) port 3 will be set high and port 2 will be set low. The mask indicates that only 3 and 2 should be set. While the value of the source also has a 1 for port 1, it is ignored because the mask indicates 1 should not be changed. ReadIO: If a port position is set to 1, the datalogger reads the status of the port. If a port position is set to 0 the datalogger ignores the status of the port (the Mask is "anded" with the port status; the "and" operation returns a 1 for a digit if the Mask digit and the port status are both 1, and a 0 if either or both is 0). CRBasic allows the entry of numbers in binary format by preceding the number with "&B". For example, if the Mask is entered as &B100 (leading zeros can be omitted in binary format just as in decimal) and ports 3 and 1 are high, the result of the instruction will be 4 (decimal, binary = 100); if port 3 is low, the result would be 0.

            Source (Variable): The name of the Variable that is the input for the instruction. Right-click the parameter to display a list of defined variables. For the WriteIO instruction, the Source parameter is a constant or the variable that holds the value for setting the control ports. The Source value is interpreted as a binary number and the ports are set accordingly.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"WriteIO({Mask},{Source})"


def WindVector(
    Reps: Constant,
    SpeedEast: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    DirectionNorth: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
    DataType: Literal[
        "String",
        "Boolean",
        "BOOL8",
        "Long",
        "NSEC",
        "UINT1",
        "UINT2",
        "UINT4",
        "FP2",
    ],
    DisableVar: Variable | Constant | Expression,
    Subinterval: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SensorType: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    OutputOpt: Literal["0", "1", "2", "3", "4"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/windvector.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/windvector.htm).

                Data can be processed from either polar (wind speed and direction) or orthogonal (fixed East and North propellers) wind sensors. Two different algorithms are available to calculate wind vector direction, one of which is weighted for wind speed.
    Call the output table conditionally (for example, do not call the table if a variable = NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN.) to keep NANs from affecting the other good values.
    If the DisableVar is true for the entire output interval, NAN is stored.
    If one or more NAN values are included in the wind speed values being processed, NAN is output for wind speed, 0 is stored for wind direction and standard deviation, and NAN is stored for mean wind vector magnitude.
    If one or more NAN values are included in the wind direction values being processed, but the wind speed values are good, the good values will be output for wind speed, 0 is stored for wind direction and standard deviation, and NAN is stored for mean wind vector magnitude.
    Note that since there is no such thing as NAN for integers, values that are converted from float to integer are expressed in data tables as the most negative number for a given data type. For example, the most negative number of data type FP2 is -7999, so NAN for FP2 data will appear in a data table as -7999.  If the data type is Long, NAN will appear in the data table as -2147483648.
    When processing scalar mean wind speed, the WindVector() instruction includes any zero-wind-speed measurements. In contrast, because vectors require magnitude and direction, measurements at zero wind speed are not used in vector speed or direction calculations.

    Args:
                    Reps (Constant): The number of repetitions for the measurement or instruction. For the WindVector instruction, the Reps are the number of wind vector averages to calculate. If the Reps parameter is greater than 1, arrays must be specified for the Speed/East and Direction/North parameters. If not, a Variable Out of Bounds error is returned when the program is compiled.

            Speed/East (Variable | Constant | Expression | Array | Integer | ConstantInteger): Enter the source variable for the wind speed (for a polar sensor) or East direction (for an orthogonal sensor). If Reps is greater than 1, this parameter must be an array dimensioned large enough to accommodate the repetitions. This parameter is ignored at compile time when OutputOpt 3 or 4 is used. However, a wind speed variable that is dimensioned to at least the number of repetitions in the instruction must be entered or a compile error will result.

            Direction/North (Variable | Constant | Expression | Array | Integer | ConstantInteger): Enter the source variable for the wind direction (for a polar sensor) or North direction (for an orthogonal sensor). If Reps is greater than 1, this parameter must be an array dimensioned large enough to accommodate the repetitions.

            DataType (Constant): A code to select the data storage format.  Right-click the parameter to display a list. Additional data types are available. However, not all data types are suitable for all output instructions, so they should be used with care.  UINT1: Holds an 8-bit unsigned integer (a number in the range of 0 - 32,767, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 8-bit integers since it requires only one byte of memory in a data table. Floating point values are converted to UINT1 as if the INT function were used. UINT2: Holds a 16-bit unsigned integer (a number in the range of 0 - 65535, where NAN values are stored as 0). The program should be written to check for values outside the range. This data type is an efficient means of storing 16-bit integers since it requires only two bytes of memory in a data table. Floating point values are converted to UINT2 as if the INT function were used. UINT4: Holds a 32-bit unsigned integer (a number in the range of 0 to 4,294,967,295). Long: Sets the output to a 32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647 (31 bits plus the sign bit). There are two possible reasons a user would use this format: (1) speed, since the OS can do math on integers faster than with floats, and (2) resolution, since the Long has 31 bits compared to the 24-bits in the IEEE4. However, in most instances it is not suitable for output since any fractional portion of the value is lost. BOOL8: Used to store variables that hold bits (0 or 1) of information. These values are shown in LoggerNet or other datalogger software as an array of eight Boolean values (each element in the array represents one bit). This data type uses less space than normal 32-bit values. Any reps stored must be divisible by two, since an odd number of bytes cannot be stored in a data table. When converting from a Long or a Float to a BOOL8, only the least significant 8 bits are used. NSEC: An 8-byte time stamp format (4 bytes of seconds since 1990, 4 bytes of nanoseconds into the second) used when the variable being sampled is the result of the RealTime instruction or when the variable is a Long storing time since 1990 (for instance, when using TableName.TimeStamp). If the variable array is dimensioned to 7, the values stored will be year, month, day of year, hour, minutes, seconds, and milliseconds. The variable array must be declared as a Float or Long. If the variable array is dimensioned to two and declared as a Long, the instruction assumes that the first element holds seconds since 1990 and the second element holds microseconds into the second. If the source is a single variable dimensioned as a Long, the instruction assumes that the variable holds seconds since 1990 and the microseconds into the second is 0. In this instance, the value stored is a standard datalogger timestamp rather than the number of seconds since January 1990.
      Must be one of following options: String (ASCII string; size defined by program), Boolean (0 = False; -1 = True), BOOL8 (1-byte Boolean value), Long (32-bit long integer, ranging from -2,147,483,648 to +2,147,483,647), NSEC (8-byte time stamp format), UINT1 (One-byte unsigned integer), UINT2 (Two-byte unsigned integer), UINT4 (Four-byte unsigned integer)

            DisableVar (Variable | Constant | Expression): A Constant, Variable, or Expression that is used to determine whether the current measurement is included in the output saved to the DataTable. Right-click the parameter to display a list. 0 = Process current measurementNon-zero = Do not process current measurement. NOTE:  For all instructions except Totalize, if the disable variable is true over the entire output interval, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. will be stored. For Totalize, if the disable variable is true over the entire output interval, 0 will be stored See also Multipliers, Offsets, and Disable Variables with Repetitions.

            Subinterval (Variable | Constant | Expression | Array | Integer | ConstantInteger): The Subinterval parameter is used to determine how the standard deviation will be averaged. 0 can be entered to use every sample taken during the output period, or a subinterval value can be entered to process standard deviations from shorter intervals of the output interval. Averaging subinterval standard deviations minimizes the effects of meander under light wind conditions. Standard deviation of horizontal wind fluctuations from sub-intervals is calculated as follows:  Where  is the standard deviation over the data storage interval and …  are sub-interval standard deviations. A subinterval is specified as a number of scans. The number of scans for a subinterval is given by: Desired subinterval (sec) / scan rate (sec) If the scan rate is 1 sec and the DataInterval is 60 minutes, the standard deviation is calculated for all 3600 scans when the subinterval is 0. With a subinterval of 900 scans, the standard deviation is the average of the four subinterval standard deviations. The last subinterval is weighted if it does not contain the specified number of scans.

            SensorType (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to define the type of sensor that is being measured. 0 = polar sensor; 1 = orthogonal sensor.

            OutputOpt (Variable | Constant | Expression | Array | Integer | ConstantInteger): Used to define the values which will be stored. All output options for this instruction result in an output array. The elements of the array have “_WVc(n)” as a suffix, where n is the element number. The array uses the name of the Speed/East variable as its base. For details on wind speed and unit vector calculations, see Wind Vector Calculations. The FieldNames instruction can be used to assign individual labels to the elements in the array. In addition, when FieldNames is used, the units for the Direction outputs will be listed as Degs in the data table header. The first output, speed, will reflect the Units designation for that variable if one is present in the program. If Units is not designated, the units field for that variable in the data table header will be blank. Note that a separate variable with a Units assignment can be dimensioned for wind speed, and that variable can be used in the FieldNames instruction; for example, FieldNames ("mean_wind_speed, mean_wind_direction, std_wind_dir")Dim mean_wind_speed : Units mean_wind_speed = m/s
      Must be one of following options: 0 (Mean horizontal wind speed (WVc(1)), unit vector mean wind direction (WVc(2)), and standard deviation of wind direction (WVc(3)). Standard deviation is calculated using the Yamartino algorithm. This option complies with EPA guidelines for use with straight-line Gaussian dispersion models to model plume transport.), 1 (Mean horizontal wind speed (WVc(1)) and unit vector mean wind direction (WVc(2)).), 2 (Mean horizontal wind speed (WVc(1)), mean wind vector magnitude (WVc(2)), resultant mean wind direction (WVc(3)), and standard deviation of wind direction (WVc(4)).  Standard deviation is calculated using the Campbell Scientific wind speed weighted algorithm. Use of the mean wind vector magnitude is not recommended for straight-line Gaussian dispersion models, but may be used to model transport direction in a variable-trajectory model.), 3 (Unit vector mean wind direction (WVc(1)).), 4 (Unit vector mean wind direction (WVc(1)) and standard deviation of wind direction (WVc(2)). Standard deviation is calculated using Campbell Scientific's wind speed weighted algorithm. Use of the mean wind vector magnitude is not recommended for straight-line Gaussian dispersion models, but may be used to model transport direction in a variable-trajectory model.)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"WindVector({Reps},{SpeedEast},{DirectionNorth},{DataType},{DisableVar},{Subinterval},{SensorType},{OutputOpt})"


def Network(
    ResultCode: Variable | Array,
    Reps: Constant,
    BeginAddr: Variable | Integer,
    TimeIntoInterval: Constant,
    Interval: Constant,
    Gap: Constant,
    GetSwath: Constant,
    GetVariables: Literal["Destination", "Destination", "Destination", "Destination"],
    SendSwath: Constant,
    SendVariable: Literal["Destination", "Destination", "Destination"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/network.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/network.htm).

    Args:
                  ResultCode (Variable | Array): The variable in which a response code for the transmission will be stored. Each time the Network instruction is executed, the ResultCode for each destination device is incremented by 1. When a response is received back from a destination device, the ResultCode is set to -1. If the Reps parameter (the number of destination devices) is greater than one, then ResultCode should be dimensioned as an array large enough to accommodate a result from each of the destination devices.

          Reps (Constant): The number of destination dataloggers with which the host datalogger will be communicating.

          BeginAddr (Variable | Integer): The PakBus address of the first destination datalogger with which the host will be communicating. If the addresses for the devices to be communicated with using this instruction are in sequential order, BeginAddr can be a scalar variable containing the address of the first device. If the addresses are not in sequential order, BeginAddr is an array declared as type Long, where each element of the array contains the PakBus address of a device to be communicated with.  NOTE: By default, Campbell Scientific software uses the following PakBus addresses: LoggerNet 4094, VisualWeather 4094, PC400 4093, PC200W 4092, PConnect/PConnectCE 4091, RTDAQ 4090, Device Configuration Utility 4089.

          TimeIntoInterval (Constant):  The TimeIntoInterval parameter is used along with the Interval parameter to provide a time to the destination dataloggers by which they all must communicate. The TimeIntoInterval is essentially a maximum offset for the interval parameter  (for example, if the interval is 60 seconds and the TimeIntoInterval is 15, communication should be completed by 15 seconds after the top of the minute, each minute). This value is entered in seconds.

          Interval (Constant): Specifies how often the destination dataloggers should send data back to the host. This value is entered in seconds. It should be the same interval as the scan interval, or an even interval into the scan interval.

          Gap (Constant): Used to specify a delay, in seconds, between communication from each of the destination dataloggers. If 0 is entered, the default value, based on the host datalogger's routing table, will be used. If a negative number is entered, no delay will occur between the data transmission by each of the destination dataloggers.

          GetSwath (Constant): Specifies the number of values that will be received from the destination datalogger. If values are being received from multiple destination devices, this is the number from each destination device.

          GetVariables (Variable): The variable or variable array in which values retrieved from the destination datalogger will be stored. If multiple values are being retrieved from multiple dataloggers, this parameter must be dimensioned to a multi-dimensional array large enough to accommodate the values returned. For example, if 2 values are being returned by each of 4 destination devices, the variable should be dimensioned to (4, 2).
    Must be one of following options: Destination (Destination device 1, value 2 = (1, 2)), Destination (Destination device 2, value 2 = (2, 2)), Destination (Destination device 3, value 2 = (3, 2)), Destination (Destination device 4, value 2 = (4, 2))

          SendSwath (Constant): Specifies the number of values that will be sent to the destination datalogger. If values are being sent to multiple destination devices, this is the number being sent to each destination device.

          SendVariable (Variable): The variable(s) that will be sent from this datalogger to the destination datalogger(s). If sending a Public variable that has been Aliased, either the Alias or the original variable name can be used. If multiple values are being sent to multiple destination dataloggers, this parameter must be a multi-dimensional array containing the values to be sent to each destination device. For instance, if you are sending 2 values to each of 3 destination devices, the variable should be dimensioned to (3, 2). The results would be: NOTE: This instruction does not initiate communication with the destination dataloggers; communication is initiated by the destination devices using the SendGetVariables instruction.
    Must be one of following options: Destination (Destination device 1, value 2 = (1, 2)), Destination (Destination device 2, value 2 = (2, 2)), Destination (Destination device 3, value 2 = (3, 2))

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Network({ResultCode},{Reps},{BeginAddr},{TimeIntoInterval},{Interval},{Gap},{GetSwath},{GetVariables},{SendSwath},{SendVariable})"


def NetworkTimeProtocol(
    NTPServer: Constant, NTPOffset: Variable | Constant, NTPMaxMSec: Variable | Constant
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/networktimeprotocol.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/networktimeprotocol.htm).

                Network Time Protocol, or NTP, is an internet protocol that can be used for clock synchronization between devices over a network. The protocol uses Coordinated Universal Time (UTC) as the basis for the synchronization. The datalogger can use network time protocol (NTP) to set its clock, and it can also act as an NTP server.
    The NetworkTimeProtocol function returns the measured clock error in milliseconds, prior to the clock adjustment. If the command fails, NAN Not a number. A data word indicating a measurement or processing error. Voltage overrange, SDI-12 sensor error, and undefined mathematical results can produce NAN. is returned. The timeout for this instruction is 70 seconds; the command will fail if no response is received within the timeout period.

    Args:
                    NTPServer (Constant): The IP address or qualified domain name for the Internet time server. The entry must be enclosed in quotes. If a domain name is used, the IP address for a DNS must be set in the datalogger. Enter a null string, "", if the NetworkTimeProtocol function is being used only to establish a time offset when the datalogger acts as an NTP server.

            NTPOffset (Variable | Constant): The NTPOffset parameter is used to specify an offset, in seconds, from Universal Time that should be used when the clock is set; for example, Mountain Standard Time in the U.S. is -7GMT, so the offset would be -25,200 (-7*3600). If the datalogger setting "UTC Offset" is set to a value other than -1 (disabled), this offset parameter will be ignored and the UTC Offset value in the datalogger will be used.

            NTPMaxMSec (Variable | Constant): The maximum time, in milliseconds, that the datalogger's clock can differ from the Internet time server without triggering a clock set.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"NetworkTimeProtocol({NTPServer},{NTPOffset},{NTPMaxMSec})"


def XMLParse(
    XMLContent: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    XMLValue: Variable,
    AttrName: Variable,
    AttrNameSpace: Variable,
    ElemName: Variable,
    ElemNameSpace: Variable,
    MaxDepth: Constant,
    MaxNameSpaces: Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/xmlparse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/xmlparse.htm).

        This function returns one of the following:

    Args:
            XMLContent (Variable | Constant | Expression | Array | Integer | ConstantInteger): The XMLContent parameter is the XML content to be parsed. It can represent either a file name (using the format DeviceName:FileName) or it can represent a null terminated string that contains the XML content to be parsed.

    XMLValue (Variable): The XMLValue parameter returns the value of an XML attribute when a response code of 2 is returned or it can return the value of the element content (otherwise known as its CDATA) when a result of 3 is returned.

    AttrName (Variable): The AttrName parameter returns the name of an XML attribute when a result of 2 is returned.

    AttrNameSpace (Variable): The AttrNameSpace parameter returns the namespace URI of an XML attribute when a result of 2 is returned.

    ElemName (Variable): The ElemName parameter returns the name of an XML element when a result of 2, 3, or 4 is returned.

    ElemNameSpace (Variable): The ElemNameSpace parameter returns the namespace URI of an XML element when a result of 2, 3, or 4 is returned.

    MaxDepth (Constant): The MaxDepth parameter controls, in part, the amount of memory that will be allocated for the parser. This value must be at least one greater than the anticipated maximum nesting depth of XML elements. For example, the CSIXML format, which has a maximum nesting depth of 4 elements, would require a minimum of 5 for this value. If too small of a value is specified, the parser may return a value of -2 while parsing the document.

    MaxNameSpaces (Constant): The MaxNameSpaces parameter controls, in part, the amount of memory that will be allocated for the parser. This value must be greater than equal to one or the maximum number of namespaces that are anticipated to be in the document. For instance any document that is exchanged using the SOAP protocol will likely have at least two namespaces. If too small a value is specified, the parser will return a value of -3 while parsing the document.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"XMLParse({XMLContent},{XMLValue},{AttrName},{AttrNameSpace},{ElemName},{ElemNameSpace},{MaxDepth},{MaxNameSpaces})"


def TypeOf(
    TypeVar: Literal["1", "2", "3", "6", "7", "9", "11", "14", "17", "18", "28"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/typeof.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/typeof.htm).

    Args:
                  TypeVar (Variable): The variable for which to return the data type code. If the TypeVar parameter passed in is not a simple variable (i.e., is an expression or a constant) then 0 is returned.  See the following list for the data type code returned for different variable or data types. Note that these data type codes are for the CR1000X dataloggers that use big-endian Endianness refers to byte order.  With the little-endian format, bytes are ordered with the least significant byte (the "little end") first.  With the big-endian format, bytes are ordered with the most significant byte ("big end") first. The CR300, GRANITE 9, and GRANITE 10 dataloggers use the little-endian format. The CR800, CR1000, CR3000, CR6, CR1000X, and GRANITE 6 use the big-endian format. Byte order when sending string variables as serial data is identical in big-endian and little-endian CSI dataloggers. Only numeric values sent as multiple bytes require attention to big-endian and little-endian issues. format. Dataloggers that use little-endian format (for example, CR300, CR350, GRANITE 9, GRANITE 10) return different data type codes.
    Must be one of following options: 1 (UINT1 – One-byte unsigned integer), 2 (UINT2 – Two-byte unsigned integer with most significant byte first), 3 (UINT4 – Four-byte unsigned integer with most significant byte first), 6 (Long - 32-bit integer with most significant byte first), 7 (FP2 - Two-byte floating point in final storage format), 9 (IEEE4 -  Four-byte floating point in big-endian format), 11 (String - ASCII string), 14 (NSec – a composite of two Int4 values that represent a time stamp as seconds since midnight 1 January 1990 and nanoseconds into the second, respectively), 17 (Bool8- a bit field of 8 bits used for representing ports and flags), 18 (IEEE8 – Eight-Byte double-precision, 64-bit floating-point value), 28 (Boolean – 4-byte value where 0 is false and any other value is true)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"TypeOf({TypeVar})"


def CurrentSE(
    Dest: Variable | Array,
    Reps: Constant,
    Range: Literal["mV1000", "mv200", "Autorange"],
    RGChan: Constant,
    MeasOff: Literal["0", "1"],
    SettlingTime: Constant,
    fN1: Literal["15000", "60", "50"],
    Mult: Variable | Constant | Expression | Array,
    Offset: Variable | Constant | Expression | Array,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/currentse.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/currentse.htm).

                The datalogger has built-in 101 ohm  shunt resistors on RG1 and RG2 that allow  the datalogger to measure a 4 to 20 mA sensor. The 101 ohm shunt resistance is a 91 ohm resistor in series with a 10 ohm resistor. The instruction measures differentially across the 10 ohm resistor.
    The maximum valid measurement range is + 80 mA. For current beyond + 80 mA, protection circuitry will affect the measurement.

    Args:
                    Dest (Variable | Array): The Variable in which to store the results of the instruction. Right-click the parameter to display a list of defined variables.  If this instruction has a Repetitions parameter and it is greater than 1, the results are stored in an array with the variable name. The array must be dimensioned large enough to hold all of the values returned from all of the Reps.

            Reps (Constant): The number of repetitions for the measurement or instruction. For the CurrentSE instruction, measurements are made on consecutive channels. If the Reps parameter is greater than 1, the Dest parameter must be a variable array.

            Range (Constant): The expected input from the sensor. To choose the appropriate range, multiply the expected current by 10 (ohms). Right-click the parameter to display a list or enter the code directly. For signals that do not fluctuate too rapidly, AutoRange allows the datalogger to automatically choose the input voltage range. AutoRange results in two voltage measurements being performed. The first voltage measurement is done quickly at a first notch frequency (fN1) of 50 kHz, the result of which determines the input voltage range to use for the second measurement. Autorange should not be used if fast measurements are required or if the analog signal could change significantly over the course of the measurement.
      Must be one of following options: mV1000 (+1000 mV), mv200 (+200 mV), Autorange (Datalogger tests for and uses most suitable range)

            RGChan (Constant): The resistive ground channel number on which to make the first measurement, RG1 or RG2.

            MeasOff (Constant): Determines whether the ground offset voltage is measured before the measurement is made on the analog channel. If the ground offset is measured it is subtracted from the sensor measurement and the result is stored in Dest.
      Must be one of following options: 0 (Offset voltage is corrected from background calibration.), 1 (Offset voltage is measured each scan  (this option
    effectively increases the measurement time as if an additional rep were added to
    the instruction).)

            Settling Time (Constant): The settling time is the duration (in microseconds) to allow for signal settling after setting up a measurement (switching to the channel, setting the excitation) and before making the measurement. Minimum settling time is 20 microseconds; maximum settling time is 600 ms. If 0 is entered, a default of 500 microseconds is used. Additional settling time may be necessary to allow the signal to settle with high resistance or long lead lengths (higher capacitance). The time it will take to make the measurement will include the measurement itself, the SettlingTime, fN1, and whether or not parameters are set to remove voltage offset errors. Using either RevDiff or RevEx causes two SettlingTimes to occur per channel; four SettlingTimes will occur when using both RevDiff and RevEx.

            fN1 (Constant): Determines the lowest frequency that will be eliminated or notched out by the sinc filter. This filter notches out frequencies at integer multiples of fN1 by averaging for a time equal to 1/fN1; thus, lower fN1 frequencies result in longer measurement times. Set  fN1 to the lowest frequency that should be filtered out. For example, setting  fN1 to 60 filters all multiples of 60 and above (60, 120, 180, etc.) but will not effectively filter lower frequencies; for example 30 Hz.  Any value between 0.5 Hz and 31.25 kHz can be entered, but common options for filtering noise are:
      Must be one of following options: 15000 (Performs a 0.0667 millisecond integration (for fast measurements)), 60 (Performs a 16.67 millisecond integration (filters 60 Hz noise)), 50 (Performs a 20 millisecond integration (filters 50 Hz noise))

            Mult (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

            Offset (Variable | Constant | Expression | Array): Factors by which to scale the raw results of the measurement. Typically used to convert the raw measurement to engineering units or to units other than which is output. For example, the TCDiff instruction measures a thermocouple and outputs temperature in degrees C. A multiplier of 1.8 and an offset of 32 will convert the temperature to degrees F. For temperature measurements, a multiplier (mult) of 1 and an offset of 0, would output in degrees Celsius. For analog measurements, a multiplier (mult) of 1 and an offset of 0, would output the measured voltage in millivolts divided by the excitation voltage in volts. If Repetitions of greater than 1 are used for this instruction, Repetitions can also be used for the Multiplier and Offset. See Multipliers, Offsets, and Disable Variables with Repetitions for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"CurrentSE({Dest},{Reps},{Range},{RGChan},{MeasOff},{SettlingTime},{fN1},{Mult},{Offset})"


def Matrix(
    Option: Literal["1", "2", "3", "4", "5"], A: Variable, B: Variable, Result: Variable
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/matrix.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/matrix.htm).

                The maximum size of the matrix is 4 x 4.
    A, B, and Result are two-dimensional arrays (matrices). The Option can be:
    The dimensions of A(m,n), B(p,q), Result(r,s) are restricted as follows:
    NOTE: Options 4 and 5 (Transpose and Inverse) do not use B.
    NOTE:     If the determinant of A is 0 for Inverse(A), NAN will result.

    Args:
                    Option (Variable | Constant | Expression | Array | Integer | ConstantInteger): Specifies the matrix operation to perform with the two-dimensional arrays, A and B. The Option can be:
      Must be one of following options: 1 (Result = A + B), 2 (Result = A - B), 3 (Result = A * B), 4 (Result = Transpose(A)), 5 (Result = Inverse(A))

            A (Variable): Two- dimensional array for matrix math.

            B (Variable): Two- dimensional array for matrix math.

            Result (Variable): Two-dimensional array holding the result of matrix math performed with arrays A and B.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Matrix({Option},{A},{B},{Result})"


def Gzip(Filename: Constant, ZippedFilename: Constant) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/gzip.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/gzip.htm).

                The Gzip instruction is commonly placed in a conditional statement and triggered with a variable flag. Zipping a file may take several seconds to minutes, depending on file size. Zipping a file has the potential to significantly reduce its size. The amount of reduction realized depends mainly on the number and proximity of redundant blocks of information in the file. Note that compression has little effect on an encrypted program (FileEncrypt in the CRBasic Editor), since the encryption process does not produce a large number of repeatable byte patterns. Additionally, GZip has little effect on files that already employ compression such as JPEG or MPEG-4. For other file types, a reduction in file size means fewer bytes are transferred when sending a file. This reduction can have a significant impact on transfer times over slow or high latency links or cost when utilizing "pay by the byte" data plans. Those using low-baud-rate terrestrial radio, satellite, or restricted cellular data plans should consider zipping programs, data, and operating systems before sending. The CR1000X also supports Gzip extract. Click here for more information.
    The Gzip function returns the number of files successfully compressed or an error code. Error codes are: -1  if there is not enough room to store the file or -10 if the file cannot be opened (for example, the file is missing or is named differently than specified).
    NOTE: It may take several minutes to complete compression of large files or multiple small files. A flag may be set in the program to indicate when compression is done.

    Args:
                    Filename (Constant): Specifies the name of the file, or files, to be zipped/compressed. FileName must be a constant and enclosed in quotes. It is entered in the format of "Device:FileName" where Device is CRD: (memory card), USR: (user-defined drive), or USB: (SC115). If more then one file is to be compressed, this is a comma-separated list. For example, "CRD:FileName1,CRD:Filename2,CRD:Filename3".

            ZippedFilename (Constant): Specifies the name of the resulting zipped file. If compression is successful, .gz will be appended to the file name. If more than one file is zipped, .tar is appended first and then .gz. For example, ZippedFiles.tar.gz.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"Gzip({Filename},{ZippedFilename})"


def StructureType(
    Name: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/structuretype.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/structuretype.htm).

                Each StructureType is given a name. The StructureType name is limited to 20 characters and must start with an alphabetical character. Note that the StructureType name cannot be any of the predefined table names in the datalogger; that is, Public, Status, Settings, or DataTableInfo.  Multiple structures may be declared as the same StructureType.
    The StructureList consists of a comma-delimited or a line-separated list of variables or variable arrays that will be grouped together into one StructureType.  Variable types supported are Float, Long, String, Boolean, and Double. If a variable within the StructureType is to be used as the destination for a measurement instruction, the variable should be declared as type Float and as read only, with the ReadOnly() instruction.
    After a StructureType is defined, it is assigned to a structure. Structures may be declared as Public or Dim. When declared as Public, structures can be viewed and manipulated remotely, similar to constants in a ConstTable.
    Structures can also be accessed programmatically using Structure.Structure-variable syntax, which is analogous to Tablename.Fieldname syntax. Structure variables may be initialized just like any other variable.
    Structures may also be passed into subroutines, used within functions or with pointers (that is., pointers may point to structures, see Pointer-to-Structure Example).
    The EndStructureType statement marks the end of the StructureType definition.

    Args:
                    Name (Variable | Constant | Expression | Array | Integer | ConstantInteger): The name for the StructureType. The name is limited to 20 characters and must start with an alphabetical character. Note that the StructureType name cannot be any of the predefined table names in the datalogger; that is, Public, Status, Settings, or DataTableInfo.  Multiple structures may be declared as the same StructureType.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"StructureType({Name})"


def Quadrature(
    Dest: Variable | Array,
    Port: Literal["C1", "C3", "C5", "C7"],
    Option: Literal["0", "1", "2"],
    Mult: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/quadrature.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/quadrature.htm).

              The Quadrature instruction is used with single ended type (A and B) quadrature encoders. A digital port pair is used to monitor the two control tracks of the encoder. The instruction calculates the displacement and direction of the encoder.

    Args:
                  Dest (Variable | Array): The variable array in which to store the results of the measurement. Dest must be dimensioned to four to hold the following values: Dest(1): Accumulator. Net number of counts from channel A and channel B. Count will increase if Channel A leads Channel B. Count will decrease if Channel B leads Channel A. Dest(2): Net direction. Indicates direction if a change occurs. 1 = A change in pulse count has occurred, where A is leading B since the last stop in pulse count. 0 = No change (default). -1 = A change in pulse count has occurred, where B is leading A since the last stop in pulse count. Dest(3): Number of counts in direction 1 (A leading B) that have occurred since the last time the instruction was executed.Dest(4): Number of counts in direction 2 (B leading A) that have occurred since the last time the instruction was executed.

          Port (Constant): Specifies which digital port pair to use for monitoring sensor channels A and B, respectively. Valid ports are:
    Must be one of following options: C1 (Control Ports 1 and 2), C3 (Control Ports 3 and 4), C5 (Control Ports 5 and 6), C7 (Control Ports 7 and 8)

          Option (Constant): Determines how each channel is counted.
    Must be one of following options: 0 (X1 - Counts will increase on rising edge of Channel A when Channel A leads Channel B. Counts will decrease on falling edge of Channel A when Channel B leads Channel A.), 1 (X2 - Counts will increase at each rising and falling edge of Channel A when Channel A leads Channel B. Counts will decrease at each rising and falling edge of Channel A when Channel A leads Channel B.), 2 (X4 - Counts will increase at each rising and falling edge of both channels when Channel A leads Channel B. Counts will decrease at each rising and falling edge of both channels when Channel B leads Channel A.)

          Mult (Variable | Constant | Expression | Array | Integer | ConstantInteger): Constant, variable, array, or expression by which to scale the results of the measurement.

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"Quadrature({Dest},{Port},{Option},{Mult})"


def SMSRecv(
    Result_Code: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    PhoneNumber: Variable,
    Message: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    TimeStamp: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/smsrecv.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/smsrecv.htm).

                NOTE: Note that SMSRecv requires a cellular account that includes text messaging capabilities. Many cellular accounts do not include text messaging.
    The SMSRecv function queries the modem for new SMS messages. The function returns True (-1) if a message is successfully retrieved.  If no messages are found, the function returns False (0) and the PhoneNumber, Message and TimeStamp variables will be cleared.  If the datalogger successfully retrieves a message, the message will be deleted from the modem.
    NOTE: SMSRecv has a 10 second timeout. It is recommended to place SMSRecv in a slow sequence scan where it will run in the background and not hold up the main program while the datalogger waits for the transaction to complete.
    If SMSRecv encounters an error, an error code is returned.  The following error codes are possible:
    SMSRecv requires the modem to enter command mode. While the modem is in command mode, cellular IP communication will be paused for a minimum of 2 seconds. When SMSRecv is called in a loop, the first call will change the modem state to command mode and immediate subsequent calls will complete faster because the modem is already in command mode.

    Args:
                    Result_Code (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable of Type Long or Float that holds the result code. See the list above for a description of possible result codes.

            PhoneNumber (Variable): The phone number associated with the received message.

            Message (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string expression containing the text used in the body of the email or text message. For messages being sent, variables can be included in the message using CRBasic's standard string syntax (for example, "The temperature is " + TempVar + " degrees C").

            TimeStamp (Variable | Constant | Expression | Array | Integer | ConstantInteger): A string variable that holds the received message’s timestamp in the format ddd,MM/DD/YYYY HH:MM:SS Where: ddd = three-letter abbreviation for the day of week (for example, Mon)MM/DD/YYYY = Month, day, year (for example, 12/31/2010)HH:MM:SS = Hour, minutes, seconds (for example, 12:00:00) Usage Notes: MMS messages are not supported.    The SMSRecv function pauses cellular IP communication. To minimize communication interuptions, wait between calls of the SMSRecv function. If SMS messages should have a higher priority than IP communication, then SMSRecv may be called more frequently. TableName.FieldName syntax can be used in CRBasic programs to monitor daily and monthly data usage in kilobytes. See Monitoring Cellular Diagnostics and Data Usage Programmatically for more information.    Some internal cellular modem settings may be set programmatically using the SetSetting instruction. See Cellular Modem Settings for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SMSRecv({Result_Code},{PhoneNumber},{Message},{TimeStamp})"


def SMSSend(
    ResultCode: Literal["0", "-1", "-3", "-5", "-6", "-7", "-8", "-9", "-11", "-12"],
    Swath: Variable,
    PhoneNumber: Variable,
    Message: Variable,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/smssend.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/smssend.htm).

                The SMSSend function generates  SMS messages and sends them out on the cellular network.
    SMSSend requires the modem to enter command mode. While the modem is in command mode, cellular IP communication will be paused.
    NOTE:  SMSSend can take up to 5 minutes to send one message.  It is recommended to place SMSSend in a slow sequence scan where it will run in the background and not hold up the main program while the datalogger waits for the transaction to complete.

    Args:
                    ResultCode (Variable | Array): A variable of Type Long or Float that holds the result of the instruction.
      Must be one of following options: 0 (Timed out waiting for a response from the modem.), -1 (Message successfully sent to the network.), -3 (Error response from modem.), -5 (PhoneNumber or Message parameter is an empty string.), -6 (Message sent to the modem, no confirmation response received from the modem.), -7 (Timed out waiting for response from the modem.), -8 (No internal cellular modem installed or modem is off/disabled), -9 (Datalogger timed out waiting for modem to send the message. Message is in Cell2XX queue and may still be sent.), -11 (Send failure. External Cell2XX is powered down), -12 (Array out of bounds)

            Swath (Variable): The number of SMS messages to be sent. The maximum number of messages possible is 60.

            PhoneNumber (Variable): A string variable or string array containing the SMS recipient phone number including the country code and area code. The country code for the United States is 1, so the Phone Number is 1+three-digit area code+seven-digit phone number. Do not include dashes or + symbols in the phone number.  Enclose the phone number in quotes.  For Example:  Public Tx_Number As String = "14351234567"

            Message  (Variable): A string variable or string array  containing the text used in the body of the  text message. For messages being sent, variables can be included in the message using CRBasic's standard string syntax (for example, "The temperature is " + TempVar + " degrees C"). Usage Notes: MMS messages are not supported.    The SMSSend and SMSRecv functions pause cellular IP communication. To minimize communication interruptions, wait between calls of the SMSSend/SMSRecv function. If SMS messages should have a higher priority than IP communication, then SMSSend/SMSRecv may be called more frequently. TableName.FieldName syntax can be used in CRBasic programs to monitor daily and monthly data usage in kilobytes. See Monitoring Cellular Diagnostics and Data Usage Programmatically for more information.    Some internal cellular modem settings may be set programmatically using the SetSetting instruction. See Cellular Modem Settings for more information.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"SMSSend({ResultCode},{Swath},{PhoneNumber},{Message})"


def TCPActiveConnections(
    Dest: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    SecsSinceLastRx: Variable
    | Constant
    | Expression
    | Array
    | Integer
    | ConstantInteger,
    Port: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpactiveconnections.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/tcpactiveconnections.htm).

        The information displayed for each connection is the IP address, TCP port, and the date and time of the last received communication from that IP address on the specified port. The seconds since the last communication received is 0 if the connection is active and increments if the connection becomes inactive. SecsSinceLastRx will be -1 if there is no connection.

    Args:
            Dest (Variable | Constant | Expression | Array | Integer | ConstantInteger):  Variable of Type String in which to store the connection information. The information returned is the IP Address, port number, and time of last connection. If multiple connections are active, the most recent connection is listed first. The list auto re-organizes with the “freshest” connection at the beginning. The format of the list is: IP Address:xxx.xxx.xxx.xxx; Port: xxxx; Time: MM/dd/yyyy hour:min:secs:microsec. If multiple connections are listed, each is shown on a separate line. If the string variable is not sized large enough to hold all the connection information, then only the information that fits into the variable is shown.

    SecsSinceLastRx (Variable | Constant | Expression | Array | Integer | ConstantInteger): A variable or variable array of Type Long which stores how many seconds it has been since something was last received on the specified connection. If the connection is active, this number is 0. If the connection becomes inactive, this number increments. If no connection is made, -1 is returned. If more than one connection is expected on the specified port, SecsSinceLastRX should be declared as an array and each element will contain seconds since last Rx for the corresponding connection in the Dest list. The list auto re-organizes with the “freshest” connections at the beginning.

    Port (Variable | Constant | Expression | Array | Integer | ConstantInteger): Constant or variable of Type Long that specifies the TCP port to monitor. If 0 is entered for the port parameter, then all active TCP connections will be shown.

    Returns:
            str: A string of the CRBasic function call.

    """
    return f"TCPActiveConnections({Dest},{SecsSinceLastRx},{Port})"


def WatchdogTimer(
    Interval: Variable | Constant | Integer,
    Units: Literal["Sec", "Min", "Hr", "Day", "Mon"],
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/watchdogtimer.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/watchdogtimer.htm).

                The Datalogger has several internal “WatchdogTimers” that monitor communication and measurement tasks and in the event that a task takes too long (i.e., something has gone wrong), the datalogger will watchdog and reboot. This guards against lock ups and keeps the system running.  However, programs may contain user-programmed tasks that are not monitored by the built-in internal watchdog timers. If an unmonitored task gets stuck, the datalogger could lock up and not be able to recover. The WatchdogTimer function may be used to safeguard against this scenario.
    To implement the Watchdog timer function, the function is called with the interval parameter set to a non-zero value. If the function is not called again before the last programmed time expires, a watchdog error will occur, and the system will reset. If a zero interval is programmed, the watchdog timer is disabled, and no watchdog will occur.
    The WatchdogTimer returns the time in Seconds to the expiration of the last programmed WatchdogTimer interval. This is useful for the programmer to establish the desired WatchdogTimer interval and find the optimal set point to prevent lock ups.
    If WatchdogTimer is called with no parameters:
    Wdog_Sec = WatchdogTimer()
    It will return the time left before expiring, in seconds, without resetting the timer.
    WARNING: The WatchdogTimer function should be used with caution. Care should be taken to not put the datalogger into an endless loop of watchdogging.

    Args:
                    Interval (Variable | Constant | Integer): The Interval parameter is a constant or variable that designates the time interval between WatchdogTimer scans. Enter 0 to disable the WatchdogTimer and no timeout will occur.

            Units (Constant): Specifies units for the WatchdogTimer interval. Valid units are
      Must be one of following options: Sec (seconds), Min (minutes), Hr (hours), Day (days), Mon (months)

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"WatchdogTimer({Interval},{Units})"


def MQTTConnect(DesiredState: Literal["True", "False"]) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttconnect.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttconnect.htm).

              NOTE: This instruction is not required for a persistent MQTT application.  MQTT will attempt to connect when enabled with the Device Configuration setting.

    Args:
                  DesiredState (Variable | Constant):
    Must be one of following options: True (Attempts to connect MQTT over an available IP connection.), False (Loads the job queue with a disconnect request. The disconnect request will follow any active jobs in the queue. This allows the datalogger to complete the publishing of data before closing the connection.  Since the disconnect request is in a buffered queue, the disconnect will not always happen immediately.)

    Returns:
                  str: A string of the CRBasic function call.

    """
    return f"MQTTConnect({DesiredState})"


def MQTTPublishTable(
    QoS: Variable | Constant | Expression | Array | Integer | ConstantInteger,
    NumRecsTimeIntoInterval: Constant,
    Interval: Constant,
    Units: Constant,
    OutputFormat: Literal["1", "2"],
    Longitude: Variable | Constant,
    Latitude: Variable | Constant,
    Altitude: Variable | Constant,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttpublishtable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttpublishtable.htm).

                MQTTPublishTable will publish the contents of the data table in CSIJSON or the Campbell Scientific version of GeoJSON format.  This is a non-blocking instruction and will not delay CRBasic processing.
    The MQTTPublishTable instruction will publish topics using this  topic structure:
    A /cj is appended to the topic when publishing CSIJSON formatted data. For example:
    This allows the CLOUD ingestion tools to differentiate the format of the incoming data. Data with no /cj is GeoJSON formatted data.
    NOTE:  The maximum MQTT packet size is 4800 bytes.

    Args:
                    QoS (Variable | Constant | Expression | Array | Integer | ConstantInteger): Publish Quality of Service.  Supports levels 0 and 1 per MQTT v3.1.1.  Level 2 is not supported.

            NumRecs/TimeIntoInterval (Constant): If Interval parameter is greater than 0, the NumRecs/TimeIntoInterval parameter specifies the time into the interval at which previously unpublished records should be published  If Interval parameter is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unpublished records that will be published. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will specify the number of records that will published each time the function is called.  The datalogger keeps track of the last record sent in the data table information. This information is maintained even through power-downs, as long at the data table itself in datalogger memory is intact. Examples These MQTTPublishTable parameters publish the most recent 2 data table records, once per minute in the GeoJSON format. DataTable (panelTempC,True,-1)  DataInterval (0,1,Min,10)  Sample (1,crTemp,FP2)  MQTTPublishTable(1,2,0,Sec,2,123.00,123.000,234.000)EndTable These MQTTPublishTable parameters publish the most recent record every 30 seconds in the CSIJSON format.. DataTable (loggerBattery,True,-1)  DataInterval (0,30,Sec,10)  Sample(1,batteryVolt,FP2)  MQTTPublishTable(publishQoS_1,-1,0,Sec,1) EndTable

            Interval (Constant): If Interval is equal to 0, the NumRecs/TimeIntoInterval parameters specifies the number of previously unsent records that will be published. If Interval is equal to 0, a negative NumRecs/TimeIntoInterval parameter will cause the datalogger to send the most recent records up to NumRecs each time the function is called. If  greater than 0, the Interval parameter determines the interval at which previously unsent data will be published. The datalogger keeps track of the last record sent in the data table information. This information is maintained even through power-downs, as long at the data table in datalogger memory is intact.

            Units (Constant): Specifies the units on which the TimeIntoInterval and Interval parameters will be based. The options are seconds, minutes, hours, or days.

            Output Format (Constant): Specifies the format for the published data. CSIJSON Output Format { "head" : {  "transaction" : 0,  "signature" : 49005,  "environment" : {   "station_name" : "321",   "table_name" : "panelTempC",   "model" : "CR1000X",   "serial_no" : "321",   "os_version" : "CR1000X.02.00.2019.02.27.1326",   "prog_name" : "CPU:mqttPub24.CR1X"  },  "fields" : [ {   "name" : "crTemp",   "type" : "xsd:float",   "process" : "Smp",   "settable" : false  } ] }, "data" : [ {  "time" : "2019-02-28T18:45:00",  "vals" : [ 24.73 ] }] } GeoJSON Output Format {   "type": "Feature",    "geometry": {     "type": "Point",     "coordinates": [ "12345.000000", "23456.000000", "345.000000" ]    },    "Properties": {     "loggerID": "CR1000X_400",     "observationNames": ["batteryVolt", "batteryVolt_Avg", "crTemp"],     "observations": {         "2019-02-28T19:00:00.0Z": [13.67, 13.67, 24.31]     }   } } For details, see GeoJSON format details.
      Must be one of following options: 1 (CSIJSON), 2 (Campbell Scientific Version of GeoJSON)

            Longitude (Variable | Constant): A constant or variable that provides the longitude for the datalogger station. 0 to -180 is west of the Greenwich meridian; 0 to 180 is east of the Greenwich meridian.

            Latitude (Variable | Constant): A constant or variable  that provides the latitude for the datalogger station. The range for Latitude is 0 to ±90 (positive value for Northern hemisphere and negative value for Southern hemisphere).

            Altitude (Variable | Constant): A constant or variable  that provides the altitude above sea level for the datalogger station. This value must be in meters.  Optional parameter for GeoJSON format.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MQTTPublishTable({QoS},{NumRecsTimeIntoInterval},{Interval},{Units},{OutputFormat},{Longitude},{Latitude},{Altitude})"


def MQTTPublishConstTable(
    QoS: Variable | Constant | Expression | Array | Integer | ConstantInteger,
) -> str:
    """For a full description of this function, visit [https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttpublishconsttable.htm](https://help.campbellsci.com/crbasic/cr1000x/Content/Instructions/mqttpublishconsttable.htm).

                The table values will be published on the following topic:
    {MQTT Base Topic}/editConst
    To edit the ConstTable via MQTT, publish the new ConstTable values in a JSON object. The JSON keys and the values must be a string.  The string values will be converted to the appropriate types by the datalogger. Only the values of the ConstTable to be changed are required in the JSON object. The JSON object must contain the “cmd” key and “editConst” value.
    {  “cmd”: “EditConst”,  “key1”: “value1”,  “key2”: “value2”}
    To change values in the ConstTable, publish the above JSON object to the following topic:
    {MQTT Base Topic}/CC/editConst
    NOTE:  The maximum MQTT packet size is 4800 bytes.

    Args:
                    QoS (Variable | Constant | Expression | Array | Integer | ConstantInteger): Publish Quality of Service.  Supports levels 0 and 1 per MQTT v3.1.1.  Level 2 is not supported.

    Returns:
                    str: A string of the CRBasic function call.

    """
    return f"MQTTPublishConstTable({QoS})"
